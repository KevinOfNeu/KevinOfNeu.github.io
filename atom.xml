<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>叫兽的博客</title>
  
  <subtitle>思绪偶尔在这里停留</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.0xff000000.com/"/>
  <updated>2019-01-11T08:32:09.898Z</updated>
  <id>https://blog.0xff000000.com/</id>
  
  <author>
    <name>KevinOfNeu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - 计算的通用性</title>
    <link href="https://blog.0xff000000.com/2019/01/11/reading-plan-01-08/"/>
    <id>https://blog.0xff000000.com/2019/01/11/reading-plan-01-08/</id>
    <published>2019-01-11T08:00:00.000Z</published>
    <updated>2019-01-11T08:32:09.898Z</updated>
    
    <content type="html"><![CDATA[<p>通用图灵机的存在是极其有意义的。尽管任何一台个体的图灵机都有一个硬编码的规则手册，但是通用图灵机证明了设计这样一个装置的可能性，这个装置可以通过从纸带读取指令来完成任何任务。这些指令实际上是控制机器硬件运行的软件，就像控制我们每天都在使用的通用可编程计算机的软件一样1。有限和下推自动机有点过于简单，不能支持这种全面的可编程性，但是图灵机具有解决这个问题的足够的复杂性。</p><a id="more"></a><h2 id="lambda-演算通用性"><a href="#lambda-演算通用性" class="headerlink" title="lambda 演算通用性"></a>lambda 演算通用性</h2><p>lambda 演算是一种可用的编程语言，但还没有探讨它是否与图灵机一样强大。事实上，lambda 演算一定至少有那么强大，因为它能够模拟包括通用图灵机（当然包括）在内的任何图灵机。</p><p>通用系统的真正好处是它能被编程以执行不同的任务，而不是总要硬编码来。<br>特别地，通用系统能被编程来模拟任何其他的通用系统；通用图灵机能计算 lambda 演算表达式的值，而 lambda 演算解释器也能模拟图灵机。</p><h2 id="SKI-组合子"><a href="#SKI-组合子" class="headerlink" title="SKI 组合子"></a>SKI 组合子</h2><p>就像 lambda 演算一样，SKI 组合子演算是一个处理表达式语法的规则系统。尽管 lambda 演算已经很简单了，但仍然还有三种表达式：变量、函数和调用。</p><p>SKI 演算更简单，它只有两种表达式：调用和字母符号，规则也更简单。它所有的能力都源于三个特别的符号 S、K 和 I（叫作组合子） ，它们每一个都有自己的归约规则：</p><ul><li>规约成 a[c][b[c]]，其中 a、b 和 c 可以是任意的 SKI 演算表达式；</li><li>K[a][b]规约成 a</li><li>I[a] 规约成 a</li></ul><p>SKI 演算用三个简单的规则就产生了出人意料的复杂行为。事实上，复杂到被证明是通用的了。我们可以证明 SKI 表达式的通用性，方法是展示如何把任意的 lambda 演算表达式转换成做同样事情的一个 SKI 表达式，这实际上也是使用 SKI 演算给了 lambda 演算一个指称语义。我们已经知道 lambda 演算是通用的，因此如果 SKI 能完全模拟它，就能得出SKI 演算也是通用的结论。</p><h2 id="约塔（Iota）"><a href="#约塔（Iota）" class="headerlink" title="约塔（Iota）"></a>约塔（Iota）</h2><p>希腊字母约塔（ɩ）是可以添加到 SKI 演算里的另一个组合子。下面是它的规约规则：ɩ[α] 可以规约成 α[S][K]。</p><p>Chris Barker 提交了一种叫作 Iota（<a href="http://semarch.linguistics.fas.nyu.edu/barker/Iota/）的语言，它的程序只使用" target="_blank" rel="noopener">http://semarch.linguistics.fas.nyu.edu/barker/Iota/）的语言，它的程序只使用</a> ɩ 组合子。尽管只有一个组合子，Iota 仍然是一种通用语言，因为任何 SKI 演算表达式都可以转成它，而我们已经看到 SKI 演算是通用的。</p><p>可以通过应用这些替换规则把 SKI 表达式转成 Iota：</p><ul><li>用 ɩ[ɩ[ɩ[ɩ[ɩ]]]] 替换 S</li><li>用 ɩ[ɩ[ɩ[ɩ]]] 替换 K</li><li>用 ɩ[ɩ] 替换 I</li></ul><h2 id="标签系统"><a href="#标签系统" class="headerlink" title="标签系统"></a>标签系统</h2><p>标签系统（tag system）是一个类似简化版图灵机的计算模型：标签系统不是在一条纸带上来回移动纸带头，而是反复在一个字符串的末尾增加新的字符并在开头处移除字符。在某方面，标签系统的字符串像是图灵机的纸带，但标签系统被限定在只能在字符串的两头操作，而且它只能朝着末尾“移动” 。</p><p>标签系统的描述包括两部分：首先，一个规则集合，其中每一条规则定义当特定的字符出现在字符串的开头时，要给这个字符串添加的一些字符（例如“字符串的开头是字符 a 时，添加字符 bcd” ） ；其次，一个叫作删除数的数字，它定义了按照一个规则执行之后有多少字符要从字符串的开头删除。</p><p>标签系统只能直接在字符串上操作，但我们也可以让它们对其他类型的值（例如数字）执行复杂的操作，只要用合适的方式把那些值编码成字符串就行。对数字编码的一种可能方式是：把数字 n 表示成字符串 aa 后跟重复 n 次的字符串 bb。例如，把数字 3 表示成字符串 aabbbbbb。</p><p>对于标签系统如何模拟图灵机工作的完整说明，请看 Matthew Cook 在 http:// <a href="http://www.complex-systems.com/pdf/15-1-1.pdf" target="_blank" rel="noopener">www.complex-systems.com/pdf/15-1-1.pdf</a> 中 2.1 节所做的简洁解释。</p><p>标签系统可以模拟任意图灵机的事实，意味着它也是通用的。</p><h2 id="循环标签系统"><a href="#循环标签系统" class="headerlink" title="循环标签系统"></a>循环标签系统</h2><p>循环标签系统（cyclic tag system）是施加了一些额外限制的更简单的标签系统。</p><ul><li>循环标签系统的字符串只能包含两个字符：0 和 1</li><li>循环标签系统的规则只会在当前字符串以 1 开始而不是 0 开始的时候才会应用</li><li>循环标签系统的删除数总 1</li></ul><p>这些约束本身对于支持任何有用的计算来说都过于苛刻了，因此作为补偿循环标签系统有一个额外的特性：循环标签系统的规则手册中的第一条规则是执行开始时的当前规则，并且在计算的每一步之后，规则手册中的下一个规则就成为了当前规则，在到达规则手册结尾的时候又会回到第一个规则。</p><p>这种系统被称为“循环的” ，是因为当前规则不断地在规则手册中循环。一个当前规则，再结合上每条规则都只会应用到 1 开头的字符串这一约束，避免了在每一步执行中不得不遍历规则手册查找可用规则的开销。如果首字符是 1，那么就应用当前规则，否则，就没有可用的规则。</p><p>循环标签系统极其受限（它们的规则不灵活，只有两个字符，删除数也是最低值） ，但令人吃惊的是，仍然可以使用它们模拟任何标签系统。</p><p>循环标签系统也是通用的。</p><h2 id="Conway-的生命游戏"><a href="#Conway-的生命游戏" class="headerlink" title="Conway 的生命游戏"></a>Conway 的生命游戏</h2><p>1970 年，John Conway 发明了一个叫作生命游戏（Game of Life）的通用系统。 “游戏”要在一个无限多的二维网格里进行，网格的每个小方格可以是生或是死。一个小方格有 8 个邻居：它上面的三个单元，紧挨着它的左右两个单元，以及它下面的三个单元。</p><p>生命游戏像有限状态机那样分一系列步骤进行。在每一步，根据由这个单元自身的当前状态和它邻居的状态所触发的规则，每个单元都可能从生转变为死，或者相反。规则很简单：如果一个活着的单元有少于两个（人口稀少）或者多于三个（人口过剩）活着的邻居，它就会死掉，如果一个死的单元恰好有三个活着的邻居它就能复活（繁殖） 。</p><p>1982 年，Conway 除了展示如何靠以创造性的方式碰撞“滑翔机”来设计逻辑上的与门（AND） 、或门（OR）和非门（NOT）以执行数字计算之外，还展示了如何使用一连串的“滑翔机”来表示二进制数据。这些结构说明理论上可以用生命游戏模拟一个数字计算机，但 Conway 没有设计出来一台可工作的机器。</p><p>2002 年，Paul Chapman 实现了一个特种通用计算机（<a href="http://www.igblan.free-online.co.uk/igblan/" target="_blank" rel="noopener">http://www.igblan.free-online.co.uk/igblan/</a> ca/） 。而 2010 年，Paul Rendell 构造出了一台通用图灵机（<a href="http://rendell-attic.org/gol/utm/）" target="_blank" rel="noopener">http://rendell-attic.org/gol/utm/）</a> 。</p><h2 id="rule-110"><a href="#rule-110" class="headerlink" title="rule 110"></a>rule 110</h2><p>rule 110 是另一个细胞自动机，由 Stephen Wolfram 在 1983 年提出。与 Conway 生命游戏里每个单元要么是生的要么是死的类似，rule 110 操作的单元按一维排列而不是二维网格形式。这意味着每个单元只有两个邻居而不是围绕着每个生命游戏单元的 8 个邻居。</p><p>2004 年，Matthew Cook 发表了一个对 rule 110 事实上通用的证明。这个证明包含大量的细节（参考 <a href="http://www" target="_blank" rel="noopener">http://www</a>.<br>complex-systems.com/pdf/15-1-1.pdf 的第 3 节和第 4 节） 。但粗略地讲，它引入了几个不同的 rule 110 模式扮演“滑翔机”的角色，然后通过用一种特定的方式排列那些“滑翔机”来展示如何模拟任意循环标签系统。</p><p>这意味着 rule 110 可以运行一个循环标签系统的模拟，而循环标签系统又可以运行一个普通标签系统的模拟，普通标签系统可以运行一个通用图灵机的模拟。这不是完成通用计算的高效方式，但对这样一台简单的细胞自动机来讲仍然是一项令人印象深刻的技术成果。</p><h2 id="Wolfram-的-2，3-图灵机"><a href="#Wolfram-的-2，3-图灵机" class="headerlink" title="Wolfram 的 2，3 图灵机"></a>Wolfram 的 2，3 图灵机</h2><p>我们要介绍的最后一个简单通用系统甚至比 rule 110 还简单：Wolfram 的 2,3 图灵机。它的名字源于其两个状态和三个字符（a、b 和空格） ，这意味着它只有 6 个规则：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2019-01-11-082957.png" alt=""></p><p>Wolfram 的 2,3 图灵机看起来没有强大到能支持通用计算。2007 年，Wolfram Research 宣布将给予能证明它是通用的人 25 000 美元的奖励。那年下半年，Alex Smith 通过成功的证明拿到了这个奖。就像对 rule 110 一样，这个证明靠的是展示出这种机器可以模拟任何循环标签系统。这个证明还是非常详细的，在 <a href="http://www.wolframscience.com/prizes/tm23/" target="_blank" rel="noopener">http://www.wolframscience.com/prizes/tm23/</a> 可以看到全文。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通用图灵机的存在是极其有意义的。尽管任何一台个体的图灵机都有一个硬编码的规则手册，但是通用图灵机证明了设计这样一个装置的可能性，这个装置可以通过从纸带读取指令来完成任何任务。这些指令实际上是控制机器硬件运行的软件，就像控制我们每天都在使用的通用可编程计算机的软件一样1。有限和下推自动机有点过于简单，不能支持这种全面的可编程性，但是图灵机具有解决这个问题的足够的复杂性。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
      <category term="通用计算" scheme="https://blog.0xff000000.com/tags/%E9%80%9A%E7%94%A8%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>随笔吧</title>
    <link href="https://blog.0xff000000.com/2019/01/10/essays-00/"/>
    <id>https://blog.0xff000000.com/2019/01/10/essays-00/</id>
    <published>2019-01-10T14:00:00.000Z</published>
    <updated>2019-01-10T15:27:55.593Z</updated>
    
    <content type="html"><![CDATA[<p>今天是平时混得比较好的同事小 A 离职的日子，突然想发点感想。<br>从大学毕业到现在，三年有余，时常反思，唯恐虚度光阴，但每每想对别人说起，却发现寂寞的很。但我相信，一定有很多人有类似的感悟。<br><a id="more"></a></p><p>以下几点，不存在必然联系，也不针对任何人。</p><h2 id="关于第一份工作"><a href="#关于第一份工作" class="headerlink" title="关于第一份工作"></a>关于第一份工作</h2><p>年轻人的第一份工作，特别重要！大多数应届生刚踏入职场时，仍是一张白纸。工作中，接触到的人，所做的事情，会慢慢深入到你的骨髓，不管是好的还是坏的。 工作久了就会发现，你的身上，或者你身边人身上总是能折射出当年第一个mentor 的影子。</p><p>职场中，一定会有两部分人，第一种是做事情的人，第二种是不做事情的人。孰好孰坏，并非总是非黑即白。萌新们一般会把事情分出个对错，因此，在遇到一些奇葩的人或者事情的时候不理解。</p><p>也许有些人会觉得自己的信念崩塌，不要急，也许换一个角度也许会豁然开朗：对错不重要，利益才是关键。古往今来，有钱道真语，无钱语不真。不信但看筵中酒，杯杯先劝有钱人；人为财死，鸟为食亡;如蚁附膻…这些词汇，道出了人的本性。但是，历史总是由那些掌握权势的人撰写。文明，社会的演进需要高瞻远瞩的人来推进，但历史却不总是。你不喜欢的，所不屑的，却主宰了历史的演进，而你只是参与。</p><p>对于做事情的人，得到权势，可以在权势的帮助下能做更多有意义的事情。不做事的人，得到权势，也不都是坏事，因为这样一般会激化矛盾，推进历史演进。</p><p>职场中，该如何选择？是站在利益这一边还是坚持自己的信念？这个选择或许每天都要遇到。争取利益这件事，无可厚非，但是一定不要丢掉自己的信念！不要太看重物质上的回报，既要坚持自己的信念，更要注意保护自己，不要陷入“党争”。</p><h2 id="视野"><a href="#视野" class="headerlink" title="视野"></a>视野</h2><p>刚踏入社会，总是会变得现实起来。工资，户口，房子，车子… 这没错，只不过，不应该整天把这些东西作为自己奋斗的原动力。</p><p>读小学的时候，国家教育我们，要为中华民族之崛起而读书。踏入社会，不能沦落成以房子车子妹子孩子而工作。虽然现实是如此，我们所处的大环境和社会给与我们的压力，让我们必须要现实起来。但是啊，把目光放长远一点吧。视野一定要足够开阔，不要仅仅局限于现实，也要活在梦里，哪里这个梦多么不切实际，哪怕每天也是努力活着，但不要浑浑噩噩啊。</p><p>视野这个东西多重要呢？很难量化，但是可以反推一下做大事的人，视野都不是仅仅局限在自己的身上。</p><p>因此，一定要有大视野。这不是说一定要去心系天下，那总归也要有点理想吧。</p><h2 id="如何定义好工作"><a href="#如何定义好工作" class="headerlink" title="如何定义好工作"></a>如何定义好工作</h2><p>说说如何定义一个好工作吧。</p><h3 id="跟对人"><a href="#跟对人" class="headerlink" title="跟对人"></a>跟对人</h3><p>比如，有一个好 leader，他能潜移默化的影响到你几乎方方面面。待人接物，如何高效处理任务，安排任务，沟通等等。</p><p>反例，想想整天务虚吹逼，没有视野，喜爱算计，搞小团伙的 leader 是什么样子吧，不会用人，不关心团队发展，用职级打压下级…</p><h3 id="做对事"><a href="#做对事" class="headerlink" title="做对事"></a>做对事</h3><p>一般情况下正确的事就是难的事情。因此，要学会离开自己的舒适区，敢想敢做，而不要划水，扯皮，搞 KPI 工程，吹嘘。</p><h3 id="一定要开心"><a href="#一定要开心" class="headerlink" title="一定要开心"></a>一定要开心</h3><p>要开心，遇到不顺心的事情，要么改变自己，要么把问题解决。</p><p>开开心心的工作才能保证工作时间能够得到高效利用，否则一旦负面情绪占据了你的大脑，就无法全身心的做事情，这可真是浪费时间呐。</p><h2 id="如何不断突破自己"><a href="#如何不断突破自己" class="headerlink" title="如何不断突破自己"></a>如何不断突破自己</h2><p>要不断提高自己，突破自己。下面主要针对技术实力。 还是那句话，基础和深度。可以通过阅读和配套实践来达到知行合一的效果，如果允许的话，那就要形成自己的观点，分享出去。</p><h3 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h3><p>一定要多读外文经典书籍。比如 CSAPP， SICP， HTDP 等，而不是什么 XXX 从入门到精通。不是说这些书不好，是说这些书就是垃圾，误人子弟，会让你浪费太多的时间吸收一些本身没有什么营养的内容。</p><p>经典的书之所以经典一定要有他的道理，先不要急于反驳，读完我说的那三本书再来反驳！</p><p>举个简单例子，经典的书就像压缩过的能量棒一样，咬一口，比较难啃，但是即便是一小口，就能让你迅速快速补充能量。 无良抄袭国外书籍或者文档的作者，或者是误人子弟的那些作者的 XXX，就像是吃完能量棒后自己拉的屎，大部分营养已不在或者变味，而偏偏有些读者觉得真香！不过，吃过了，除了自己的消化系统损坏以外，也没什么营养。</p><p>所以，一定要有品位。知道如何搜索，如何获取第一手资料，而不是吃着像巧克力一样的屎。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>还是关于布鲁姆认知领域六层次目标理论。阅读，理解后，实践完毕才能有信心说自己学会了。最好，还是分享出来。这个时候你就能带着自己的观点，有所评价，才意味着你对某个领域或者知识点是真正的有见地了。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>特别喜欢这句话：“The difference between ordinary and extraordinary is that little extra”。也许上面这些胡言乱语就是这个小小的 extra 吧。</p><p>最后，勉励一下自己，不要无所作为！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是平时混得比较好的同事小 A 离职的日子，突然想发点感想。&lt;br&gt;从大学毕业到现在，三年有余，时常反思，唯恐虚度光阴，但每每想对别人说起，却发现寂寞的很。但我相信，一定有很多人有类似的感悟。&lt;br&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://blog.0xff000000.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="品味" scheme="https://blog.0xff000000.com/tags/%E5%93%81%E5%91%B3/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - lambda 演算</title>
    <link href="https://blog.0xff000000.com/2019/01/05/reading-plan-01-07/"/>
    <id>https://blog.0xff000000.com/2019/01/05/reading-plan-01-07/</id>
    <published>2019-01-05T13:00:00.000Z</published>
    <updated>2019-01-05T13:54:28.637Z</updated>
    
    <content type="html"><![CDATA[<p>我们将研究一种叫作无类型 lambda 演算（untyped lambda calculus）的极小编程语言。首先，我们将用尽可能少的语言特性写（用 Ruby）一些接近 lambda 演算的程序。</p><p>这将仍然仅仅是在用 Ruby 编程，但施加虚构的约束之后，我们便能很轻松地探索一个受限的语义，而不需要学习一门新语言。然后，我们了解到这些非常有限的特性集合能做什么以后，就将利用这些特性把它们实现为一种语言（使用它自己的解析器、抽象语法和操作语义）—— 使用我们在之前章节中学到的技术。</p><a id="more"></a><h2 id="模拟lambda演算"><a href="#模拟lambda演算" class="headerlink" title="模拟lambda演算"></a>模拟lambda演算</h2><p>proc<br><code>-&gt; x { -&gt; y { x.call(y) } }</code></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>写一个程序输出数字 1 到 100。但如果数字是 3 的倍数，就不输出数字而是输出“Fizz” ， 如果是 5 的倍数就输出 “Buzz” 。 对于那些 3 和 5 的公倍数， 就输出 “FizzBuzz” 。</p><p>完整特性的 Ruby 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1..100).map do |n|</span><br><span class="line">  if (n % 15).zero?</span><br><span class="line">    &apos;FizzBuzz&apos; </span><br><span class="line">  elsif (n % 3).zero?     </span><br><span class="line">    &apos;Fizz&apos;   </span><br><span class="line">  elsif (n % 5).zero?     </span><br><span class="line">    &apos;Buzz&apos;   </span><br><span class="line">  else     </span><br><span class="line">    n.to_s   </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="实现数字"><a href="#实现数字" class="headerlink" title="实现数字"></a>实现数字</h3><p>描绘数字特征的一种方式是某个动作的重复（或者叫迭代）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def one(proc, x)</span><br><span class="line">    proc[x]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def two(proc, x)</span><br><span class="line">  proc[proc[x]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以此类推。<br>按照这种模式，可以很自然地把 #zero 定义为一个带有 proc 和另一个参数的方法，这个方法完全忽略 proc（换句话说，对其调用零次） ，并且会原封不动地返回第二个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def zero(proc, x)</span><br><span class="line">   x </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>把 数 据 表 示 为 纯 代 码 的 技 术 称 为 邱 奇 编 码（Church encoding） ， 它 是 以lambda 演算（<a href="http://dx.doi.org/10.2307/2371045）的发明者阿隆佐·邱奇的名字命名的。这些数字是邱奇数（Church" target="_blank" rel="noopener">http://dx.doi.org/10.2307/2371045）的发明者阿隆佐·邱奇的名字命名的。这些数字是邱奇数（Church</a> numeral） ，而且我们很快将会看到邱奇布尔值（Church Boolean）和邱奇有序对（Church pair）的例子。</p><h3 id="实现布尔值"><a href="#实现布尔值" class="headerlink" title="实现布尔值"></a>实现布尔值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def true(x, y)   </span><br><span class="line">    x </span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line">def false(x, y)</span><br><span class="line">   y </span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF =</span><br><span class="line">   -&gt; b &#123;     </span><br><span class="line">       -&gt; x &#123;       </span><br><span class="line">           -&gt; y &#123; </span><br><span class="line">                   b[x][y]       </span><br><span class="line">            &#125;     </span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="实现谓词"><a href="#实现谓词" class="headerlink" title="实现谓词"></a>实现谓词</h3><p><code>IS_ZERO = -&gt; n { n[-&gt; x { FALSE }][TRUE] }</code></p><h3 id="有序对"><a href="#有序对" class="headerlink" title="有序对"></a>有序对</h3><p>最简单的数据结构是有序对（pair） ，它跟二元数组类似。有序对实现起来非常容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PAIR  = -&gt; x &#123; -&gt; y &#123; -&gt; f &#123; f[x][y] &#125; &#125; &#125; </span><br><span class="line">LEFT  = -&gt; p &#123; p[-&gt; x &#123; -&gt; y &#123; x &#125; &#125; ] &#125; </span><br><span class="line">RIGHT = -&gt; p &#123; p[-&gt; x &#123; -&gt; y &#123; y &#125; &#125; ] &#125;</span><br></pre></td></tr></table></figure><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>现在有了数字，布尔值，条件，谓词以及有序对，下面实现数值运算。</p><p>递增:<br><code>INCREMENT = -&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }</code></p><p>我们调用这个新的 proc 的时候它会做什么呢？首先它会以 p 和 x 作为参数调用 n——因为n 是一个数字，所以这意味着就像原始的数字那样， “在 x 上对 p 进行 n 次调用”——然后对结果再调用一次 p。那么总体说来，这个 proc 的第一个参数会在它的第二个参数上调用n+1 次，这恰好是表示数字 n+1 的方法。</p><p>递减呢？这看起来是个更难的问题。</p><p>一个解决办法就是设计一个 proc，在对某个初始参数调用 n 次的时候返回数字 n-1。幸运的是，有序对正好可以帮助我们实现这种方法。思考一下这个 Ruby 方法所做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def slide(pair)   </span><br><span class="line">    [pair.last, pair.last + 1] </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在我们用数字组成的二元数组为参数调用 slide 时，它会返回一个新的二元数组，这个二元数组包含第二个数字还有比第二个数字大 1 的数字；如果输入的数组包含的是连续数字，那么效果就是向上“滑动”一个数字窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([3, 4]) </span><br><span class="line">=&gt; [4, 5] </span><br><span class="line">&gt;&gt; slide([8, 9]) </span><br><span class="line">=&gt; [9, 10]</span><br></pre></td></tr></table></figure></p><p>这很有用，因为通过在 -1 处开始一个窗口，我们可以安排一种情况，让数组里的第一个数字比我们调用 slide 的次数小 1，即使我们只是在递增数据 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([-1, 0])</span><br><span class="line">=&gt; [0, 1] </span><br><span class="line">&gt;&gt; slide(slide([-1, 0])) </span><br><span class="line">=&gt; [1, 2] </span><br><span class="line">&gt;&gt; slide(slide(slide([-1, 0]))) </span><br><span class="line">=&gt; [2, 3] </span><br><span class="line">&gt;&gt; slide(slide(slide(slide([-1, 0])))) </span><br><span class="line">=&gt; [3, 4]</span><br></pre></td></tr></table></figure></p><p>我们不能只用基于 proc 的数字完成，因为没法表示 -1，但 side 的有趣之处是不管怎样它只关注数组中的第二个数，因此我们可以放入任意的哑值（dummy value）——比如说0——替换掉 -1，这样仍然能得到同样的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([0, 0]) </span><br><span class="line">=&gt; [0, 1] </span><br><span class="line">&gt;&gt; slide(slide([0, 0])) </span><br><span class="line">=&gt; [1, 2] </span><br><span class="line">&gt;&gt; slide(slide(slide([0, 0]))) </span><br><span class="line">=&gt; [2, 3] </span><br><span class="line">&gt;&gt; slide(slide(slide(slide([0, 0])))) </span><br><span class="line">=&gt; [3, 4]</span><br></pre></td></tr></table></figure></p><p>这是让 DECREMENT 工作的关键：我们可以把 slide 转成一个 proc，使用数字 n 的 proc 表示对由 ZERO 组成的有序对调用 slide n 次，然后使用 LEFT 从结果的有序对中拉出左边的数来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SLIDE     = -&gt; p &#123; PAIR[RIGHT[p]][INCREMENT[RIGHT[p]]] &#125; </span><br><span class="line">DECREMENT = -&gt; n &#123; LEFT[n[SLIDE][PAIR[ZERO][ZERO]]] &#125;</span><br></pre></td></tr></table></figure><p><em>注：</em>DECREMENT[ZERO] 的结果实际上只是最初的 PAIR[ZERO][ZERO] 值的左边元素，在这种情况下根本就没有对其调用过 SLIDE。既然没有负值，0 就是我们能提供给 DECREMENT[ZERO] 的最合理的答案，因此使用 0 作为哑值是个好主意。</p><p>有了 INCREMENT 和 DECREMENT，就可能实现类似加法、减法、乘法和取幂这样的数字运算了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD      = -&gt; m &#123; -&gt; n &#123; n[INCREMENT][m] &#125; &#125; </span><br><span class="line">SUBTRACT = -&gt; m &#123; -&gt; n &#123; n[DECREMENT][m] &#125; &#125; </span><br><span class="line">MULTIPLY = -&gt; m &#123; -&gt; n &#123; n[ADD[m]][ZERO] &#125; &#125; </span><br><span class="line">POWER    = -&gt; m &#123; -&gt; n &#123; n[MULTIPLY[m]][ONE] &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><p>MOD，map, range, 字符串都可以利用以上实现来实现，此处略。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们将研究一种叫作无类型 lambda 演算（untyped lambda calculus）的极小编程语言。首先，我们将用尽可能少的语言特性写（用 Ruby）一些接近 lambda 演算的程序。&lt;/p&gt;
&lt;p&gt;这将仍然仅仅是在用 Ruby 编程，但施加虚构的约束之后，我们便能很轻松地探索一个受限的语义，而不需要学习一门新语言。然后，我们了解到这些非常有限的特性集合能做什么以后，就将利用这些特性把它们实现为一种语言（使用它自己的解析器、抽象语法和操作语义）—— 使用我们在之前章节中学到的技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
      <category term="lamda" scheme="https://blog.0xff000000.com/tags/lamda/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - 图灵机</title>
    <link href="https://blog.0xff000000.com/2019/01/02/reading-plan-01-06/"/>
    <id>https://blog.0xff000000.com/2019/01/02/reading-plan-01-06/</id>
    <published>2019-01-02T15:11:00.000Z</published>
    <updated>2019-01-02T15:30:24.453Z</updated>
    
    <content type="html"><![CDATA[<p>有限自动机和下推自动机——都有很严格的限制，这些限制影响了它们作为现实计算模型的使用。我们的小型系统还要多强大，才能摆脱这些限制并完成正常计算机的所有工作呢？它还要多复杂才能对 RAM 或硬盘的行为以及合适的输出机制建模呢？怎么才能设计一台能实际运行程序而不总是执行某个硬编码任务的机器呢？</p><a id="more"></a><p>20 世纪 30 年代，阿兰·图灵（Alan Turing）致力于从本质上解决这个问题。在那个年代，单词 computer 意味着一个人，通常是一个女人，她手工重复着一系列繁重的数学性操作以执行长长的计算。图灵当时正在寻找一种理解和描述“人肉计算机”操作特征的方法，这样同样的工作就可以完全由机器执行。本章，我们将看到图灵关于设计最简单的“自动化机器”的思想，这一机器具有手工计算的全部能力和复杂性。</p><h2 id="确定型图灵机"><a href="#确定型图灵机" class="headerlink" title="确定型图灵机"></a>确定型图灵机</h2><p>我们通过给一台有限自动机赋予一个作为外部存储的栈，增强了它的计算能力。与由机器状态提供的有限内部存储相比，栈的真正优点是能动态增长以适应任意数量的信息，从而使下推自动机能够处理那些需要存储任意数量数据的问题。</p><p>但是，外部存储这种特殊的形式给如何使用存储之后的数据带来了限制。通过把栈替换成更灵活的存储机制，我们可以消除这些限制并进一步提高能力。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><blockquote><p>计算通常可以通过在纸上写某些符号完成。我们可以把这张纸想象成小朋友的算术本，它被划分成了一个个方格。在初等算术里，我们有时也会使用纸的二维特性。但这种使用通常是可以避免的，并且我认为纸的二维性不是计算的本质，而且相信大家也赞同我这一观点。我假定计算是在一张一维的纸上完成的，比如在一条分成方格的纸带上完成。 ——阿兰•图灵， 《论可计算数及其在判定性问题上的应用》</p></blockquote><p>图灵的做法是给一台机器配上一条无限长的空纸带（实际上是一个两端都能随需增长的一维数组） ，并且允许在纸带上的任意位置读写字符。一条纸带既做存储又做输入：可以在纸带上预先填满字符串当作输入，然后机器在执行过程中可以读取这些字符并在必要的时候覆盖它们。</p><p>能访问一条无限长纸带的有限状态自动机叫作图灵机（Turing Machine，TM ） 。这个名字通常指一条拥有确定性规则的机器，但我们也可以毫无歧义地叫它确定型图灵机（Deterministic Turing Machine，DTM） 。</p><p>传统的图灵机使用简单的安排：用一个纸带头（tape head）指向纸带的一个特定位置，并且只能在那个位置读取或写入字符。每一步计算之后，纸带头都可以向左或者向右移动一个方格，这意味着一台图灵机为了到达远处的位置只能费力地在纸带上往复移动。使用移动缓慢的纸带头不会影响机器访问纸带上任何数据的能力，只会影响花费的时间，因此为了保持简单付出这个代价是值得的。</p><p>能访问纸带之后，除了能够接受或者拒绝字符串，我们又能解决新的问题了。例如，我们可以设计一台在纸带上就地递增一个二进制数的 DTM。为此，我们需要知道如何递增一个二进制数的一位数字。幸好这很简单：如果这位的数字是 0，就用 1 替换；如果这位数是 1，就用 0 替换，然后立即使用同样的方法增加它左边的数字（ “进 1 位” ） 。图灵机只需要使用这个过程递增二进制数的最右位，然后把纸带头移到起始位置。</p><ul><li>给机器赋予三个状态（状态 1、状态 2、状态 3） ，状态 3 作为接受状态</li><li>机器从状态 1 开始，纸带头指向一个二进制数的最右位</li><li>处于状态 1 并且读到一个 0（或者空白）时，就用 1 覆写，把纸带头向右移，然后回到 状态 2</li><li>处于状态 1 并且读到一个 1 时，就用 0 覆写，然后把纸带头向左移</li><li>处于状态 2 并且读到一个 0 或者 1 时，就把纸带头向右移</li><li>处于状态 2 并且读到空白时，就把纸带头向左移并转移到状态 3</li></ul><p>在机器试图递增一位数字的时候，它处于状态 1，在移回起始位置时处于状态 2，结束的时候处于状态 3。下面是初始纸带上字符串为 ‘1011’ 时对机器执行的跟踪。纸带头当前指向的字符会由括号包围，而下划线表示输入字符串某一端的空白方格。</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2019-01-02-151512.png" alt=""></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><p>让我们想象一下，由机器执行的操作被分解成“简单的操作” ，这些操作都非常基本，以至于无法想象它们能进一步分解。……操作实际上是由计算者的思维状态和被观察的符号决定的……具体来讲，操作执行之后，计算者的思维状态就确定了。<br>我们现在可以构造一台做这种计算者工作的机器了。  ——阿兰•图灵， 《论可计算数及其在判定性问题上的应用》</p></blockquote><p>在每一步计算中，可能都有几个“简单的操作”需要图灵机执行：在纸带头的当前位置读取字符，在那个位置写入一个新字符，把纸带头左移或者右移，或者改变状态。简单起见，我们没有为所有这些动作指定不同种类的规则，而只是像处理下推自动机时那样，只设计了一种能灵活适应各种条件的规则格式。</p><p>这个统一的规则格式有 5 部分：</p><ul><li>机器的当前状态</li><li>必须出现在纸带头当前位置的字符</li><li>机器的下一状态</li><li>要写入纸带头当前位置的字符</li><li>写入纸带之后纸带头的移动方向（向左还是向右）</li></ul><p>这里我们假设一台图灵机每次执行规则，都要改变状态并向纸带写一个字符。就像通常对状态机的处理那样，如果我们想要一个规则不实际改变状态，可以让“下一个状态”与当前状态相同；与之类似的是，如果想要一个规则不改变纸带内容，可以把与读到的字符一样的字符写入纸带。</p><h2 id="非确定性图灵机"><a href="#非确定性图灵机" class="headerlink" title="非确定性图灵机"></a>非确定性图灵机</h2><p>我们看到非确定性没有让有限自动机有什么不同。增加不确定性不会使一台图灵机更加强大。因为 DFA 和 DTM 都有足够的能力模拟其非确定性的对应机器。</p><h2 id="最大能力"><a href="#最大能力" class="headerlink" title="最大能力"></a>最大能力</h2><p>确定型图灵机代表了从有限计算机器到全能机器的临界点。实际上，通过升级图灵机规范以使其更强大的任何尝试都注定失败，因为它们本来就有能力模拟任何潜在的增强了。尽管增加某些特性会使图灵机更小巧或者更高效，但无法从根本上增强它们的能力。</p><p>例如对传统图灵机的 4 个其他扩展——内部存储、子例程、多纸带以及多维纸带，没有任何一个可以增加计算能力。</p><h2 id="通用机器"><a href="#通用机器" class="headerlink" title="通用机器"></a>通用机器</h2><p>尽管到目前为止我们看到的机器都有严重的缺陷：它们的规则都是硬编码的，这让它们无法适应不同的任务。一台能接受与一个特定正则表达式匹配的字符串的 DFA，不可能学会接受一个不同集合的字符串；一台能识别回文的 NPDA 将只能识别回文；一台递增二进制数的图灵机将永远不能做其他用途。</p><p>大多数现实中的计算机不是这么工作的。现代计算机不是专门做某一项特殊工作的，而是为了通用目的而设计的并且能通过编程执行不同的任务。尽管一台可编程计算机的指令集和 CPU 设计是固定的，但能通过软件控制它的硬件并根据用户需要改变它的行为。</p><p>我们的简单机器能做这样的事情吗？在做一件不同的工作时，不必每次去设计一台新的机器，而是设计一台简单机器，它会从输入读取一个程序，然后做这个程序定义的任何工作。这办得到吗？</p><p>或许不足为奇的是，一台图灵机足够强大，它能从纸带读取一台简单机器的描述——比如说，一台确定性有限自动机——然后运行这台机器的模拟以找出它的工作内容。</p><p>一台完整的图灵机以字符串的形式写在另一台图灵机的纸带上，准备通过模拟开始自己的生命周期。</p><p>它的规则手册、接受状态以及起始配置——都以编码的格式存在于UTM 的纸带上。为了执行模拟的一步，UTM 要在规则、当前状态和所模拟机器的纸带之间来回移动纸带头，以搜索出能应用到当前配置的一条规则。它找到一条规则的时候，就会根据规则里定义的字符和方向，更新所模拟的纸带，并把所模拟的机器放到新的状态上去。</p><p>这个过程会一直重复，直到所模拟的机器进入到一个接受状态，或者到达某个配置后因为没有规则应用处于卡死的状态。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有限自动机和下推自动机——都有很严格的限制，这些限制影响了它们作为现实计算模型的使用。我们的小型系统还要多强大，才能摆脱这些限制并完成正常计算机的所有工作呢？它还要多复杂才能对 RAM 或硬盘的行为以及合适的输出机制建模呢？怎么才能设计一台能实际运行程序而不总是执行某个硬编码任务的机器呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
      <category term="图灵机" scheme="https://blog.0xff000000.com/tags/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - 增加计算能力</title>
    <link href="https://blog.0xff000000.com/2018/12/30/reading-plan-01-05/"/>
    <id>https://blog.0xff000000.com/2018/12/30/reading-plan-01-05/</id>
    <published>2018-12-30T12:30:00.000Z</published>
    <updated>2018-12-30T12:35:10.513Z</updated>
    
    <content type="html"><![CDATA[<p>之前部分探讨了有限自动机，这是一种假想的机器，它去掉了真实计算机的复杂性并把其规约成了最简单的形式。我们详细考察了这些机器的行为并了解了它们的用处，而且还发现，非确定性有限自动机虽然有一些奇特的执行方法，但计算能力并不比确定性有限自动机强。那如何增加计算能力呢？</p><a id="more"></a><h2 id="计算能力"><a href="#计算能力" class="headerlink" title="计算能力"></a>计算能力</h2><p>我们没法通过为有限自动机增加非确定性和自由移动这种奇特的特性来提高它的计算能力。</p><p>这个事实表明，我们已经停留在这些简单机器的计算水平上无法前进了。而且如果不从根本上改变机器的工作方式，将无法脱离这种停滞不前的境地。那么，所有这些机器到底有多强的能力呢？好吧，没有多少能力。它们被限制在非常有限的应用上（只能接受或者拒绝字符序列） ，而且即使在这么小的范围内，仍然很容易碰到机器无法识别的语言。</p><h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><p>举个例子，假设要设计一台有限自动机，要求它能读取带有左右括号的字符串，并且只有字符串中的左右括号是平衡的（即每一个右括号都能在字符串中找到与其匹配的左括号） ，它才会接受。</p><p>可以设计如下 NFA 来实现：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-121522.jpg" alt=""></p><p>一次读取一个字符，同时跟踪一个表示当前嵌套级别的数字：读入一个左括号时增加嵌套级别，读入一个右括号时降低嵌套级别。只要嵌套级别到零了，就表示当前读到的这些括号已经都匹配上了（因为嵌套级别增加和减少的数量是一样的） ，并且如果我们试图把嵌套级别降低到小于零的值，那就表明当前的右括号多了（如 ‘())’） ，不管还有什么字符没有读取，字符串里的括号一定已经不平衡了。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>可是这种设计有一个严重的缺陷：如果括号的嵌套等级超过 3，它就会失败。它没有足够多的状态跟踪 ‘(((())))’ 这样的字符串的嵌套，因此即使括号明显是平衡的它也会拒绝。</p><p>我们可以通过临时增加更多的状态来修正此问题。一台拥有 5 个状态的 NFA 可以识别任意嵌套级别小于 5 的平衡字符串，而一台拥有 10 个、100 个或者 1000 个状态的 NFA，可以识别嵌套级别在机器硬限制以内的任意平衡字符串。但是，我们如何设计支持任意嵌套级别、能识别任意平衡字符串的 NFA 呢？结论是设计不出来：一台有限自动机的状态数总是有限的，因此任何机器能支持的嵌套级别也总是有限的，我们只要提供一个比它能处理的嵌套级别多一级的字符串，它就无法处理了。</p><p>根本问题是一台有限自动机只有固定的状态集合，因而其存储是有限的，因此没法跟踪任意数量的信息。在平衡字符串问题当中，一台 NFA 很容易递增到设计时限制的某个最大数目，但无法继续计数以适应任何可能大小的输入。</p><p>本质上大小固定的任务（比如对字符串 ‘abc’ 进行匹配） ，或者无需跟踪重复次数的任务（比如对正则表达式 ab*c 进行匹配） ，都不受这个问题的影响，但在信息数目不可预知，需要在计算过程中存储并在之后重用的场景下，这个问题会让有限自动机无能为力。</p><h2 id="增加计算能力"><a href="#增加计算能力" class="headerlink" title="增加计算能力"></a>增加计算能力</h2><p>为了解决存储问题，我们可以使用专门的原始空间扩展有限状态自动机，它负责在计算过程中存储数据。除状态提供的有限内部存储之外，这个空间给了机器一种外部存储（external memory） 。就像我们将会发现的那样，拥有外部存储对于一台机器的计算能力关系重大。</p><p>为有限自动机增加存储的简单方式就是让它可以访问栈，这是一个后进先出的数据结构，可以把字符推入和弹出。栈是简单而且有限制的数据结构——在任意时间都只有顶端的字符可以访问。为了查明栈下面位置的数据，我们只能丢弃顶层的字符，而一旦向栈内推入一串字符，我们就只能按相反的顺序把它们弹出——但它确实可以很好地解决有限存储的问题。对于栈的大小并没有内在的限制，因此原则上它可以根据需要存储数据。</p><p>自带栈的有限状态机叫作下推自动机（PushDown Automaton，PDA） ，如果这台机器的规则是确定性的，我们就叫它确定性下推自动机（Deterministic PushDown Automaton，DPDA）。</p><h2 id="问题解决方案-确定性下推自动机-PDA"><a href="#问题解决方案-确定性下推自动机-PDA" class="headerlink" title="问题解决方案 - 确定性下推自动机 PDA"></a>问题解决方案 - 确定性下推自动机 PDA</h2><p>能对栈进行访问带来了新的可能性，例如，很容易设计一台 DPDA 来识别括号组成的平衡字符串。</p><ul><li>给机器两个状态：1 和 2，状态 1 作为接受状态。</li><li>状态 1 作为机器的起始状态，此时栈为空。</li><li>如果处于状态 1 并且读入一个左括号，就把某个字符——我们使用 b 表示“括号”——入栈，并转移到状态 2。</li><li>如果处于状态 2 并且读入一个左括号，就把字符 b 入栈。</li><li>如果处于状态 2 并且读入一个右括号，就把字符 b 从栈中弹出。</li><li>如果处于状态 2 且栈为空，就转移回状态 1。</li></ul><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-121507.png" alt=""></p><h2 id="非确定性下推自动机-NPDA"><a href="#非确定性下推自动机-NPDA" class="headerlink" title="非确定性下推自动机 NPDA"></a>非确定性下推自动机 NPDA</h2><p>尽管处理平衡括号问题的机器确实需要栈来完成工作，但它其实只是将栈作为一个计数器，并且它的规则只区分“栈为空”和“栈不为空” 。更复杂的 DPDA 将会把一种以上的符号推入栈中，并在执行计算时使用这些信息。一个简单的例子是一台机器，它能识别包含相等数目的两种字符的字符串，比如 a 和 b。</p><p>DPDA 没有利用栈的全部优点。为了真正开发出栈的潜能，我们需要一个更难的问题强迫我们存储结构化信息。经典的例子是识别回文字符串：随着一个字符一个字符地读取输入字符串，我们需要记住所看到的数据；一旦字符串读取过了一半，就要检查内存以确定之前看到的字符是否为当前呈现字符的逆序。下面这个 DPDA 能够识别一个回文字符串，这个字符串由字符 a 和 b 组成，并且在中间的位置有一个字符 m（表示中间位置） ：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-122426.png" alt=""></p><p>这台机器从状态 1 开始，不断从输入读取 a 和 b，然后把它们推入栈中。它读到 m 的时候，会转移到状态 2，在那里一直读取输入字符同时尝试把每一个字符都弹出栈。如果字符串后半部分的每一个字符都与栈中弹出的内容匹配，机器就停留在状态 2 并最终碰到栈底的 $，此时转移到状态 3 并接受这个输入字符串。处于状态 2 的时候，如果读入的任何字符与栈顶的字符不匹配，那就没有规则可以遵守，因此它将进入阻塞状态并拒绝这个字符串。</p><p>没有确定性约束的下推自动机叫作非确定性下推自动机（nondeterministic pushdown automaton） 。下面是一台能识别由偶数个字母组成的回文字符串的非确定性下推自动机：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-122540.png" alt=""></p><h2 id="使用下推自动机进行分析"><a href="#使用下推自动机进行分析" class="headerlink" title="使用下推自动机进行分析"></a>使用下推自动机进行分析</h2><p>下推自动机有一个重要的实际应用：它们能用来解析编程语言。传统的方式是把解析过程分成两个独立的阶段:</p><ul><li><p>词法分析<br>读取一个原始字符串然后把它转换成一个单词 token 序列。每一个单词 token 代表程序语法的一个组成部分，例如“变量名” 、 “左括号”或者“while 关键字” 。词法分析器使用称为词法的规则集合来决定什么样的字符应该产生什么样的单词。这个阶段处理杂乱的字符级别的细节，比如变量命名规则、注释和空格，它为下一阶段的处理准备好清楚的单词序列。</p></li><li><p>语法分析<br>读入一个单词序列并根据正在分析的语言语法判断它们是否代表一个有效的程序。如果程序有效，那么语法解析器会生成一些关于程序结构的附加信息（如一个解析树）。</p></li></ul><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段通常相当直接。这可以通过正则表达式实现（因而也就是通过一台 NFA 实现） ，因为它把字符序列与一些规则简单匹配以判断那些字符是否为关键字、变量名、运算符或者其他什么符号。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>使用下推自动机是可以识别单词的有效序列。</p><p>分析的过程依赖于非确定性，但在实际程序中，最好能避免非确定性，因为一个确定性的 PDA 模拟起来要比非确定性的快得多而且容易得多。幸运的是，在每个阶段几乎都可以使用输入单词本身决定该应用哪个符号规则，这样就可能把非确定性去掉——这个技术叫作递推（lookahead）——但这让从 CFG 到 PDA 的转换更为复杂。</p><p>在实践中，我们可以让 PDA 模拟记录它到达接受状态过程中的规则序列，以此来创建结构化表示，这个规则序列提供了构建一个分析树所需的足够信息。</p><h2 id="计算能力-1"><a href="#计算能力-1" class="headerlink" title="计算能力"></a>计算能力</h2><p>我们见到了两个新的计算能力的级别：DPDA 比 DFA 和 NFA 更强大，而NPDA 要比 DPDA 更强大。能访问栈之后，看起来下推自动机比有限自动机要强大和复杂一些。</p><p>拥有栈的主要结果就是能识别某些有限自动机不能识别的语言了，如回文和平衡括号字符串。栈提供的无限存储使 PDA 能在计算中记住任意数量的信息并在随后再次使用它。</p><p>PDA 能识别回文，但它不能识别 ‘abab’ 和 ‘baaabaaa’ 这样“双倍”的字符串，因为一旦信息被推入到栈中，就只能以相反的顺序处理了。</p><p>如果我们抛开识别字符串的特定问题，而把这些机器看成通用目的的计算机，就可以看到DFA、NFA 和 PDA 还远远不够有用。首先，它们都没有像样的输出机制：它们通过进入接受状态表达成功，但不能输出哪怕一个字符（更不用说由字符组成的字符串了）来表示详细的结果。无法将信息发送回世界意味着它们连把两个数相加这样的简单算法都实现不了。而像有限自动机一样，PDA 有一个固定的程序；没有明显的方法构建出一台 PDA 能以某种方式从输入读取一个程序然后运行。</p><p>所有这些缺点意味着我们需要一个更好的计算模型，去真正地研究计算机能干什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前部分探讨了有限自动机，这是一种假想的机器，它去掉了真实计算机的复杂性并把其规约成了最简单的形式。我们详细考察了这些机器的行为并了解了它们的用处，而且还发现，非确定性有限自动机虽然有一些奇特的执行方法，但计算能力并不比确定性有限自动机强。那如何增加计算能力呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
      <category term="NFA" scheme="https://blog.0xff000000.com/tags/NFA/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - 非确定性有限自动机（NFA）</title>
    <link href="https://blog.0xff000000.com/2018/12/27/reading-plan-01-04/"/>
    <id>https://blog.0xff000000.com/2018/12/27/reading-plan-01-04/</id>
    <published>2018-12-27T14:37:00.000Z</published>
    <updated>2018-12-29T06:33:12.651Z</updated>
    
    <content type="html"><![CDATA[<p>NFA 以及正则表达式的原理。</p><a id="more"></a><h2 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h2><p>假设我们想要一台有限自动机，它能接受由 a 和 b 组成的第三个字符是 b 的任意字符串。此时很容易想出一个合适的 DFA 设计：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-152704.png" alt=""></p><p>如果想要一台机器能接受倒数第三个字符是 b 的字符串，怎么办呢？那将如何工作呢？似乎更加困难：上面的 DFA 能保证在读第三个字符的时候处于状态 3，但是一台机器无法预先知道什么时候能读到倒数第三个字符，因为在结束读取之前它不知道这个字符串有多长。甚至这样的一台 DFA 是否可能存在都不一定能立刻清楚。</p><p>但是，如果我们放松确定性的限制，并且允许规则手册对于一个状态和输入包含多条规则（或者根本没有规则） ，那么就可以设计一台能完成任务的机器：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-152925.png" alt=""></p><p>这是一台非确定性有限自动机（NFA） ，对每一个输入序列不再只有一条执行路径。处于状态 1 并且读入 b 的时候，它可能会按照一条规则仍保持在状态 1，但也可能会按照另一条规则进入状态 2。反过来，一旦进入状态 4，它找不到任何规则可以遵守，因此没法再继续读取输入。一台 DFA 的下一状态总是完全由它的当前状态和输入决定，但是一台NFA 在向下一个状态转移时会有多种可能性，而且有时候根本无法转移。</p><p>如果一台 DFA 读取一个字符串然后完全按照规则执行，并且最终终止于一个接受状态，那它就能接受这个字符串。那么对于一台 NFA 来说，什么才能表示一台 NFA 接受或者拒绝一个字符串呢？很自然的回答是，如果存在某条路径能让 NFA 按照它的某些规则执行并终止于一个接受状态，那它就能接受这个字符串 ; 这就是说，即使不是必然的，只要终止于一个接受状态是可能的就可以。</p><p>例如，这台 NFA 接受字符串 ‘baa’，因为从状态 1 开始，有一条路径可以让这台机器读取一个 b 转移到状态 2，再读取一个 a 转移到状态 3，最后读一个 a 终止于状态 4，这是一个接受态。它还接受字符串 ‘bbbbb’，因为 NFA 可以在读取前两个 b 的时候，按照另一条规则执行并停留在状态 1，然后在读第三个 b 的时候使用规则转移到状态 2，再读取字符串的其他部分，并向以前那样终止于状态 4。</p><p>另一方面，没有读取 ‘abb’ 并终止于状态 4 的方法（取决于遵照的不同规则，它最终只能终止于状态 1、2 或者 3） ，因此这台 NFA 不接受 ‘abb’。’bbabb’ 也不行，它最多只能到达状态 3：如果读入第一个 b 的时候直接转移到状态 2，它将很快终止于状态 4，这样留下两个字符没有处理但是已经没有规则可用了。</p><p>能被一台特定机器接受的字符串集合称为一种语言：我们说这台机器识别了这种语言。不是所有的语言都有一台 DFA 或者 NFA 能识别它们（详见第 4 章） ，但那些能被有限自动机识别的语言称为正则语言（regular language） 。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>在确定性计算机上模拟一台 NFA，关键是找到一种方法探索出这台机器所有可能的执行。<br>这种暴力方法把所有的可能全都摆出来，以此避免了只模拟一种可能执行时所需要的“幽灵般”的预见性。一台 NFA 读到一个字符的时候，它下一步转移到什么状态只会有有限数目的可能性，因此我们模拟非确定性时可以尝试遍历所有可能，然后看它们中哪个最终到达一个接受状态。</p><p>尝试遍历所有可能时可以采用递归的方式：每当所模拟的 NFA 读取一个字符并且有多个可用的规则时，遵照其中的一条规则，然后尝试读取输入的后续部分；如果这没有让机器到达一个可接受状态，就回退到早期状态，把输入也倒回早期的位置，然后按照另一个不同的规则再次尝试；如此重复，直到某次选择的规则让机器到达一个接受状态，或者所有可能的选择进行遍历的结果都不成功为止。</p><p>还有一个策略是采用并行的方式模拟所有可能：每当机器有超过一条规则可以遵守时就创建新线程，并把需要模拟的 NFA 复制过去以便复制的每一份都能尝试一条新规则，然后观察它的结果。所有这些线程都能同时执行，每个都从它自己的输入字符串副本中读取。<br>如果任何一个线程让机器读取了整个字符串，并且停止于一个接受状态，那么可以说这个字符串已经被接受了。</p><h2 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h2><p>很容易设计一台 DFA，能接受长度是 2 的倍数的、由字符 a 组成的字符串（’aa’、’aaaa’……） ：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153504.png" alt=""></p><p>但是如何设计一台机器，让它能接受长度是 2 或 3 的倍数的字符串呢？我们知道非确定性让一台机器可以走多于一条的执行路径，因此或许可以设计一台 NFA，它有一条“2 的倍数”的路径和一条“3 的倍数”的路径。一个初步的尝试可能看起来像这个样子：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153536.png" alt=""></p><p>这台 NFA 的思想是，在状态 1 和状态 2 之间移动以接受像 ‘aa’ 和 ‘aaaa’ 这样的字符串，在状态 1、状态 3 和状态 4 之间移动以接受像 ‘aaa’ 和 ‘aaaaaaaaa’ 这样的字符串。这工作得很好，但问题是这台机器还会接受字符串 ‘aaaaa’，因为它可以从状态 1 转移到状态 2 然后读完前两个字符的时候回到状态 1，再在状态 3 和状态 4 之间转移，之后在读完接下来的三个字符之后回到状态 1，终止于一个接受状态，即使这个字符串的长度不是 2 或者3 的倍数。</p><p>这次，一台 NFA 是否能完成这个工作还不是很明显，但是我们可以引入一个叫作自由移动的机器特性来解决此问题。这些规则让机器无需读取任何输入就能自发遵照执行，并且它们在这儿提供帮助是因为能让 NFA 在两组状态之间做一个初步选择：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153623.png" alt=""></p><p>自由移动表示成从状态 1 到状态 2 和状态 4 的无标记虚线箭头。机器仍然接受字符串’aaaa’，它会先自发地转移到状态 2，然后随着读取输入在状态 2 和状态 3 之间转移。类似地，如果它开始先自由移动到状态 4 也能接受 ‘aaaaaaaaa’。但是现在它没法接受字符串 ‘aaaaa’ 了：不管做任何可能的执行，它都一定要从到状态 2 或者状态 4 的转移开始，而且一旦选择了其中一条路径转移之后，就没法退回来了。一旦处于状态 2，就只能接受一个长度是 2 的倍数的字符串，同样一旦处于状态 4，就只能接受长度是 3 的倍数的字 符串。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>非确定性和自由移动增强了有限自动机的表达能力。</p><p>有限自动机完全适合这个工作。就像我们即将看到的，把任何正则表达式转成一个等价的 NFA 是可能的——每一个与正则表达式匹配的字符串都能被这台 NFA 接受，反过来也一样——把字符串输入给一台模拟的 NFA 看它是否能被接受，从而判断字符串是否与正则表达式匹配。用第 2 章的话说，我们可以把这个看成是为正则表达式提供了一种指称语义：我们不一定知道如何直接执行一个正则表达式，但是可以展示如何把它表示成一台NFA，并且因为有了 NFA 的操作语义（ “通过读取字符然后执行规则改变状态” ） ，所以可以执行这个指称（denotation）实现同样的结果。</p><h2 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h2><p>把任何非确定性有限自动机转成接受完全相同字符串的确定性自动机是可能的。</p><p>非确定性和自由移动只是一台 DFA 已经能做的工作的再包装，就像编程语言里中的语法糖一样，它们不是让我们超越确定性约束的新能力。</p><p>理论上说，为一台简单的机器增加更多的特性却没有为它根本上增加更多的能力非常有趣，但实际上这是很有用的，因为一台 DFA 比一台 NFA 更容易模拟：只有一个当前状态要跟踪，并且一台 DFA 用硬件或者机器代码实现起来足够简单，可以使用程序存储位置作为状态，用条件分支作为规则。这意味着一个正则表达式的实现可以把一个模式先转换成一台 NFA 然后再转换成一台 DFA，得到一台能被快速高效模拟的非常简单的机器。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;NFA 以及正则表达式的原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
      <category term="NFA" scheme="https://blog.0xff000000.com/tags/NFA/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，深入剖析程序和计算机 - 确定性有限自动机（Deterministic Finite Automaton，DFA）</title>
    <link href="https://blog.0xff000000.com/2018/12/24/reading-plan-01-03/"/>
    <id>https://blog.0xff000000.com/2018/12/24/reading-plan-01-03/</id>
    <published>2018-12-24T14:37:00.000Z</published>
    <updated>2018-12-24T14:38:26.604Z</updated>
    
    <content type="html"><![CDATA[<p>现实中，计算机通常都有大量的易失存储器（RAM）和非多核易失存储器（硬盘或者SSD） ，有许多输入输出设备，还有能同时执行多个指令的处理器。有限状态机（finite state machine） ，也叫有限自动机（finite automaton） ，是一台计算机的极简模型，为了容易理解、推导并且容易用硬件或软件实现，它放弃了上面所有的这些特性。<br><a id="more"></a></p><h2 id="状态、规则和输入"><a href="#状态、规则和输入" class="headerlink" title="状态、规则和输入"></a>状态、规则和输入</h2><p>下面是一台有限自动机的结构图：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-24-142901.png" alt=""></p><p>两个圆代表自动机的两个状态 1 和 2。凭空出现的箭头表明这台自动机从状态 1 开始，1 是它的起始状态。两个状态之间的箭头代表机器的规则：</p><ul><li>处于状态 1 并且读入字符 a 时，切换到状态 2；</li><li>处于状态 2 并且读入字符 a 时，切换到状态 1。</li></ul><p>这让我们有足够的信息研究机器如何处理一个输入流。</p><ul><li>这台机器从状态 1 开始。</li><li>这台机器只有从输入流读入字符a 的规则，因此这是唯一能发生的事情。读取到 a 的时候，它会从状态 1 切换到状态 2。</li><li>当这台机器又读取到了一个 a 时，它会切换回状态 1。</li></ul><p>一旦回到状态 1，它又将开始重复自身，这就是这台机器的行为范围。我们可以认为当前状态的信息存在于机器内部, 它像一个“黑盒”一样运转，并不会展现其内部工作状况——这台无聊的机器毫无用处，没有任何能观察到的输出。即使这台机器一直在状态 1 和状态 2 之间切换，机器之外也没有一个人能看出来有什么事情在发生。因此在这种情况下，我们可能还要增加一个状态，这样就不用再为任何内部结构操心了。</p><p><em>备注</em>：每台有限自动机没有通用的 CPU 执行任意程序，而是硬编码了一些规则集合，以决定在相应的输入下如何从一个状态切换到另一个状态。自动机先从一个特定的状态开始，然后从输入流中读入字符——按照规则它每次读取一个字符，有限自动机没有键盘、鼠标和接收输入的网络接口，只有一个外部的字符输入流可以一次读取一个字符。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>只是把一些状态标记成特别状态，并且认为机器的单比特输出提供了当前是否处于特别状态的信息。对于这台机器，我们将状态 2 作为特别状态，并在图中用双重的圆形表示它。</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-24-143328.png" alt=""></p><p>这些特定状态通常称为接受状态，表明这台机器对某个输入序列是接受还是拒绝。如果这台自动机从状态 1 开始并读入一个 a，它将会停留在状态 2，这是一个接受状态，因此我们可以说这台机器接受字符串 ‘a’。另外，如果它先读到一个 a，然后又读取了另一个 a，它将终止于状态 1，这不是一个接受状态，所以这台机器拒绝字符串 ‘aa’。事实上很容易看到，这台机器接受任何奇数个数的 a 组成的字符串：’a’、’aaa’、’aaaaa’ 都能被接受，但是 ‘aa’、’aaaa’ 和 ‘’（空字符串）会被拒绝。</p><h2 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h2><p>很明显，这种自动机具有确定性：不管它当前处于什么状态，并且不管读入什么字符，最终所处的状态总是完全确定的。只要满足下面两个约束，就能保证这种确定性。</p><ul><li><p>没有冲突<br>不存在这样的状态： 它的下一次转换状态因为有彼此冲突的规则而有二义性。<br>（这意味着一个状态对于同样的输入，不能有多个规则。 ）</p></li><li><p>没有遗漏　<br>不存在这样的状态：它的下一次转换状态因为缺失规则而未知。 （这意味着每个状态都必须针对每个可能的输入字符有至少一个规则。 ）</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，如果遵循上述约定，这就是一台确定性有限自动机（DFA）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现实中，计算机通常都有大量的易失存储器（RAM）和非多核易失存储器（硬盘或者SSD） ，有许多输入输出设备，还有能同时执行多个指令的处理器。有限状态机（finite state machine） ，也叫有限自动机（finite automaton） ，是一台计算机的极简模型，为了容易理解、推导并且容易用硬件或软件实现，它放弃了上面所有的这些特性。&lt;br&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，计算机的本质：深入剖析程序和计算机 - 程序的含义</title>
    <link href="https://blog.0xff000000.com/2018/12/20/reading-plan-01-02/"/>
    <id>https://blog.0xff000000.com/2018/12/20/reading-plan-01-02/</id>
    <published>2018-12-20T14:38:00.000Z</published>
    <updated>2018-12-20T14:59:09.858Z</updated>
    
    <content type="html"><![CDATA[<p>100 天计划第一期，决定读一些经典的技术类书籍。作为 IT 从业者，虽然是科班出身，但是基础知识结构仍然有很多需要夯实。</p><p>《计算机的本质：深入剖析程序和计算机》这本书涵盖了计算理论和编程语言设计，阐释了形式语义、自动机理论，以及通过 lambda 演算进行函数式编程等计算问题，可以帮助更好的理解计算机科学和计算原理。</p><a id="more"></a><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-19-132932.png" alt="drawing" width="250"></p><p>本文主要是阅读过程中的一些摘录和整理。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>传统的计算机程序是长长的字符串。每一种编程语言都有一系列规则，描述在那种语言中什么样的字符串被认为是有效程序。这些规则定义了这种语言的语法。</p><p>语法关心的只是程序的表面是什么样的，而不是它的含义。程序有可能语法正确但没有任何实际意义。例如，程序 y = x + 1 本身可能没有任何意义，因为并没有事先说明 x 是什么，而程序 z = true + 1 可能会在运行时候报错，因为它试图在一个布尔型值上加数字。<br>（当然，这依赖于具体编程语言的其他属性。 ）</p><h2 id="操作语义"><a href="#操作语义" class="headerlink" title="操作语义"></a>操作语义</h2><p>操作语义学（operational semantic）的基础，这种方法为程序在某种机器上的执行定义一些规则，以此来捕捉编程语言的含义。这个机器常常是一种抽象的机器：为了解释这种语言所写的程序如何执行而设计出来的一个想象的、理想化的计算机。为了更好地捕获编程语言的运行时行为，通常需要针对不同种类的编程语言设计不同的抽象机器。</p><h3 id="小步语义"><a href="#小步语义" class="headerlink" title="小步语义"></a>小步语义</h3><p>假想一台机器，用这台机器直接按照这种语言的语法进行操作一小步一小步地对其进行反复规约，从而对一个程序求值。不管最后得到的结果含义是什么，我们每一步都能让程序更接近最终结果。</p><p>这种小步规约类似于对代数式求值的方式。</p><p>例如，为了对 (1×2) + (3×4) 求值，我们知道应该：(1) 执行左侧的乘法（1×2 变成了 2） ，这样表达式就规约成了 2 + (3×4)；(2) 执行右侧的乘法（3×4 变成了 12） ，这样表达式规约成了 2 + 12；(3) 执行加法（2 + 12 变成了 14） ，最终得到 14。</p><h3 id="大步语义"><a href="#大步语义" class="headerlink" title="大步语义"></a>大步语义</h3><p>大步语义的思想是，定义如何从一个表达式或者语句直接得到它的结果。这必然需要把程序的执行当成一个递归的而不是迭代的过程：大步语义说的是，为了对一个更大的表达式求值，我们要对所有比它小的子表达式求值，然后把结果结合起来得到最终答案。</p><p>大步语义经常会写成更为松散的形式，只会说哪些子计算会执行，而不会指明它们按什么顺序执行。</p><h2 id="指称语义"><a href="#指称语义" class="headerlink" title="指称语义"></a>指称语义</h2><p>指称语义（denotational semantic）关心从程序本来的语言到其他表示的转换。</p><p>指称语义确实是一种比操作语义更抽象的方法，因为它只是用一种语言替换另一种语言，而不是把一种语言转换成真实的行为。</p><h2 id="形式化语义"><a href="#形式化语义" class="headerlink" title="形式化语义"></a>形式化语义</h2><p>形式化的语义通常都是由数学化的工具完成的。</p><p>形式化语义的一个重要应用是为一种编程语言的含义给出一个无歧义的定义，而不是让其依赖于像自然语言规范文档和“由实现规范”这样更加随意的方法。形式化的定义还有其他用途，例如证明某种语言通常情况下的特性，以及特定程序在特定情况下的特性，证明语言中程序之间的等价性，研究如何在不改变程序行为的情况下安全地变换程序而使其效率更高。</p><p>例如，既然操作语义与解释器的实现极为接近，那么计算机科学家就可以把一个适当的解释器看成一种语言的操作语义，然后证明它在那种语言的指称语义方面的正确性——这意味着证明了由解释器给出的含义和由指称语义给出的含义之间存在着明显的联系。</p><p>指称语义的一个优点是比操作语义抽象层次更高，它忽略了程序如何执行的细节，而只关心如何把它转换成一个不同的表示。例如，如果存在一种指称语义可以把两种语言翻译成某种共通的表示，就使对不同语言写成的两个程序进行比较成为可能。</p><p>抽象程度会使指称语义看起来有点兜圈子。如果问题是如何解释一种程序设计语言的含义，那么把一种语言翻译成另一种语言是如何让我们更接近问题答案的呢？一个指称只不过与它的含义一样好；尤其是，如果指称的语言有某种操作性的含义，那么一个指称语义只是让我们更接近于能实际执行一个程序，这个语言的语义本身展示了它是如何执行的，而不是如何翻译成另一种语言的。</p><p>形式化的指称语义使用抽象的数学对象（通常是函数）来表示表达式和语句这样的编程语言结构，并且因为数学上的约定会规定如何对函数求值这样的事情，这就有了一种直接在操作意义上思考指称的方式。我们已经使用了不太正式的方式，把指称语义看成是一种语言到另一种语言的编译器，而事实上这是多数编程语言最终得以执行的方式：一个 Java 程序将会由 javac 编译成字节码，字节码将会被 java 的虚拟机即时编译成 x86 的指令，然后一个 CPU 会把每一条 x86 指令解码成类 RISC（精简指令集）的微指令放到一个核上去执行</p><h2 id="treetop"><a href="#treetop" class="headerlink" title="treetop"></a>treetop</h2><p><a href="https://github.com/nathansobo/treetop" target="_blank" rel="noopener">treetop</a> 是本书中推荐的一个 ruby 的语法解释器。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>偷偷的放一下本书的资源吧，<a href="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/pdf/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA.pdf" target="_blank" rel="noopener">点我下载</a>, 侵权删。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;100 天计划第一期，决定读一些经典的技术类书籍。作为 IT 从业者，虽然是科班出身，但是基础知识结构仍然有很多需要夯实。&lt;/p&gt;
&lt;p&gt;《计算机的本质：深入剖析程序和计算机》这本书涵盖了计算理论和编程语言设计，阐释了形式语义、自动机理论，以及通过 lambda 演算进行函数式编程等计算问题，可以帮助更好的理解计算机科学和计算原理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>100 天阅读计划，第一期</title>
    <link href="https://blog.0xff000000.com/2018/12/19/reading-plan-01-01/"/>
    <id>https://blog.0xff000000.com/2018/12/19/reading-plan-01-01/</id>
    <published>2018-12-19T14:00:00.000Z</published>
    <updated>2018-12-19T14:23:36.052Z</updated>
    
    <content type="html"><![CDATA[<p>100 天阅读计划，第一期。</p><a id="more"></a><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>起止时间：2018.12.19 ~ 2019.3.29</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol start="0"><li>背景：独学而无友(你多久没阅读了?)。</li><li>目标：每天分享学到的一个知识点。</li><li>内容：不做限制，可以装逼，但要经得起灵魂拷问</li><li>依据：布鲁姆认知领域六层次目标理论。</li><li>实操：六层次目标理论实际操作可以简化为对知识的理解，应用和分享，而分享才代表你真正掌握。</li><li>规则：免押入群，不能超过连续三天不打卡的情况（特殊情况群里报备），违规收取 100 RMB 罚款。每次分享形式不做限定，推荐形式为博客，笔记截图，或者干脆来一次在线分享。</li><li>周期：100 天。期满，罚款汇总作为团建基金。到时候会有不限形式的总结，分享或者轰趴等活动。</li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="如何理解布鲁姆认知领域六层次目标理论？"><a href="#如何理解布鲁姆认知领域六层次目标理论？" class="headerlink" title="如何理解布鲁姆认知领域六层次目标理论？"></a>如何理解布鲁姆认知领域六层次目标理论？</h3><p>具体定义请看百科。这里给出自己的理解，该理论简化而言就是认知过程过程可分为三大层级，或者是三个步骤，逐级加深。</p><p>首先是通过阅读一手，或者 N 手材料，消化并且理解了某个知识点，举例而言，通过 Python 官方文档学会了基本语法，该阶段的特点是吸收的快，忘掉的也快，这个跟理解的深度有关系，对事物理解的越透彻，越是能看清本质，比较容易加深印象，不容易忘记。</p><p>第二阶段，能运用，关键是动手实践，所谓知行合一，比如学会了 Python 的语法，理解了该语言编程范式，可以用它来做一些项目，中间必然会遇到一些问题，可能会反复查阅文档，解决，如此往复可能需要一段时间才能熟练运用。</p><p>第三阶段，分享。经过动手实践，仅仅能代表自己掌握了该知识点并作为自己的一项技能来熟练运用，而大多数人往往止步于此。同时，分享是更高层级的认知活动。举例，有人邀请你做一场关于 Python 的分享活动，那么你自然会站在更高的层级来看待这个问题，比如你会有自己的评判（Python 是不是世界上最好的编程原因），一些奇淫技巧，或者是某些最佳实践，这些都可以认为是在实践过程中，对之前掌握的知识点的一个提炼。分享的同时也是在创造价值。</p><h3 id="为什么是-100-天？"><a href="#为什么是-100-天？" class="headerlink" title="为什么是 100 天？"></a>为什么是 100 天？</h3><p>一般而言，掌握一项技能，大概需要 3 个月。中间可能会有不可抗拒的外力，多出来的 10 天作为 Buffer。</p><h3 id="为什么要分享？"><a href="#为什么要分享？" class="headerlink" title="为什么要分享？"></a>为什么要分享？</h3><p>分享是更高层级的认知活动。如果一个毫无经验的人可以从你的分享中受益，首先你必须真正掌握了改知识点以及相关外围知识，其次你的表达能力也会得到锻炼。而表达，很重要！（有多少人，自认为自己很熟悉某个知识，但无法表达出来！！！）。</p><h3 id="分享的内容"><a href="#分享的内容" class="headerlink" title="分享的内容"></a>分享的内容</h3><p>每个人都不一样。阅读和分享的内容固然重要，但是学习知识的过程可能更重要。授人以鱼不如授人以渔。希望这 100 天不仅可以让自己真正学会某些东西，也能让自己的学习能力得到锻炼，争取成为一个高效的学习者。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>可能坚持 10 天，20 天，拍脑袋想，没那么难，但是 100 天绝对是一个巨大的挑战，不要盲目自信，拭目以待吧。</p><h2 id="想加入吗？"><a href="#想加入吗？" class="headerlink" title="想加入吗？"></a>想加入吗？</h2><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-19-141820.png" alt="drawing" width="250"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;100 天阅读计划，第一期。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计划" scheme="https://blog.0xff000000.com/tags/%E8%AE%A1%E5%88%92/"/>
    
      <category term="阅读" scheme="https://blog.0xff000000.com/tags/%E9%98%85%E8%AF%BB/"/>
    
      <category term="100 天" scheme="https://blog.0xff000000.com/tags/100-%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title>obfuscator (OLLVM）</title>
    <link href="https://blog.0xff000000.com/2018/11/12/ollvm/"/>
    <id>https://blog.0xff000000.com/2018/11/12/ollvm/</id>
    <published>2018-11-12T12:00:00.000Z</published>
    <updated>2018-11-12T13:05:27.207Z</updated>
    
    <content type="html"><![CDATA[<p>OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加对逆向工程的难度。后期转向商业项目strong.protect。目前，OLLVM已经支持LLVM-4.0版本。</p><p>本文主要记录了 OLLVM 的编译，使用流程。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank" rel="noopener">obfuscator</a> 在 2010年由 HEIG-VD 发起，为 LLVM 提供了代码混淆编译组件。Obfuscator 作用在 LLVM 的 IR 层，因此，它和其他所有可经由 LLVM 编译的语言都兼容，比如 C，C++, OC, Ada 等，并且也支持所有的平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, and XCore）。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank" rel="noopener">obfuscator</a> 有多个分支，我们选 llvm-4.0, 它基于 LLVM 官方版本 4.0.1。</p><p>编译 obfuscator 需要安装 CMake，克隆代码需要 git， 读者自行补齐。</p><p>只需要执行如下系列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git</span><br><span class="line">$ cd obfuscator</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">$ make -j7</span><br></pre></td></tr></table></figure></p><p>大概需要个个把小时，就会有结果。编译结果的二进制文件在 obfuscator/build/bin 目录下，比如 clang 命令。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>假设我们有源文件 cff.c, 路径位于相对于源码根目录 ./obfuscator 下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = 0;</span><br><span class="line">  if(a == 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return 10;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先用系统自带的 clang 编译，产生结果文件（在 cff.c 源码路径）:<br><code>$ clang cff.c -o original</code></p><p>然后我们使用自己编译的 clang +  ‘Control Flow Flattening’ 模式混淆。</p><p>在编译结果 bin 路径执行如下命令：<br><code>./clang-4.0 ../../obfuscator/cff.c -o ../../obfuscator/obs -mllvm -fla</code></p><p>然后我们用 Hopper 分别打开 original 和 obs 两个对象文件:</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-124222.jpg" alt=""></p><p>对比发现，经过 cfa 混淆后，原本程序的控制流被打破，增加了阅读门槛。</p><h2 id="几种混淆模式"><a href="#几种混淆模式" class="headerlink" title="几种混淆模式"></a>几种混淆模式</h2><h3 id="指令替换模式（Instructions-Substitution）"><a href="#指令替换模式（Instructions-Substitution）" class="headerlink" title="指令替换模式（Instructions Substitution）"></a>指令替换模式（Instructions Substitution）</h3><p>本质上指令替换就是用等价的更加复杂的指令替换原本可读性更好的指令。比如，加减以及布尔指令。</p><p>编译时，使用 -mllvm -sub 参数即可。</p><h3 id="控制流平展模式（Control-Flow-Flattening）"><a href="#控制流平展模式（Control-Flow-Flattening）" class="headerlink" title="控制流平展模式（Control Flow Flattening）"></a>控制流平展模式（Control Flow Flattening）</h3><p>该模式改变原本程序的控制流。<br>例如在 _使用_ 示例，原本程序的控制流如下：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-124942.jpg" alt=""></p><p>经过控制流平展后，控制流变成：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-125100.jpg" alt=""></p><p>编译时使用 -mllvm -fla 参数。</p><h3 id="控制流伪造模式-（Bogus-Control-Flow）"><a href="#控制流伪造模式-（Bogus-Control-Flow）" class="headerlink" title="控制流伪造模式 （Bogus Control Flow）"></a>控制流伪造模式 （Bogus Control Flow）</h3><p>也是对程序的控制流做操作，不同的是，BCF模式会在原代码块的前后随机插入新的代码块，新插入的代码块不是确定的，然后新代码块再通过条件判断跳转到原代码块中。更要命地是，原代码块可能会被克隆并插入随机的垃圾指令。</p><p>编译时加 -mllvm -bcf 参数即可。</p><h3 id="字符串混淆"><a href="#字符串混淆" class="headerlink" title="字符串混淆"></a>字符串混淆</h3><p>注意该模式 obfuscator 没有实现，这里只是提及一下，也是一种常见的混淆模式。混淆后的字符串没办法直接搜索到，变成一系列操作后的合成产物，提高了反编译成本。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>有的时候，由于效率或其他原因的考虑，我们只想给指定的函数混淆或不混淆该函数，OLLVM也提供了对这一特性的支持，你只需要给对应的函数添加attributes即可。比如，想对函数foo()使用fla混淆，只需要给函数foo()增加fla属性即可。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int foo() __attribute((__annotate__((&quot;fla&quot;))));</span><br><span class="line">int foo() &#123;</span><br><span class="line">   return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.jianshu.com/p/a631b5584de6" target="_blank" rel="noopener">https://www.jianshu.com/p/a631b5584de6</a></p></li><li><p><a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Functions-annotations" target="_blank" rel="noopener">https://github.com/obfuscator-llvm/obfuscator/wiki/Functions-annotations</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加对逆向工程的难度。后期转向商业项目strong.protect。目前，OLLVM已经支持LLVM-4.0版本。&lt;/p&gt;
&lt;p&gt;本文主要记录了 OLLVM 的编译，使用流程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="LLVM" scheme="https://blog.0xff000000.com/tags/LLVM/"/>
    
      <category term="obfuscator" scheme="https://blog.0xff000000.com/tags/obfuscator/"/>
    
      <category term="混淆" scheme="https://blog.0xff000000.com/tags/%E6%B7%B7%E6%B7%86/"/>
    
  </entry>
  
  <entry>
    <title>曲线救国之修复腾讯 X5 内核文件上传的兼容性问题</title>
    <link href="https://blog.0xff000000.com/2018/09/11/Fix-TBS-magic-bug/"/>
    <id>https://blog.0xff000000.com/2018/09/11/Fix-TBS-magic-bug/</id>
    <published>2018-09-11T14:00:00.000Z</published>
    <updated>2018-10-26T15:44:59.617Z</updated>
    
    <content type="html"><![CDATA[<p>来说说可恶的腾讯 X5 内核，记录下今天问题的排查，定位，和修复过程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Android 项目中的 WebView 集成了腾讯的 X5 内核，由于 X5 在展示方面的兼容性问题深受前端们的喜爱（我能说，他们的 H5 页面的样式兼容问题，全部推锅到移动开发吗, 除了最新版本的 Chrome 内核，是否可以考虑下别的浏览器…）。</p><p>然而，就在今天，一个不幸的上午，捕获到了如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">UncaughtException detected: android.os.FileUriExposedException: file:///storage/emulated/0/DCIM/Camera/1536649175379.jpg exposed beyond app through ClipData.Item.getUri()</span><br><span class="line">       at android.os.StrictMode.onFileUriExposed(StrictMode.java:1958)</span><br><span class="line">       at android.net.Uri.checkFileUriExposed(Uri.java:2356)</span><br><span class="line">       at android.content.ClipData.prepareToLeaveProcess(ClipData.java:941)</span><br><span class="line">       at android.content.Intent.prepareToLeaveProcess(Intent.java:9747)</span><br><span class="line">       at android.content.Intent.prepareToLeaveProcess(Intent.java:9732)</span><br><span class="line">       at android.app.Instrumentation.execStartActivity(Instrumentation.java:1611)</span><br><span class="line">       at android.app.Activity.startActivityForResult(Activity.java:4536)</span><br><span class="line">       at android.support.v4.app.BaseFragmentActivityApi16.startActivityForResult(BaseFragmentActivityApi16.java:54)</span><br><span class="line">       at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:65)</span><br><span class="line">       at android.app.Activity.startActivityForResult(Activity.java:4494)</span><br><span class="line">       at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:711)</span><br><span class="line">       at android.app.Activity.startActivity(Activity.java:4855)</span><br><span class="line">       at android.app.Activity.startActivity(Activity.java:4823)</span><br><span class="line">       at android.content.ContextWrapper.startActivity(ContextWrapper.java:376)</span><br><span class="line">       at org.chromium.android_webview.ResourcesContextWrapperFactory$WebViewContextWrapper.startActivity(Unknown Source:11)</span><br><span class="line">       at com.tencent.tbs.core.partner.b.a$2.onClick(Unknown Source:406)</span><br><span class="line">       at android.view.View.performClick(View.java:6266)</span><br><span class="line">       at android.view.View$PerformClick.run(View.java:24730)</span><br><span class="line">       at android.os.Handler.handleCallback(Handler.java:789)</span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:98)</span><br><span class="line">       at android.os.Looper.loop(Looper.java:171)</span><br><span class="line">       at android.app.ActivityThread.main(ActivityThread.java:6672)</span><br><span class="line">       at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">       at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:246)</span><br><span class="line">       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)</span><br></pre></td></tr></table></figure><h2 id="一回头"><a href="#一回头" class="headerlink" title="一回头"></a>一回头</h2><p>幸运的是找到了出现问题的调用： <code>&lt;input type=&quot;file&quot; acctType=&quot;image/*&quot;/&gt;</code>。</p><p>上述标签，最终会调用到 WebChromeClient 的 <code>onShowFileChooser</code> 方法（不同 Android 版本有所差异，&gt;= 5.0 是此方法），然而，经过测试，这次崩溃并没有调用到此处（一脸懵逼)。</p><p>乍一看是跨 APP 文件共享导致的问题，恰好最近项目刚把 <code>targetSdkVersion</code> 从 22 升级到 26，也就是必须要兼容 Android 6.0 的动态权限以及 7.0 的跨应用文件共享。</p><p>但是，仔细分析堆栈信息，没有发现项目主动调用的代码，可疑点锁定到这一行 <code>at com.tencent.tbs.core.partner.b.a$2.onClick(Unknown Source:406)</code>。但是下载下来的<br>腾讯内核 jar 文件中并没有包含 <code>com.tencent.tbs.core.partner.**</code>，由于 X5 内核只提供了轻量级的 jar 文件，实际内核的下载和更新是 APP 安装后动态进行的，于是乎去了<br> <code>/data/data/{packageUd}/app_tbs</code>, 并且把所有文件都导到电脑上，里面主要包含了包含资源文件的 apk, .so 文件以及一个 dex 文件，经过 dex2jar 这些操作后，仍然没有找到可疑的类文件。</p><h2 id="二回头"><a href="#二回头" class="headerlink" title="二回头"></a>二回头</h2><p>上一条路被堵死。<br>很幸运，恰好今天帮测试解决 <code>UI Automator</code> 的问题，顺道也用了一下, 获得如下布局：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/onm05.jpg" alt=""></p><p>emmm, 出问题的关键就是点击拍照，项目中没有主动显示这种样式的弹窗，因此可能是系统做了拦截处理，或者就是 X5。</p><p>换了几台不同厂商的测试机实验，样式都是一样，基本排除是系统拦截处理的锅。最可疑的就是 X5 了。</p><p><em>中午还去了浜烧市场吃了顿饭，心好大….</em></p><h2 id="三回头"><a href="#三回头" class="headerlink" title="三回头"></a>三回头</h2><p>基本锁定问题后，就开始各种预先申请权限，StrictMode 上折腾，试图解决权限问题，无果。</p><p>但每次 APP 崩溃几次后，再次调用，发现又会调用到 WebChromeClient 的 <code>onShowFileChooser</code> 方法，由于我们自己做过权限处理，一切又恢复正常。<br>(后来发现是 X5 发现崩溃后，降级逻辑)。</p><h2 id="四回头"><a href="#四回头" class="headerlink" title="四回头"></a>四回头</h2><p>测试发现，出问题的点只是拍照这一个地方，可恶的腾讯 X5 内核并没有做兼容 7.0 的逻辑处理，并且恶意拦截 input file 标签，美美的弹出自己的文件选择框。<br>兼容都没有做好，有碧莲弹窗。。。。佩服！！！</p><h2 id="五回头"><a href="#五回头" class="headerlink" title="五回头"></a>五回头</h2><p>不知怎么滴灵光一现，就想如果我们去掉拍照这个按钮，问题不就解决了吗？分析布局，目测是 X5 在 WebView 后面动态 add 了一个 <code>android.widget.LinearLayout</code>, 别问我怎么知道的…</p><p>于是乎诞生了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">项目中 WebView.java</span><br><span class="line"></span><br><span class="line">    LinearLayout fuckTbsLayout;</span><br><span class="line">    List&lt;TextView&gt; fuckTextViews;</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewAdded(View child) &#123;</span><br><span class="line">        if (child.getClass().getName().startsWith(&quot;com.tencent.tbs.&quot;)</span><br><span class="line">                &amp;&amp;</span><br><span class="line">                child instanceof LinearLayout</span><br><span class="line">                &amp;&amp;</span><br><span class="line">                ((LinearLayout) child).getChildCount() &gt; 0</span><br><span class="line">                ) &#123;</span><br><span class="line">            fuckTbsLayout = (LinearLayout) child;</span><br><span class="line">            TextView fuckItem;</span><br><span class="line">            if (fuckTbsLayout.getChildAt(0) instanceof TextView) &#123;</span><br><span class="line">                fuckItem = (TextView) fuckTbsLayout.getChildAt(0);</span><br><span class="line">                String fuckTitle = fuckItem.getText().toString();</span><br><span class="line">                if (fuckTitle.contains(&quot;请选择上传方式&quot;) || fuckTitle.contains(&quot;相册&quot;) || fuckTitle.contains(&quot;拍照&quot;) || fuckTitle.contains(&quot;其它方式&quot;)) &#123;</span><br><span class="line">                    fuckTextViews = new ArrayList&lt;&gt;();</span><br><span class="line">                    for (int i = 0; i &lt; fuckTbsLayout.getChildCount(); i++) &#123;</span><br><span class="line">                        TextView fuckTextView = null;</span><br><span class="line">                        if (fuckTbsLayout.getChildAt(i) instanceof TextView) &#123;</span><br><span class="line">                            fuckTextView = (TextView) fuckTbsLayout.getChildAt(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (fuckTextView != null &amp;&amp; fuckTextView.getText().toString().trim().contains(&quot;拍照&quot;)) &#123;</span><br><span class="line">                            fuckTextViews.add(fuckTextView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fuckTextViews != null &amp;&amp; fuckTextViews.size() &gt; 0) &#123;</span><br><span class="line">                        for (TextView todoRemoveFuckTextView : fuckTextViews) &#123;</span><br><span class="line">                            fuckTbsLayout.removeView(todoRemoveFuckTextView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fuckTextViews = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onViewAdded(child);</span><br><span class="line">    &#125;</span><br><span class="line">//sorry for the F words.</span><br></pre></td></tr></table></figure><p>主要思想就是在 WebView 的 onViewAdded 方法中做手脚，此方法是作甚的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called when a new child is added to this ViewGroup. Overrides should always</span><br><span class="line"> * call super.onViewAdded.</span><br><span class="line"> *</span><br><span class="line"> * @param child the added child view</span><br><span class="line"> */</span><br><span class="line">public void onViewAdded(View child) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常通俗易懂，当 X5 偷偷的去动态 addView 的时候，所在的父组件此方法必定会被调用，只要过滤一下，记录下来拍照的所属的 View，然后从父组件上调用  removeView 移除掉就好了。</p><h2 id="再回头脖子就要断了"><a href="#再回头脖子就要断了" class="headerlink" title="再回头脖子就要断了"></a>再回头脖子就要断了</h2><p>上述问题，曲线救国得以解决。</p><h2 id="方案的缺点"><a href="#方案的缺点" class="headerlink" title="方案的缺点"></a>方案的缺点</h2><ul><li>脏</li><li>脏</li><li>脏</li><li>TextView 变化，文案变化，会再次失效</li></ul><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><ul><li><p>在问题排查以及解决过程中，腾讯的 X5 文档，以及论坛，QQ 群形同虚设，几乎没有什么有价值的线索，狂吐槽。</p></li><li><p>X5 估计自己都没有做兼容测试，就动态下发错误的逻辑代码，属实是狂傲。</p></li><li><p>X5 检测应用崩溃后，降级逻辑总算是有点良心，降低对用户的影响，但是我们的 crash 率飙升了…唉</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;来说说可恶的腾讯 X5 内核，记录下今天问题的排查，定位，和修复过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="TBS" scheme="https://blog.0xff000000.com/tags/TBS/"/>
    
      <category term="X5" scheme="https://blog.0xff000000.com/tags/X5/"/>
    
      <category term="文件上传" scheme="https://blog.0xff000000.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="问题记录" scheme="https://blog.0xff000000.com/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 20</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-20/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-20/</id>
    <published>2018-09-04T14:20:00.000Z</published>
    <updated>2018-09-04T14:57:50.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 20 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-20" target="_blank" rel="noopener">Github</a></p><h2 id="扑克牌洗牌模拟器"><a href="#扑克牌洗牌模拟器" class="headerlink" title="扑克牌洗牌模拟器"></a>扑克牌洗牌模拟器</h2><p>在之前的 19 篇博客中，我把实现编程语言的每一步都详细的记录下来了。如果不拿这门语言，练练手，做个东西玩，那就没什么意思了，对不？</p><p>我准备实现一个扑克牌的洗牌模拟器。思路是提供一定数量的玩家，指定每个玩家的扑克牌的数量。作为输出，每个玩家都能获得一定数量的随机扑克牌。</p><h3 id="Card-类"><a href="#Card-类" class="headerlink" title="Card 类"></a>Card 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Card &#123;</span><br><span class="line"></span><br><span class="line">    string color</span><br><span class="line">    string pattern</span><br><span class="line"></span><br><span class="line">    Card(string cardColor,string cardPattern) &#123;</span><br><span class="line">        color = cardColor</span><br><span class="line">        pattern = cardPattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getColor() &#123;</span><br><span class="line">        color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getPattern() &#123;</span><br><span class="line">        pattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot; + color + &quot;,&quot; + pattern + &quot;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有黑科技，就是一个对象，并且是不可变的。</p><h3 id="CardDrawer-类"><a href="#CardDrawer-类" class="headerlink" title="CardDrawer 类"></a>CardDrawer 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CardDrawer &#123;</span><br><span class="line">    start &#123;</span><br><span class="line">        var cards = new List() //creates java.util.ArrayList </span><br><span class="line">        addNumberedCards(cards) //calling method with 3 arguments (last 2 are default)</span><br><span class="line">        addCardWithAllColors(&quot;Ace&quot;,cards) </span><br><span class="line">        addCardWithAllColors(&quot;Queen&quot;,cards)</span><br><span class="line">        addCardWithAllColors(&quot;King&quot;,cards)</span><br><span class="line">        addCardWithAllColors(&quot;Jack&quot;,cards)</span><br><span class="line">        //Calling with named arguments (and in differnet order)</span><br><span class="line">        //The last parameter (cardsPerPlayer) is ommited (it&apos;s default value is 5)</span><br><span class="line">        drawCardsForPlayers(playersAmount -&gt; 5,cardsList -&gt; cards) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addNumberedCards(List cardsList,int first=2, int last=10) &#123;</span><br><span class="line">        for i from first to last &#123;  //loop from first to last (inclusive)</span><br><span class="line">            var numberString = new java.lang.Integer(i).toString()</span><br><span class="line">            addCardWithAllColors(numberString,cardsList)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addCardWithAllColors(string pattern,List cardsList) &#123;</span><br><span class="line">        cardsList.add(new Card(&quot;Clubs&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Diamonds&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Hearts&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Spades&quot;,pattern))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    drawCardsForPlayers(List cardsList,int playersAmount = 3,int cardsPerPlayer = 5) &#123;</span><br><span class="line">        if(cardsList.size() &lt; (playersAmount * cardsPerPlayer)) &#123;</span><br><span class="line">            print &quot;ERROR - Not enough cards&quot; //No exceptions yet :)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var random = new java.util.Random()</span><br><span class="line">        for i from 1 to playersAmount &#123;</span><br><span class="line">            var playernumberString = new java.lang.Integer(i).toString()</span><br><span class="line">            print &quot;player &quot; + playernumberString  + &quot; is drawing:&quot;</span><br><span class="line">            for j from 1 to cardsPerPlayer &#123;</span><br><span class="line">                var dawnCardIndex = random.nextInt(cardsList.size() - 1)</span><br><span class="line">                var drawedCard = cardsList.remove(dawnCardIndex)</span><br><span class="line">                print &quot;    drawed:&quot; + drawedCard</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>首先我们需要编译 Card 类。然后编译 CardDrawer 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar: com.kubadziworski.compiler.Compiler EnkelExamples/RealApp/Card.enk</span><br><span class="line">java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/RealApp/CardDrawer.enk</span><br><span class="line"></span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java CardDrawer </span><br><span class="line">player 1 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,Queen&#125;</span><br><span class="line">    drawed:&#123;Spades,7&#125;</span><br><span class="line">    drawed:&#123;Hearts,Jack&#125;</span><br><span class="line">    drawed:&#123;Spades,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,2&#125;</span><br><span class="line">player 2 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,Ace&#125;</span><br><span class="line">    drawed:&#123;Diamonds,Jack&#125;</span><br><span class="line">    drawed:&#123;Spades,Queen&#125;</span><br><span class="line">    drawed:&#123;Spades,King&#125;</span><br><span class="line">player 3 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,Ace&#125;</span><br><span class="line">    drawed:&#123;Clubs,2&#125;</span><br><span class="line">    drawed:&#123;Clubs,3&#125;</span><br><span class="line">    drawed:&#123;Spades,8&#125;</span><br><span class="line">    drawed:&#123;Clubs,7&#125;</span><br><span class="line">player 4 is drawing:</span><br><span class="line">    drawed:&#123;Spades,Ace&#125;</span><br><span class="line">    drawed:&#123;Diamonds,3&#125;</span><br><span class="line">    drawed:&#123;Clubs,4&#125;</span><br><span class="line">    drawed:&#123;Clubs,6&#125;</span><br><span class="line">    drawed:&#123;Diamonds,2&#125;</span><br><span class="line">player 5 is drawing:</span><br><span class="line">    drawed:&#123;Hearts,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,Queen&#125;</span><br><span class="line">    drawed:&#123;Hearts,10&#125;</span><br><span class="line">    drawed:&#123;Clubs,Jack&#125;</span><br><span class="line">    drawed:&#123;Diamonds,8&#125;</span><br></pre></td></tr></table></figure><p>完美！</p><h2 id="再见，Enkel"><a href="#再见，Enkel" class="headerlink" title="再见，Enkel"></a>再见，Enkel</h2><p>为了实现 Enkel 和分享整个过程我花费了大量的精力。写代码是一回事，能够表达和分享是另一回事（能够让读者通俗易懂本身就是一个很大的挑战）。</p><p>在这个过程中我学习到了很多，也希望屏幕前面的你也能有所收获。</p><p>很不幸的是，这是系列中的最后一篇了，这个项目将继续下去，所以，保持关注吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 20 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 19</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-19/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-19/</id>
    <published>2018-09-04T14:19:00.000Z</published>
    <updated>2018-09-04T14:59:11.470Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 19 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-19" target="_blank" rel="noopener">Github</a></p><p><img src="http://jakubdziworski.github.io/assets/media/enkel_19/equals.gif" alt=""></p><h2 id="Java-中的对象比较"><a href="#Java-中的对象比较" class="headerlink" title="Java 中的对象比较"></a>Java 中的对象比较</h2><p>对于 Java 初学者来说，对象比较或许是最让人头疼的事情了。</p><p>我们来看如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 15;</span><br><span class="line">Integer b = 15;</span><br><span class="line">boolean areEqual = a == b;</span><br></pre></td></tr></table></figure><p>这里有个隐式的的类型装箱，Integer.valueOf(15) 会返回缓存的缓存的 Integer 对象，因为引用一样，所以 areEqual 是 true。</p><p>上面代码执行完后，Java 菜逼理所当然的想，我可以用 == 来比较对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nteger a = 155;</span><br><span class="line">Integer b = 155;</span><br><span class="line">boolean areEqual = a == b;</span><br></pre></td></tr></table></figure><p>areEqual 是 false, 这是因为 155 超过了缓存的阈值。</p><p>Strings 也有陷阱。比如通过 new 创建的对象获得一个新的引用，如果你通过双引号字符串给变量赋值，拿到的是一个缓存对象。</p><p>问题在于，在超过 99% 的情境下，我们比较的是对象是否相等，而不是引用是否相等。我希望 == 意味着相等，而 &lt;, &gt;, &lt;=, &gt;= 调用 compareTo。</p><p>我们一起来实现这个功能吧。</p><h2 id="条件表达式的字节码生成"><a href="#条件表达式的字节码生成" class="headerlink" title="条件表达式的字节码生成"></a>条件表达式的字节码生成</h2><p>在第十部分，条件表达式中，我们引入了比较原始类型的操作。这里我们引入 compareTo，只需要在生成字节码的部分修改就可以了。</p><p>基本思路是，判断值，如果是原始类型，调用 compareTo， 如果是引用，调用 equals。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionalExpressionGenerator &#123;</span><br><span class="line">     </span><br><span class="line">    //Constructor and fields</span><br><span class="line"></span><br><span class="line">    public void generate(ConditionalExpression conditionalExpression) &#123;</span><br><span class="line">        Expression leftExpression = conditionalExpression.getLeftExpression();</span><br><span class="line">        Expression rightExpression = conditionalExpression.getRightExpression();</span><br><span class="line">        CompareSign compareSign = conditionalExpression.getCompareSign();</span><br><span class="line">        if (conditionalExpression.isPrimitiveComparison()) &#123;</span><br><span class="line">            generatePrimitivesComparison(leftExpression, rightExpression, compareSign);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            generateObjectsComparison(leftExpression, rightExpression, compareSign);</span><br><span class="line">        &#125;</span><br><span class="line">        Label endLabel = new Label();</span><br><span class="line">        Label trueLabel = new Label();</span><br><span class="line">        methodVisitor.visitJumpInsn(compareSign.getOpcode(), trueLabel);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">        methodVisitor.visitJumpInsn(Opcodes.GOTO, endLabel);</span><br><span class="line">        methodVisitor.visitLabel(trueLabel);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ICONST_1);</span><br><span class="line">        methodVisitor.visitLabel(endLabel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateObjectsComparison(Expression leftExpression, Expression rightExpression, CompareSign compareSign) &#123;</span><br><span class="line">        Parameter parameter = new Parameter(&quot;o&quot;, new ClassType(&quot;java.lang.Object&quot;), Optional.empty()); // #1 </span><br><span class="line">        List&lt;Parameter&gt; parameters = Collections.singletonList(parameter);</span><br><span class="line">        Argument argument = new Argument(rightExpression, Optional.empty());</span><br><span class="line">        List&lt;Argument&gt; arguments = Collections.singletonList(argument);</span><br><span class="line">        switch (compareSign) &#123; // #2</span><br><span class="line">            case EQUAL:</span><br><span class="line">            case NOT_EQUAL:</span><br><span class="line">                FunctionSignature equalsSignature = new FunctionSignature(&quot;equals&quot;, parameters, BultInType.BOOLEAN); // #3</span><br><span class="line">                FunctionCall equalsCall = new FunctionCall(equalsSignature, arguments, leftExpression);</span><br><span class="line">                equalsCall.accept(expressionGenerator); // #4</span><br><span class="line">                methodVisitor.visitInsn(Opcodes.ICONST_1); </span><br><span class="line">                methodVisitor.visitInsn(Opcodes.IXOR); // #5</span><br><span class="line">                break;</span><br><span class="line">            case LESS:</span><br><span class="line">            case GREATER:</span><br><span class="line">            case LESS_OR_EQUAL:</span><br><span class="line">            case GRATER_OR_EQAL:</span><br><span class="line">                FunctionSignature compareToSignature = new FunctionSignature(&quot;compareTo&quot;, parameters, BultInType.INT); // #6</span><br><span class="line">                FunctionCall compareToCall = new FunctionCall(compareToSignature, arguments, leftExpression);</span><br><span class="line">                compareToCall.accept(expressionGenerator);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generatePrimitivesComparison(Expression leftExpression, Expression rightExpression, CompareSign compareSign) &#123;</span><br><span class="line">        leftExpression.accept(expressionGenerator);</span><br><span class="line">        rightExpression.accept(expressionGenerator);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ISUB); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是:</p><ul><li>1 Equals 方法在 Object 类中声明如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此参数需要是 java.lang.Object 类型，没有默认值（Optional.empty）</p><ul><li>2 需要强制区分是否相等（== 或者 !=）, 或者比较操作符（&gt; &lt; &gt;= &lt;=）。我们可以使用 compareTo 但是并不是所有的类都实现了 Comparable 接口。</li><li>3 如前面所述，equals 方法的入参是 java.lang.Object 并且返回值是布尔值。</li><li>4 为 equals 方法调用生成字节码。具体参考 CallExpressionGenerator 类。</li><li>5 如果对象相等，equals 返回 true ，否则返回 false, 原始类型的对比通过相减的方式，如果结果是 0 意味着相等。为了让对象可比较，我用了XOR（异或）逻辑指令，compareTo 方法和原始类型非常像。如果相同返回 0</li><li>6 创建 compareTo 的调用。他接受 java.lang.Object 类型参数，但是返回 int 类型的值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EqualitySyntax &#123;</span><br><span class="line"></span><br><span class="line"> start &#123;</span><br><span class="line">    var a = new java.lang.Integer(455)</span><br><span class="line">    var b = new java.lang.Integer(455)</span><br><span class="line">    print a == b</span><br><span class="line">    print a &gt; b</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成字节码反编译成 Java 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EqualitySyntax &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        Integer var1 = new Integer(455);</span><br><span class="line">        Integer var2 = new Integer(455);</span><br><span class="line">        System.out.println(var1.equals(var2));</span><br><span class="line">        System.out.println(var1.compareTo(var2) &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        (new EqualitySyntax()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，== 被映射成 equals， &gt; 被映射成 compareTo 操作。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 19 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 18</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-18/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-18/</id>
    <published>2018-09-04T14:18:00.000Z</published>
    <updated>2018-09-04T14:56:43.742Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 18 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-18" target="_blank" rel="noopener">Github</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>语法规则和 Java 非常类似，但是更加简单，没有复杂的修饰符（比如 static, volatile, transient）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fields &#123;</span><br><span class="line"></span><br><span class="line">    int field</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        field = 5</span><br><span class="line">        print field</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><p>在本篇之前我们只能在类中定义方法，现在我们开启定义字段的大门吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classBody :  field* function* ;</span><br><span class="line">field : type name;</span><br></pre></td></tr></table></figure><p>赋值语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assignment : name EQUALS expression;</span><br></pre></td></tr></table></figure><h3 id="为何这么久都没实现赋值语句"><a href="#为何这么久都没实现赋值语句" class="headerlink" title="为何这么久都没实现赋值语句"></a>为何这么久都没实现赋值语句</h3><p>字段用来赋值，但是这么久以来我们一直没有实现赋值语句来给声明的变量赋值，我这么做是因为有以下考量。</p><p>我希望变量是不可变的，赋值意味着改变状态，这会导致许多问题，比如同步，副作用，还有内存泄漏。</p><p>比如有如下的 Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stuff trustMeIWontModifyYourArg(SomeObject arg) &#123;</span><br><span class="line">    ... 999 lines of code </span><br><span class="line">    arg = null; //or some other nasty hidden stuff</span><br><span class="line">    ...another 999 lines of code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法签名，我们可能理所当然的想，方法会修改参数吗，他没有 final 修饰，但是大多数 Java 程序员会忽略。仅仅通过名字判断出来方法不会修改变量，那我们就用他吧。</p><p>过了两个小时后，出现了 NullPointerException，方法还是修改了参数。</p><p>如果方法没有副作用，那么可以很方便的实现并发而不用担心同步的问题，这种方法没有状态，也没有副作用，实现避免副作用方法最简单的办法就是尽可能的使用常量。</p><h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><h3 id="声明字段"><a href="#声明字段" class="headerlink" title="声明字段"></a>声明字段</h3><p>使用 ASM 的 visitField 来声明字段。它添加字段到 fields[]，fields_count 会自动增加计数器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FieldGenerator &#123;</span><br><span class="line"></span><br><span class="line">    private final ClassWriter classWriter;</span><br><span class="line"></span><br><span class="line">    public FieldGenerator(ClassWriter classWriter) &#123;</span><br><span class="line">        this.classWriter = classWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Field field) &#123;</span><br><span class="line">        String name = field.getName();</span><br><span class="line">        String descriptor = field.getType().getDescriptor();</span><br><span class="line">        FieldVisitor fieldVisitor = classWriter.visitField(Opcodes.ACC_PUBLIC, name,descriptor, null, null);</span><br><span class="line">        fieldVisitor.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取字段"><a href="#读取字段" class="headerlink" title="读取字段"></a>读取字段</h3><p>读取字段，你需要:</p><ul><li>字段名</li><li>字段类型修饰符</li><li>持有者的全限定名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceExpressionGenerator &#123;</span><br><span class="line"></span><br><span class="line">     //constructor and fields</span><br><span class="line"></span><br><span class="line">    public void generate(FieldReference fieldReference) &#123;</span><br><span class="line">        String varName = fieldReference.geName();</span><br><span class="line">        Type type = fieldReference.getType();</span><br><span class="line">        String ownerInternalName = fieldReference.getOwnerInternalName();</span><br><span class="line">        String descriptor = type.getDescriptor();</span><br><span class="line">        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, ownerInternalName,varName,descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ALOAD， 0  获得 this ，也就是局部变量索引值为 0 的值。在 非 static 语境中，this 默认都会在索引为 0 的位置。</li><li>GETFIELD 读取变量的指令</li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AssignmentStatementGenerator &#123;</span><br><span class="line"></span><br><span class="line">    //constructor and fields</span><br><span class="line">    </span><br><span class="line">    public void generate(Assignment assignment) &#123;</span><br><span class="line">        String varName = assignment.getVarName();</span><br><span class="line">        Expression expression = assignment.getExpression();</span><br><span class="line">        Type type = expression.getType();</span><br><span class="line">        if(scope.isLocalVariableExists(varName)) &#123;</span><br><span class="line">            int index = scope.getLocalVariableIndex(varName);</span><br><span class="line">            methodVisitor.visitVarInsn(type.getStoreVariableOpcode(), index);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Field field = scope.getField(varName);</span><br><span class="line">        String descriptor = field.getType().getDescriptor();</span><br><span class="line">        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);</span><br><span class="line">        expression.accept(expressionGenerator);</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD,field.getOwnerInternalName(),field.getName(),descriptor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和字段名字冲突了，那么局部变量有更高的优先级。</p><p>PUTFIELD 和 GETFIELD 相似，但是会出栈顶数据，表达式的值会被赋值到变量</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fields &#123;</span><br><span class="line"></span><br><span class="line">    int field</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        field = 5</span><br><span class="line">        print field</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成字节码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Fields &#123;</span><br><span class="line">  public int field;</span><br><span class="line"></span><br><span class="line">  public void start();</span><br><span class="line">    Code:           </span><br><span class="line">       0: aload_0               //get &quot;this&quot;</span><br><span class="line">       1: ldc           #9      // load constant &quot;5&quot; from constant pool </span><br><span class="line">       3: putfield      #11     // Field field:I - pop 5 off the stack and write to field</span><br><span class="line">       6: getstatic     #17     // Field java/lang/System.out:Ljava/io/PrintStream; </span><br><span class="line">       9: aload_0               //get &quot;this&quot; reference</span><br><span class="line">      10: getfield      #11     // Field field:I</span><br><span class="line">      13: invokevirtual #22     // Method &quot;Ljava/io/PrintStream;&quot;.println:(I)V</span><br><span class="line">      16: return</span><br><span class="line"></span><br><span class="line"> //autogenerated constructor and main method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 18 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 17</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-17/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-17/</id>
    <published>2018-09-04T14:17:00.000Z</published>
    <updated>2018-09-04T14:56:13.291Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 17 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-17" target="_blank" rel="noopener">Github</a></p><h2 id="字节码-JVM-语言的通用描述"><a href="#字节码-JVM-语言的通用描述" class="headerlink" title="字节码 - JVM 语言的通用描述"></a>字节码 - JVM 语言的通用描述</h2><p>所有基于 JVM 的编程语言最终被编译到字节码，然后被虚拟机加载解释执行，这意味着虚拟机并不知道是什么语言生成了字节码。只要类在 classpath 上。</p><p>这为 Enkel 调用 Java 库以及其他框架提供了具体可能性。</p><h2 id="查找类方法和构造器"><a href="#查找类方法和构造器" class="headerlink" title="查找类方法和构造器"></a>查找类方法和构造器</h2><p>为了能够引用到其他类，有如下两种选择：</p><ul><li>运行时  相信程序员并且不检验生成的字节码，这可能会导致如果 classpath 不存在，JVM 会抛出异常</li><li>编译时  在生成字节码之前验证。如果验证失败，会终止编译过程。</li></ul><p>在 Enkel 中，我决定使用第二种方式，主要是出于安全考量。我们可以使用反射 API 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathScope &#123;</span><br><span class="line"></span><br><span class="line"> public Optional&lt;FunctionSignature&gt; getMethodSignature(Type owner, String methodName, List&lt;Type&gt; arguments) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Class&lt;?&gt; methodOwnerClass = owner.getTypeClass();</span><br><span class="line">         Class&lt;?&gt;[] params = arguments.stream()</span><br><span class="line">                 .map(Type::getTypeClass).toArray(Class&lt;?&gt;[]::new);</span><br><span class="line">         Method method = methodOwnerClass.getMethod(methodName,params);</span><br><span class="line">         return Optional.of(ReflectionObjectToSignatureMapper.fromMethod(method));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         return Optional.empty();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public Optional&lt;FunctionSignature&gt; getConstructorSignature(String className, List&lt;Type&gt; arguments) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Class&lt;?&gt; methodOwnerClass = Class.forName(className);</span><br><span class="line">         Class&lt;?&gt;[] params = arguments.stream()</span><br><span class="line">                 .map(Type::getTypeClass).toArray(Class&lt;?&gt;[]::new);</span><br><span class="line">         Constructor&lt;?&gt; constructor = methodOwnerClass.getConstructor(params);</span><br><span class="line">         return Optional.of(ReflectionObjectToSignatureMapper.fromConstructor(constructor));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         return Optional.empty();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果方法或者构造器不存在，会抛异常并且终止编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Scope.java</span><br><span class="line">return new ClassPathScope().getMethodSignature(owner.get(), methodName, argumentsTypes)</span><br><span class="line">                .orElseThrow(() -&gt; new MethodSignatureNotFoundException(this,methodName,arguments));</span><br></pre></td></tr></table></figure><p>这种方式看起来更加安全，但是同时也会慢一点。所有的依赖需要在编译的时候通过反射的方式来解决依赖。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="调用其他-Enkel-类"><a href="#调用其他-Enkel-类" class="headerlink" title="调用其他 Enkel 类"></a>调用其他 Enkel 类</h3><p>下面我们从 Client 类中调用 Library 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client &#123;</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        print &quot;Client: Calling my own &apos;Library&apos; class:&quot;</span><br><span class="line">        var myLibrary = new Library()</span><br><span class="line">        var addition = myLibrary.add(5,2)</span><br><span class="line">        print &quot;Client: Result returned from &apos;Library.add&apos; = &quot; + addition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Library &#123;</span><br><span class="line"></span><br><span class="line">    int add(int x,int y) &#123;</span><br><span class="line">        print &quot;Library: add() method called&quot;</span><br><span class="line">        return x+y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要先编译 Library（我们目前不支持多文件同时编译），否则  Client 没办法编译通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/ClassPathCalls/Library.enk </span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/ClassPathCalls/Client.enk </span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java Client </span><br><span class="line">Client: Calling my own &apos;Library&apos; class:</span><br><span class="line">Library: add() method called</span><br><span class="line">Client: Result returned from &apos;Library.add&apos; = 7</span><br></pre></td></tr></table></figure><h3 id="调用-Java-的-API"><a href="#调用-Java-的-API" class="headerlink" title="调用 Java 的 API"></a>调用 Java 的 API</h3><figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        var someString = &quot;someString&quot;</span><br><span class="line">        print someString + &quot; to upper case : &quot; +  someString.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Client </span><br><span class="line">cos to upper case = COS</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 17 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 16</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-16/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-16/</id>
    <published>2018-09-04T14:16:00.000Z</published>
    <updated>2018-09-04T14:55:35.789Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 16 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-16" target="_blank" rel="noopener">Github</a></p><h2 id="OOP-和-statics"><a href="#OOP-和-statics" class="headerlink" title="OOP 和 statics"></a>OOP 和 statics</h2><p>面向对象语言中最大的优点是啥？我个人认为是多态， 如何实现多态，使用继承呗，可以在静态语义下使用继承么？肯定不行呀。</p><p>在我认为，静态语义违反了面向对象的思想，不应该出现在面向对象中，为了避免使用多态，你可以用单例呀。</p><p>因此，为何有 static 情况下，Java 还声称自己是面向对象的呢？我认为，Java 是为了迎合 C++ 更加方便的接纳 Java 才引入的历史因素。</p><h2 id="去掉-static"><a href="#去掉-static" class="headerlink" title="去掉 static"></a>去掉 static</h2><p>直到上一篇博客，Enkel 中一直存在 static。包括 main 方法和其他的静态方法，这么是为了方便实现语言的其他特性，比如变量，条件表达式，循环，方法调用，然后才转成 OO。</p><p>那么我们来实现没有静态的 OO 吧。</p><h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><p>static main 方法需要 Java 程序员手动编写。Enkel 是这样处理的：</p><ul><li>编译器自动生成</li><li>在 main 方法中，用默认的构造器创建一个对象</li><li>然后调用 start 方法</li><li>程序员需要提供 start 方法定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Function getGeneratedMainMethod() &#123;</span><br><span class="line">     FunctionParameter args = new FunctionParameter(&quot;args&quot;, BultInType.STRING_ARR, Optional.empty());</span><br><span class="line">     FunctionSignature functionSignature = new FunctionSignature(&quot;main&quot;, Collections.singletonList(args), BultInType.VOID);</span><br><span class="line">     ConstructorCall constructorCall = new ConstructorCall(scope.getClassName());</span><br><span class="line">     FunctionSignature startFunSignature = new FunctionSignature(&quot;start&quot;, Collections.emptyList(), BultInType.VOID);</span><br><span class="line">     FunctionCall startFunctionCall = new FunctionCall(startFunSignature, Collections.emptyList(), scope.getClassType());</span><br><span class="line">     Block block = new Block(new Scope(scope), Arrays.asList(constructorCall,startFunctionCall));</span><br><span class="line">     return new Function(functionSignature, block);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>start 方法是非静态的，但其实是 main 方法的一种变体。</p><h2 id="INVOSTATIC-vs-INVOKEVIRTUAL"><a href="#INVOSTATIC-vs-INVOKEVIRTUAL" class="headerlink" title="INVOSTATIC vs INVOKEVIRTUAL"></a>INVOSTATIC vs INVOKEVIRTUAL</h2><p>在第七部分，我用了 INVOKESTATIC 来做方法调用，是时候换成 INVOKEVIRTUAL 了。</p><p>INVOKEVIRTUAL 有一点和 INVOKESTATIC 有很大的差异，INVOKEVIRTUAL 需要一个所有者，INVOKESTATIC 从栈中出栈参数，INVOKEVIRTUAL 首先是把所有者出栈，然后才是出栈参数。</p><p>如果没有显示的提供所有者信息，默认用 this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Mapping antlr generated FunctionCallContext to FunctionCall </span><br><span class="line">@Override</span><br><span class="line">public Expression visitFunctionCall(@NotNull EnkelParser.FunctionCallContext ctx) &#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    boolean ownerIsExplicit = ctx.owner != null;</span><br><span class="line">    if(ownerIsExplicit) &#123;</span><br><span class="line">        Expression owner = ctx.owner.accept(this);</span><br><span class="line">        return new FunctionCall(signature, arguments, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassType thisType = new ClassType(scope.getClassName());</span><br><span class="line">    return new FunctionCall(signature, arguments, new VarReference(&quot;this&quot;,thisType)); //pass &quot;this&quot; as a owner </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Generating bytecode using mapped FunctionCall object</span><br><span class="line">public void generate(FunctionCall functionCall) &#123;</span><br><span class="line">    functionCall.getOwner().accept(this); //generate owner (pushses it onto stack)</span><br><span class="line">    generateArguments(functionCall);  //generate arguments</span><br><span class="line">    String functionName = functionCall.getIdentifier();</span><br><span class="line">    String methodDescriptor = DescriptorFactory.getMethodDescriptor(functionCall.getSignature());</span><br><span class="line">    String ownerDescriptor = functionCall.getOwnerType().getInternalName();</span><br><span class="line">    //Consumes owner and arguments off the stack</span><br><span class="line">    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ownerDescriptor, functionName, methodDescriptor, false); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HelloStart &#123;</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        print &quot;Hey I am non-static &apos;start&apos; method&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class HelloStart &#123;</span><br><span class="line">  public void start();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #14                 // String Hey I am non-static  &apos;start&apos; method</span><br><span class="line">       5: invokevirtual #19                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line"></span><br><span class="line">  //Constructor</span><br><span class="line">  public HelloStart();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0   //get &quot;this&quot;</span><br><span class="line">       1: invokespecial #22                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V - call super</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class HelloStart - create new object</span><br><span class="line">       3: dup       //duplicate new object so that invokespecial does not consumes it</span><br><span class="line">       4: invokespecial #25                 // Method &quot;&lt;init&gt;&quot;:()V - call constructor</span><br><span class="line">       7: invokevirtual #27                 // Method start:()V</span><br><span class="line">      10: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之对应 Java 类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HelloStart &#123;</span><br><span class="line">    public HelloStart() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        (new HelloStart()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Hey I am non-static \&apos;start\&apos; method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 16 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 15</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-15/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-15/</id>
    <published>2018-09-04T14:15:00.000Z</published>
    <updated>2018-09-04T14:54:54.478Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 15 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-15" target="_blank" rel="noopener">Github</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Enkel 的构造器声明和调用的语法和 Java 保持一致。<br>声明实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat ( String name ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Cat ( &quot;Molly&quot; )</span><br></pre></td></tr></table></figure><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><p>Java 中构造器的声明是一个没有返回值的函数。Enkel 中也是一样。</p><p>对于构造器的调用呢？解析器如何区别方法调用和构造器调用呢？因此，Enkel 引入了关键字 <code>new</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//other rules</span><br><span class="line">expression : //other rules alternatives</span><br><span class="line">           | &apos;new&apos; className &apos;(&apos;argument? (&apos;,&apos; argument)* &apos;)&apos; #constructorCall</span><br></pre></td></tr></table></figure><h2 id="匹配-Antlr-上下文对象"><a href="#匹配-Antlr-上下文对象" class="headerlink" title="匹配 Antlr 上下文对象"></a>匹配 Antlr 上下文对象</h2><p>新的语法规则 constructCall 带来一个新的解析回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Expression visitConstructorCall(@NotNull EnkelParser.ConstructorCallContext ctx) &#123;</span><br><span class="line">    String className = ctx.className().getText();</span><br><span class="line">    List&lt;EnkelParser.ArgumentContext&gt; argumentsCtx = ctx.argument();</span><br><span class="line">    List&lt;Expression&gt; arguments = getArgumentsForCall(argumentsCtx, className);</span><br><span class="line">    return new ConstructorCall(className, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法调用要求名字，返回值，以及参数和持有者的信息。构造器的调用仅仅需要类名和参数。</p><ul><li>构造器需要类型吗？ 不需要。因为返回值类型都是固定的，就是类本身</li><li>构造器需要持有者信息吗？不需要。因为构造器的调用都是通过 new 关键字，<code>someObject.new SomeObject()</code> 这种调用时没有任何意义的</li></ul><p>对于方法声明，我们又该如何区分呢? 有一种简单的办法就是对比方法的名字和类型是否一致。这也就是意味着普通方法的命名不能跟类名重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Function visitFunction(@NotNull EnkelParser.FunctionContext ctx) &#123;</span><br><span class="line">        List&lt;Type&gt; parameterTypes = ctx.functionDeclaration().functionParameter().stream()</span><br><span class="line">                .map(p -&gt; TypeResolver.getFromTypeName(p.type())).collect(toList());</span><br><span class="line">        FunctionSignature signature = scope.getMethodCallSignature(ctx.functionDeclaration().functionName().getText(),parameterTypes);</span><br><span class="line">        scope.addLocalVariable(new LocalVariable(&quot;this&quot;,scope.getClassType()));</span><br><span class="line">        addParametersAsLocalVariables(signature);</span><br><span class="line">        Statement block = getBlock(ctx);</span><br><span class="line">        //Check if method is not actually a constructor</span><br><span class="line">        if(signature.getName().equals(scope.getClassName())) &#123;</span><br><span class="line">            return new Constructor(signature,block);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Function(signature, block);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="默认的构造器"><a href="#默认的构造器" class="headerlink" title="默认的构造器"></a>默认的构造器</h2><p>如果你没有手动创建构造器，Enkel 会创建默认的构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ClassDeclaration visitClassDeclaration(@NotNull EnkelParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">    //some other stuff</span><br><span class="line">    boolean defaultConstructorExists = scope.parameterLessSignatureExists(className);</span><br><span class="line">    addDefaultConstructorSignatureToScope(name, defaultConstructorExists);</span><br><span class="line">    //other stuff</span><br><span class="line">    if(!defaultConstructorExists) &#123;</span><br><span class="line">        methods.add(getDefaultConstructor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">private void addDefaultConstructorSignatureToScope(String name, boolean defaultConstructorExists) &#123;</span><br><span class="line">    if(!defaultConstructorExists) &#123;</span><br><span class="line">        FunctionSignature constructorSignature = new FunctionSignature(name, Collections.emptyList(), BultInType.VOID);</span><br><span class="line">        scope.addSignature(constructorSignature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Constructor getDefaultConstructor() &#123;</span><br><span class="line">    FunctionSignature signature = scope.getMethodCallSignatureWithoutParameters(scope.getClassName());</span><br><span class="line">    Constructor constructor = new Constructor(signature, Block.empty(scope));</span><br><span class="line">    return constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你或许好奇为何构造器返回 void。简单来说就是 JVM 把对象的创建分为两个步骤：首先分配内存空间，然后才是调用构造器（构造器主要职责是做初始化，因此我们可以在构造函数内调用 this 变量）。</p><h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><p>到目前为止，我们已经可以解析构造函数的声明以及调用了。接下来就是如何生成字节码了。</p><p>对象的创建的字节码有两个指令：</p><ul><li>NEW 在堆中分类内存，初始化成员变量为默认值</li><li>INVOKESPECIAL 调用构造器</li></ul><p>Java 中你无需在构造器中手动调用 super() 。实际上这是必须的，否则无法创建对象，但是 Java 编译器帮我们做了这一步。</p><p>调用 super 会用到 INVOKESPECIAL 指令，Enkel 编译器跟 Java 编译器保持一致，也会自动处理调用。</p><h3 id="构造器调用的字节码生成"><a href="#构造器调用的字节码生成" class="headerlink" title="构造器调用的字节码生成"></a>构造器调用的字节码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void generate(ConstructorCall constructorCall) &#123;</span><br><span class="line">        String ownerDescriptor = scope.getClassInternalName(); //example : java/lang/String</span><br><span class="line">        methodVisitor.visitTypeInsn(Opcodes.NEW, ownerDescriptor); //NEW instruction takes object decriptor as an input</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.DUP); //Duplicate (we do not want invokespecial to &quot;eat&quot; our brand new object</span><br><span class="line">        FunctionSignature methodCallSignature = scope.getMethodCallSignature(constructorCall.getIdentifier(),constructorCall.getArguments());</span><br><span class="line">        String methodDescriptor = DescriptorFactory.getMethodDescriptor(methodCallSignature);</span><br><span class="line">        generateArguments(constructorCall);</span><br><span class="line">        methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, ownerDescriptor, &quot;&lt;init&gt;&quot;, methodDescriptor, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么用到了 DUP 指令。在 NEW 指令执行后，栈中保存了新建创的对象。INVOKESPECIAL 指令会从栈顶取数据，然后初始化。如果我们不赋值对象，这样会导致新创建的对象被构造器指令出栈，然后对象会丢失在堆中等待 GC 去做垃圾回收。</p><p>如下的语句：<br><code>new Cat().meow()</code></p><p>会生成如下的字节码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class Cat</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #23                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: invokevirtual #26                 // Method meow:()V</span><br></pre></td></tr></table></figure><h3 id="构造器声明的字节码生成"><a href="#构造器声明的字节码生成" class="headerlink" title="构造器声明的字节码生成"></a>构造器声明的字节码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void generate(Constructor constructor) &#123;</span><br><span class="line">    Block block = (Block) constructor.getRootStatement();</span><br><span class="line">    Scope scope = block.getScope();</span><br><span class="line">    int access = Opcodes.ACC_PUBLIC;</span><br><span class="line">    String description = DescriptorFactory.getMethodDescriptor(constructor);</span><br><span class="line">    MethodVisitor mv = classWriter.visitMethod(access, &quot;&lt;init&gt;&quot;, description, null, null);</span><br><span class="line">    mv.visitCode();</span><br><span class="line">    StatementGenerator statementScopeGenrator = new StatementGenerator(mv,scope);</span><br><span class="line">    new SuperCall().accept(statementScopeGenrator); //CALL SUPER IMPLICITILY BEFORE BODY ITSELF</span><br><span class="line">    block.accept(statementScopeGenrator); //CALL THE BODY DEFINED BY PROGRAMMER</span><br><span class="line">    appendReturnIfNotExists(constructor, block,statementScopeGenrator);</span><br><span class="line">    mv.visitMaxs(-1,-1);</span><br><span class="line">    mv.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到，构造器中的 super 调用时必须的，Java 中我们没有手动调用（除非父类没有无参构造器）。这样做不是非必须的而是 Java 编译器帮我们做了自动生成。Enkel 也要有这么炫酷的功能。</p><p><code>new SuperCall().accept(statementScopeGenrator);</code></p><p>触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void generate(SuperCall superCall) &#123;</span><br><span class="line">    methodVisitor.visitVarInsn(Opcodes.ALOAD,0); //LOAD &quot;this&quot; object</span><br><span class="line">    generateArguments(superCall);</span><br><span class="line">    String ownerDescriptor = scope.getSuperClassInternalName();</span><br><span class="line">    methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, ownerDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot; , false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法（甚至是构造器）把参数当做帧中的局部变量来对待。如果方法 <code>int add(int x,int y)</code> 在静态上下文中被调用，他的初始 frame 中存在两个变量（x, y）。如果在非静态上下文中，this(被调用者）也存在局部变量中。因此，如果 add 方法是在非静态上下文中被调用，那么有三个局部变量(this, x, y)。</p><p>Cat 类的构造器（构造器内没有内容）生成的字节码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0      //load &quot;this&quot;</span><br><span class="line">1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V - call super on &quot;this&quot; (the Cat dervies from Object)</span><br><span class="line">12: return</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 15 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 14</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-14/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-14/</id>
    <published>2018-09-04T14:14:00.000Z</published>
    <updated>2018-09-04T14:54:14.803Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 14 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-14" target="_blank" rel="noopener">Github</a></p><h2 id="支持新的类型"><a href="#支持新的类型" class="headerlink" title="支持新的类型"></a>支持新的类型</h2><p>目前为止 Enkel 仅支持了整数类型和字符串类型。是时候支持其他的原始类型了。这也是为创建面向对象特性做准备。</p><h2 id="指令集的抽象"><a href="#指令集的抽象" class="headerlink" title="指令集的抽象"></a>指令集的抽象</h2><p>字节码指令中有很多指令仅仅是在数据类型上有区别，以 return 指令举例：</p><ul><li>return - 方法返回</li><li>ireturn - 返回interger</li><li>freturn - 返回float</li><li>dreturn - 返回double</li><li>lreturn - 返回long</li><li>areturn - 返回引用</li></ul><p>字节码生成的时候，我们多写一点 case 语句可以实现，但是很丑陋。因此我用 TypeSpecificOpcodes 枚举存储了所有类型对应的字节码指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum TypeSpecificOpcodes &#123; </span><br><span class="line"></span><br><span class="line">    INT (ILOAD, ISTORE, IRETURN,IADD,ISUB,IMUL,IDIV), //values (-127,127) - one byte.</span><br><span class="line">    LONG (LLOAD, LSTORE, LRETURN,LADD,LSUB,LMUL,LDIV),</span><br><span class="line">    FLOAT (FLOAD, FSTORE, FRETURN,FADD,FSUB,FMUL,FDIV),</span><br><span class="line">    DOUBLE (DLOAD, DSTORE, DRETURN,DADD,DSUB,DMUL,DDIV),</span><br><span class="line">    VOID(ALOAD, ASTORE, RETURN,0,0,0,0),</span><br><span class="line">    OBJECT (ALOAD,ASTORE,ARETURN,0,0,0,0);</span><br><span class="line"></span><br><span class="line">    TypeSpecificOpcodes(int load, int store, int ret, int add, int sub, int mul, int div) &#123;</span><br><span class="line">        //assign each parameter to the field</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //getters</span><br></pre></td></tr></table></figure><p>类型相关的字节码指令，目前我们用到了：</p><ul><li>load - 从局部变量表中加载变量</li><li>store - 存储至局部变量表</li><li>ret - 返回</li><li>add - 操作数栈中两个数相加</li><li>sub - 栈中操作数相减</li><li>mul - 栈中操作数相乘</li><li>div - 栈中操作数相除</li></ul><p>TypeSpecificOpcodes 是在 BultInType 类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum BultInType implements Type &#123;</span><br><span class="line">    BOOLEAN(&quot;bool&quot;,boolean.class,&quot;Z&quot;, TypeSpecificOpcodes.INT),</span><br><span class="line">    </span><br><span class="line">    //other members</span><br><span class="line">    </span><br><span class="line">    BultInType(String name, Class&lt;?&gt; typeClass, String descriptor, TypeSpecificOpcodes opcodes) &#123;</span><br><span class="line">        //assign to fields</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int getMultiplyOpcode() &#123;</span><br><span class="line">        return opcodes.getMultiply();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无论何时，两个数相乘，只要知道类型就可以了，再也不用查找类型对应的字节码指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void generate(Multiplication expression) &#123;</span><br><span class="line">    evaluateArthimeticComponents(expression);</span><br><span class="line">    Type type = expression.getType();</span><br><span class="line">    methodVisitor.visitInsn(type.getMultiplyOpcode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main(string[] args) &#123;</span><br><span class="line">        var stringVar = &quot;str&quot;</span><br><span class="line">        var booleanVar = true</span><br><span class="line">        var integerVar = 2745 + 33</span><br><span class="line">        var doubleVar = 2343.05</span><br><span class="line">        var sumOfDoubleVars =  23.0 + doubleVar</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>编译后的字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AllPrimitiveTypes &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #8                  // String str</span><br><span class="line">       2: astore_1                          //store it variable</span><br><span class="line">       3: ldc           #9                  // int 1 - bool values are represented as ints in JVM</span><br><span class="line">       5: istore_2                          //store as int </span><br><span class="line">       6: ldc           #10                 // int 2745 </span><br><span class="line">       8: ldc           #11                 // int 33</span><br><span class="line">      10: iadd                              // iadd - add integers</span><br><span class="line">      11: istore_3                          //store result in integer varaible</span><br><span class="line">      12: ldc           #12                 // float 2343.05f </span><br><span class="line">      14: fstore        4                   //store in float variable</span><br><span class="line">      16: ldc           #13                 // float 23.0f </span><br><span class="line">      18: fload         4                   //load integer varaible (from index 4)</span><br><span class="line">      20: fadd                              //add float variables</span><br><span class="line">      21: fstore        5                   //store float result</span><br><span class="line">      23: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 14 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 13</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-13/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-13/</id>
    <published>2018-09-04T14:13:00.000Z</published>
    <updated>2018-09-04T14:53:33.176Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 13 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-13" target="_blank" rel="noopener">Github</a></p><h2 id="范围-for-循环"><a href="#范围-for-循环" class="headerlink" title="范围 for 循环"></a>范围 for 循环</h2><p>本节中我们来实现范围循环，在范围内迭代值，在 Java 中大概张这个样子：<br><code>for (int i=0;i&lt;=5;i++)</code></p><p>Enkel 的等价形式：<br><code>for i from 0 to 5</code></p><p>我实现另外一个特性，循环会自动检测是递增还是递减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i from 0 to 5 //increment i from 0 to 5  - for (int i=0;i&lt;=5;i++)</span><br><span class="line"></span><br><span class="line">for i from 5 to 0 //decremenet i from 5 to 0 - for (int i=5;i&gt;=0;i--)</span><br></pre></td></tr></table></figure><p>递增或者递减必须在运行时推断，因为范围的值可能是方法调用的返回值。</p><p>for while 循环或者容器迭代器都很相似，本节不做描述。</p><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">statement : block</span><br><span class="line">           //other statement alternatives</span><br><span class="line">           | forStatement ;</span><br><span class="line"></span><br><span class="line">forStatement : &apos;for&apos; (&apos;(&apos;)? forConditions (&apos;)&apos;)? statement ;</span><br><span class="line">forConditions : iterator=varReference  &apos;from&apos; startExpr=expression range=&apos;to&apos; endExpr=expression ;</span><br></pre></td></tr></table></figure><ul><li>forConditions 是迭代的条件表达式</li><li>= 提高可读性</li><li>迭代器必须是变量的名字</li><li>startExpression 用来初始化迭代器</li><li>endExpressions 是迭代器的终止值</li></ul><p><code>for (i from 0 to 5) print i</code> 图形化的解析树如下所示：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_13/parse_tree.gif" alt=""></p><h2 id="匹配-Antlr-上下文对象"><a href="#匹配-Antlr-上下文对象" class="headerlink" title="匹配 Antlr 上下文对象"></a>匹配 Antlr 上下文对象</h2><p>Antlr 根据语法规则会生成 ForStatementContext 对象，我们用它生成对编译器更加友好的类。可以解决迭代器变量未生明的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ForStatementVisitor extends EnkelBaseVisitor&lt;RangedForStatement&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //other stuff</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public RangedForStatement visitForStatement(@NotNull ForStatementContext ctx) &#123;</span><br><span class="line">        EnkelParser.ForConditionsContext forExpressionContext = ctx.forConditions();</span><br><span class="line">        Expression startExpression = forExpressionContext.startExpr.accept(expressionVisitor);</span><br><span class="line">        Expression endExpression = forExpressionContext.endExpr.accept(expressionVisitor);</span><br><span class="line">        VarReferenceContext iterator = forExpressionContext.iterator;</span><br><span class="line">        String varName = iterator.getText();</span><br><span class="line">        //If variable referenced by iterator already exists in the scope</span><br><span class="line">        if(scope.localVariableExists(varName)) &#123; </span><br><span class="line">            //register new variable value</span><br><span class="line">            Statement iteratorVariable = new AssignmentStatement(varName, startExpression); </span><br><span class="line">            //get the statement (usually block))</span><br><span class="line">            Statement statement = ctx.statement().accept(statementVisitor); </span><br><span class="line">            return new RangedForStatement(iteratorVariable, startExpression, endExpression,statement, varName, scope); </span><br><span class="line">        //Variable has not been declared in the scope</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            //create new local variable and add to the scope</span><br><span class="line">            scope.addLocalVariable(new LocalVariable(varName,startExpression.getType())); </span><br><span class="line">            //register variable declaration statement</span><br><span class="line">            Statement iteratorVariable = new VariableDeclarationStatement(varName,startExpression); </span><br><span class="line">            Statement statement = ctx.statement().accept(statementVisitor);</span><br><span class="line">            return new RangedForStatement(iteratorVariable, startExpression, endExpression,statement, varName,scope);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器变量可能在作用中存在或者未生明，这两种情况都需要被妥善处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var iterator = 0</span><br><span class="line">for (iterator from 0 to 5) print iterator</span><br></pre></td></tr></table></figure><p>迭代器已经声明过，赋值给 startExpression。<br><code>new AssignmentStatement(varName,startExpression);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (iterator from 0 to 5) print iterator</span><br></pre></td></tr></table></figure><p>迭代器没有声明，首先声明，然后赋值给 startExpression。<br><code>new VariableDeclarationStatement(varName,startExpression);</code></p><h2 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h2><p>RangedForStatement 生成后，下面我们开始生成字节码。</p><p>JVM 中没有为 for 循环设计特殊的指令。一种实现方式就是使用控制流指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void generate(RangedForStatement rangedForStatement) &#123;</span><br><span class="line">    Scope newScope = rangedForStatement.getScope();</span><br><span class="line">    StatementGenerator scopeGeneratorWithNewScope = new StatementGenerator(methodVisitor, newScope);</span><br><span class="line">    ExpressionGenrator exprGeneratorWithNewScope = new ExpressionGenrator(methodVisitor, newScope);</span><br><span class="line">    Statement iterator = rangedForStatement.getIteratorVariableStatement();</span><br><span class="line">    Label incrementationSection = new Label();</span><br><span class="line">    Label decrementationSection = new Label();</span><br><span class="line">    Label endLoopSection = new Label();</span><br><span class="line">    String iteratorVarName = rangedForStatement.getIteratorVarName();</span><br><span class="line">    Expression endExpression = rangedForStatement.getEndExpression();</span><br><span class="line">    Expression iteratorVariable = new VarReference(iteratorVarName, rangedForStatement.getType());</span><br><span class="line">    ConditionalExpression iteratorGreaterThanEndConditional = new ConditionalExpression(iteratorVariable, endExpression, CompareSign.GREATER);</span><br><span class="line">    ConditionalExpression iteratorLessThanEndConditional = new ConditionalExpression(iteratorVariable, endExpression, CompareSign.LESS);</span><br><span class="line"></span><br><span class="line">    //generates varaible declaration or variable reference (istore)</span><br><span class="line">    iterator.accept(scopeGeneratorWithNewScope);</span><br><span class="line"></span><br><span class="line">    //Section below checks whether the loop should be iterating or decrementing</span><br><span class="line">    //If the range start is smaller than range end (i from 0 to 5)  then iterate (++)</span><br><span class="line">    //If the range start is greater than range end (i from 5 to 0) then decrement (--)</span><br><span class="line"></span><br><span class="line">    //Pushes 0 or 1 onto the stack </span><br><span class="line">    iteratorLessThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    //IFNE - is value on the stack (result of conditional) different than 0 (success)?</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFNE,incrementationSection);</span><br><span class="line"></span><br><span class="line">    iteratorGreaterThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFNE,decrementationSection);</span><br><span class="line"></span><br><span class="line">    //Incrementation section</span><br><span class="line">    methodVisitor.visitLabel(incrementationSection);</span><br><span class="line">    rangedForStatement.getStatement().accept(scopeGeneratorWithNewScope); //execute the body</span><br><span class="line">    methodVisitor.visitIincInsn(newScope.getLocalVariableIndex(iteratorVarName),1); //increment iterator</span><br><span class="line">    iteratorGreaterThanEndConditional.accept(exprGeneratorWithNewScope); //is iterator greater than range end?</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFEQ,incrementationSection); //if it is not go back loop again </span><br><span class="line">    //the iterator is greater than end range. Break out of the loop, skipping decrementation section</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.GOTO,endLoopSection); </span><br><span class="line"></span><br><span class="line">    //Decrementation section</span><br><span class="line">    methodVisitor.visitLabel(decrementationSection);</span><br><span class="line">    rangedForStatement.getStatement().accept(scopeGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitIincInsn(newScope.getLocalVariableIndex(iteratorVarName),-1); //decrement iterator</span><br><span class="line">    iteratorLessThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFEQ,decrementationSection);</span><br><span class="line"></span><br><span class="line">    methodVisitor.visitLabel(endLoopSection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来有点复杂，因为递增递减的推测逻辑是在运行时决定的。</p><p>以 <code>for (i from 0 to 5)</code> 为例，我们来看一下整个流程:</p><ol><li>声明迭代器变量 i 并且赋予初始值 0</li><li>检测迭代器的值 0 是否大于结束值 5</li><li>因为 0 &lt; 5, 因此递增，跳到递增部分</li><li>执行 for 循环体内的语句</li><li>递增 1</li><li>检查迭代器的值是否大于 5</li><li>如果条件不成立，跳到 4</li><li>循环体执行 5 次后，跳到结束部分</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Loops &#123;</span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">        for i from 1 to 5 &#123;</span><br><span class="line">            print i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成后的字节码反编译后的 Java 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Loops &#123;</span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        int var1 = 1;</span><br><span class="line">        if(var1 &gt;= 5 ) &#123; //should it be decremented?</span><br><span class="line">            do &#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">                --var1;</span><br><span class="line">            &#125; while(var1 &gt;= 5);</span><br><span class="line">        &#125; else &#123; //should it be incremented?</span><br><span class="line">            do &#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">                ++var1;</span><br><span class="line">            &#125; while(var1 &lt;= 5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ java Loops </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 13 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 12</title>
    <link href="https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-12/"/>
    <id>https://blog.0xff000000.com/2018/09/04/Creating-JVM-Language-Part-12/</id>
    <published>2018-09-04T14:00:00.000Z</published>
    <updated>2018-09-04T14:03:08.196Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 12 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-12" target="_blank" rel="noopener">Github</a></p><h2 id="为什么需要命名参数"><a href="#为什么需要命名参数" class="headerlink" title="为什么需要命名参数"></a>为什么需要命名参数</h2><p>在 Java 中（多数语言中也是如此）方法调用的参数匹配是通过索引值，如果方法调用的参数比较少并且参数的类型有差别的情况，是合理的。不幸的是，如果方法调用的参数有很多个，并且类型相同，这是个悲剧。</p><p>例如：<br><code>Rect createRectangle(int x1,int y1,int x2, int y2) //createRectangle signature</code></p><p>我打赌你很有可能会传错参数。</p><p>你发现问题了吗？这种情况开发者很容易搞混参数的顺序，由于是相同类型，编译器也没办帮你检查问题。</p><p>这就是命名参数的有点，你可以给参数指定名字，而不是仅仅通过索引值来指定参数。<br>使用命名参数有很多好处：</p><ul><li>参数的顺序不受限制</li><li>代码可读性提高</li><li>不用再两个文件中跳转对比方法的签名和实际传参是否一致</li></ul><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functionCall : functionName &apos;(&apos;argument? (&apos;,&apos; argument)* &apos;)&apos;;</span><br><span class="line">argument : expression              //unnamed argument</span><br><span class="line">         | name &apos;-&gt;&apos; expression   ; //named argument</span><br></pre></td></tr></table></figure><p>方法调用的参数之间用逗号分割。argument 有两种格式，命名参数和未命名参数，这两种格式不允许同时存在。</p><h2 id="记录参数"><a href="#记录参数" class="headerlink" title="记录参数"></a>记录参数</h2><p>在第七部分描述到，方法的解析分为两个步骤: 首先记录所有的方法签名（方法的声明），下一步是解析方法体，这样保证在解析方法体的时候，所有的方法签名都已经被解析过了。</p><p>实现命名参数的思路是把命名参数的调用转换成未命名参数的调用，参数索引位置通过方法签名去获得：</p><ul><li>在方法签名中查找匹配的参数名字</li><li>获得参数的索引</li><li>如果参数的索引值和实际不一致，记录下来</li></ul><p><img src="http://jakubdziworski.github.io/assets/media/enkle_12/diagram.gif" alt=""></p><p>上图中的示例，x1 的索引和 y1 对调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    @Override</span><br><span class="line">    public Expression visitFunctionCall(@NotNull EnkelParser.FunctionCallContext ctx) &#123;</span><br><span class="line">        String funName = ctx.functionName().getText();</span><br><span class="line">        FunctionSignature signature = scope.getSignature(funName); </span><br><span class="line">        List&lt;EnkelParser.ArgumentContext&gt; argumentsCtx = ctx.argument();</span><br><span class="line">        //Create comparator that compares arguments based on their index in signature</span><br><span class="line">        Comparator&lt;EnkelParser.ArgumentContext&gt; argumentComparator = (arg1, arg2) -&gt; &#123;</span><br><span class="line">            if(arg1.name() == null) return 0; //If the argument is not named skip</span><br><span class="line">            String arg1Name = arg1.name().getText();</span><br><span class="line">            String arg2Name = arg2.name().getText();</span><br><span class="line">            return signature.getIndexOfParameter(arg1Name) - signature.getIndexOfParameter(arg2Name);</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Expression&gt; arguments = argumentsCtx.stream() //parsed arguments (wrong order)</span><br><span class="line">                .sorted(argumentComparator) //Order using created comparator</span><br><span class="line">                .map(argument -&gt; argument.expression().accept(this)) //Map parsed arguments into expressions</span><br><span class="line">                .collect(toList());</span><br><span class="line">        return new FunctionCall(signature, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式对字节码的生成是透明的，字节码生成阶段无需了解方法调用参数是命名还是未命名</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下的 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NamedParamsTest &#123;</span><br><span class="line"></span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">        createRect(x1-&gt;25,x2-&gt;-25,y1-&gt;50,y2-&gt;-50)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createRect (int x1,int y1,int x2, int y2) &#123;</span><br><span class="line">        print &quot;Created rect with x1=&quot; + x1 + &quot; y1=&quot; + y1 + &quot; x2=&quot; + x2 + &quot; y2=&quot; + y2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的字节码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NamedParamsTest &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        25          //x1 (1 index in call)</span><br><span class="line">       2: bipush        50          //y1 (3 index in call)</span><br><span class="line">       4: bipush        -25         //x2 (2 index in call)</span><br><span class="line">       6: bipush        -50         //y2 (4 index in call)</span><br><span class="line">       8: invokestatic  #10                 // Method createRect:(IIII)V</span><br><span class="line">      11: return</span><br><span class="line"></span><br><span class="line">  public static void createRect(int, int, int, int);</span><br><span class="line">    Code:</span><br><span class="line">      //normal printing code </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><code>Created rect with x1=25 y1=50 x2=-25 y2=-50</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文系 &lt;a href=&quot;http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Creating JVM language&lt;/a&gt; 翻译的第 12 篇。&lt;br&gt;原文中的代码和原文有不一致的地方均在新的&lt;a href=&quot;https://github.com/KevinOfNeu/Enkel&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;代码仓库&lt;/a&gt;中更正过，建议参考新的代码仓库。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="翻译" scheme="https://blog.0xff000000.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Enkel" scheme="https://blog.0xff000000.com/tags/Enkel/"/>
    
      <category term="JVM" scheme="https://blog.0xff000000.com/tags/JVM/"/>
    
  </entry>
  
</feed>
