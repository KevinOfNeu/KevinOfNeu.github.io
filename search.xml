<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>100 天阅读计划，深入剖析程序和计算机 - lambda 演算</title>
      <link href="/2019/01/05/reading-plan-01-07/"/>
      <url>/2019/01/05/reading-plan-01-07/</url>
      <content type="html"><![CDATA[<p>我们将研究一种叫作无类型 lambda 演算（untyped lambda calculus）的极小编程语言。首先，我们将用尽可能少的语言特性写（用 Ruby）一些接近 lambda 演算的程序。</p><p>这将仍然仅仅是在用 Ruby 编程，但施加虚构的约束之后，我们便能很轻松地探索一个受限的语义，而不需要学习一门新语言。然后，我们了解到这些非常有限的特性集合能做什么以后，就将利用这些特性把它们实现为一种语言（使用它自己的解析器、抽象语法和操作语义）—— 使用我们在之前章节中学到的技术。</p><a id="more"></a><h2 id="模拟lambda演算"><a href="#模拟lambda演算" class="headerlink" title="模拟lambda演算"></a>模拟lambda演算</h2><p>proc<br><code>-&gt; x { -&gt; y { x.call(y) } }</code></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>写一个程序输出数字 1 到 100。但如果数字是 3 的倍数，就不输出数字而是输出“Fizz” ， 如果是 5 的倍数就输出 “Buzz” 。 对于那些 3 和 5 的公倍数， 就输出 “FizzBuzz” 。</p><p>完整特性的 Ruby 实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1..100).map do |n|</span><br><span class="line">  if (n % 15).zero?</span><br><span class="line">    &apos;FizzBuzz&apos; </span><br><span class="line">  elsif (n % 3).zero?     </span><br><span class="line">    &apos;Fizz&apos;   </span><br><span class="line">  elsif (n % 5).zero?     </span><br><span class="line">    &apos;Buzz&apos;   </span><br><span class="line">  else     </span><br><span class="line">    n.to_s   </span><br><span class="line">end</span><br></pre></td></tr></table></figure></p><h3 id="实现数字"><a href="#实现数字" class="headerlink" title="实现数字"></a>实现数字</h3><p>描绘数字特征的一种方式是某个动作的重复（或者叫迭代）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def one(proc, x)</span><br><span class="line">    proc[x]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def two(proc, x)</span><br><span class="line">  proc[proc[x]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>以此类推。<br>按照这种模式，可以很自然地把 #zero 定义为一个带有 proc 和另一个参数的方法，这个方法完全忽略 proc（换句话说，对其调用零次） ，并且会原封不动地返回第二个参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def zero(proc, x)</span><br><span class="line">   x </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>把 数 据 表 示 为 纯 代 码 的 技 术 称 为 邱 奇 编 码（Church encoding） ， 它 是 以lambda 演算（<a href="http://dx.doi.org/10.2307/2371045）的发明者阿隆佐·邱奇的名字命名的。这些数字是邱奇数（Church" target="_blank" rel="noopener">http://dx.doi.org/10.2307/2371045）的发明者阿隆佐·邱奇的名字命名的。这些数字是邱奇数（Church</a> numeral） ，而且我们很快将会看到邱奇布尔值（Church Boolean）和邱奇有序对（Church pair）的例子。</p><h3 id="实现布尔值"><a href="#实现布尔值" class="headerlink" title="实现布尔值"></a>实现布尔值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def true(x, y)   </span><br><span class="line">    x </span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line">def false(x, y)</span><br><span class="line">   y </span><br><span class="line">end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">IF =</span><br><span class="line">   -&gt; b &#123;     </span><br><span class="line">       -&gt; x &#123;       </span><br><span class="line">           -&gt; y &#123; </span><br><span class="line">                   b[x][y]       </span><br><span class="line">            &#125;     </span><br><span class="line">       &#125;   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="实现谓词"><a href="#实现谓词" class="headerlink" title="实现谓词"></a>实现谓词</h3><p><code>IS_ZERO = -&gt; n { n[-&gt; x { FALSE }][TRUE] }</code></p><h3 id="有序对"><a href="#有序对" class="headerlink" title="有序对"></a>有序对</h3><p>最简单的数据结构是有序对（pair） ，它跟二元数组类似。有序对实现起来非常容易。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PAIR  = -&gt; x &#123; -&gt; y &#123; -&gt; f &#123; f[x][y] &#125; &#125; &#125; </span><br><span class="line">LEFT  = -&gt; p &#123; p[-&gt; x &#123; -&gt; y &#123; x &#125; &#125; ] &#125; </span><br><span class="line">RIGHT = -&gt; p &#123; p[-&gt; x &#123; -&gt; y &#123; y &#125; &#125; ] &#125;</span><br></pre></td></tr></table></figure><h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>现在有了数字，布尔值，条件，谓词以及有序对，下面实现数值运算。</p><p>递增:<br><code>INCREMENT = -&gt; n { -&gt; p { -&gt; x { p[n[p][x]] } } }</code></p><p>我们调用这个新的 proc 的时候它会做什么呢？首先它会以 p 和 x 作为参数调用 n——因为n 是一个数字，所以这意味着就像原始的数字那样， “在 x 上对 p 进行 n 次调用”——然后对结果再调用一次 p。那么总体说来，这个 proc 的第一个参数会在它的第二个参数上调用n+1 次，这恰好是表示数字 n+1 的方法。</p><p>递减呢？这看起来是个更难的问题。</p><p>一个解决办法就是设计一个 proc，在对某个初始参数调用 n 次的时候返回数字 n-1。幸运的是，有序对正好可以帮助我们实现这种方法。思考一下这个 Ruby 方法所做的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def slide(pair)   </span><br><span class="line">    [pair.last, pair.last + 1] </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在我们用数字组成的二元数组为参数调用 slide 时，它会返回一个新的二元数组，这个二元数组包含第二个数字还有比第二个数字大 1 的数字；如果输入的数组包含的是连续数字，那么效果就是向上“滑动”一个数字窗口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([3, 4]) </span><br><span class="line">=&gt; [4, 5] </span><br><span class="line">&gt;&gt; slide([8, 9]) </span><br><span class="line">=&gt; [9, 10]</span><br></pre></td></tr></table></figure></p><p>这很有用，因为通过在 -1 处开始一个窗口，我们可以安排一种情况，让数组里的第一个数字比我们调用 slide 的次数小 1，即使我们只是在递增数据 :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([-1, 0])</span><br><span class="line">=&gt; [0, 1] </span><br><span class="line">&gt;&gt; slide(slide([-1, 0])) </span><br><span class="line">=&gt; [1, 2] </span><br><span class="line">&gt;&gt; slide(slide(slide([-1, 0]))) </span><br><span class="line">=&gt; [2, 3] </span><br><span class="line">&gt;&gt; slide(slide(slide(slide([-1, 0])))) </span><br><span class="line">=&gt; [3, 4]</span><br></pre></td></tr></table></figure></p><p>我们不能只用基于 proc 的数字完成，因为没法表示 -1，但 side 的有趣之处是不管怎样它只关注数组中的第二个数，因此我们可以放入任意的哑值（dummy value）——比如说0——替换掉 -1，这样仍然能得到同样的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; slide([0, 0]) </span><br><span class="line">=&gt; [0, 1] </span><br><span class="line">&gt;&gt; slide(slide([0, 0])) </span><br><span class="line">=&gt; [1, 2] </span><br><span class="line">&gt;&gt; slide(slide(slide([0, 0]))) </span><br><span class="line">=&gt; [2, 3] </span><br><span class="line">&gt;&gt; slide(slide(slide(slide([0, 0])))) </span><br><span class="line">=&gt; [3, 4]</span><br></pre></td></tr></table></figure></p><p>这是让 DECREMENT 工作的关键：我们可以把 slide 转成一个 proc，使用数字 n 的 proc 表示对由 ZERO 组成的有序对调用 slide n 次，然后使用 LEFT 从结果的有序对中拉出左边的数来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SLIDE     = -&gt; p &#123; PAIR[RIGHT[p]][INCREMENT[RIGHT[p]]] &#125; </span><br><span class="line">DECREMENT = -&gt; n &#123; LEFT[n[SLIDE][PAIR[ZERO][ZERO]]] &#125;</span><br></pre></td></tr></table></figure><p><em>注：</em>DECREMENT[ZERO] 的结果实际上只是最初的 PAIR[ZERO][ZERO] 值的左边元素，在这种情况下根本就没有对其调用过 SLIDE。既然没有负值，0 就是我们能提供给 DECREMENT[ZERO] 的最合理的答案，因此使用 0 作为哑值是个好主意。</p><p>有了 INCREMENT 和 DECREMENT，就可能实现类似加法、减法、乘法和取幂这样的数字运算了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ADD      = -&gt; m &#123; -&gt; n &#123; n[INCREMENT][m] &#125; &#125; </span><br><span class="line">SUBTRACT = -&gt; m &#123; -&gt; n &#123; n[DECREMENT][m] &#125; &#125; </span><br><span class="line">MULTIPLY = -&gt; m &#123; -&gt; n &#123; n[ADD[m]][ZERO] &#125; &#125; </span><br><span class="line">POWER    = -&gt; m &#123; -&gt; n &#123; n[MULTIPLY[m]][ONE] &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h3><p>MOD，map, range, 字符串都可以利用以上实现来实现，此处略。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
            <tag> lamda </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，深入剖析程序和计算机 - 图灵机</title>
      <link href="/2019/01/02/reading-plan-01-06/"/>
      <url>/2019/01/02/reading-plan-01-06/</url>
      <content type="html"><![CDATA[<p>有限自动机和下推自动机——都有很严格的限制，这些限制影响了它们作为现实计算模型的使用。我们的小型系统还要多强大，才能摆脱这些限制并完成正常计算机的所有工作呢？它还要多复杂才能对 RAM 或硬盘的行为以及合适的输出机制建模呢？怎么才能设计一台能实际运行程序而不总是执行某个硬编码任务的机器呢？</p><a id="more"></a><p>20 世纪 30 年代，阿兰·图灵（Alan Turing）致力于从本质上解决这个问题。在那个年代，单词 computer 意味着一个人，通常是一个女人，她手工重复着一系列繁重的数学性操作以执行长长的计算。图灵当时正在寻找一种理解和描述“人肉计算机”操作特征的方法，这样同样的工作就可以完全由机器执行。本章，我们将看到图灵关于设计最简单的“自动化机器”的思想，这一机器具有手工计算的全部能力和复杂性。</p><h2 id="确定型图灵机"><a href="#确定型图灵机" class="headerlink" title="确定型图灵机"></a>确定型图灵机</h2><p>我们通过给一台有限自动机赋予一个作为外部存储的栈，增强了它的计算能力。与由机器状态提供的有限内部存储相比，栈的真正优点是能动态增长以适应任意数量的信息，从而使下推自动机能够处理那些需要存储任意数量数据的问题。</p><p>但是，外部存储这种特殊的形式给如何使用存储之后的数据带来了限制。通过把栈替换成更灵活的存储机制，我们可以消除这些限制并进一步提高能力。</p><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><blockquote><p>计算通常可以通过在纸上写某些符号完成。我们可以把这张纸想象成小朋友的算术本，它被划分成了一个个方格。在初等算术里，我们有时也会使用纸的二维特性。但这种使用通常是可以避免的，并且我认为纸的二维性不是计算的本质，而且相信大家也赞同我这一观点。我假定计算是在一张一维的纸上完成的，比如在一条分成方格的纸带上完成。 ——阿兰•图灵， 《论可计算数及其在判定性问题上的应用》</p></blockquote><p>图灵的做法是给一台机器配上一条无限长的空纸带（实际上是一个两端都能随需增长的一维数组） ，并且允许在纸带上的任意位置读写字符。一条纸带既做存储又做输入：可以在纸带上预先填满字符串当作输入，然后机器在执行过程中可以读取这些字符并在必要的时候覆盖它们。</p><p>能访问一条无限长纸带的有限状态自动机叫作图灵机（Turing Machine，TM ） 。这个名字通常指一条拥有确定性规则的机器，但我们也可以毫无歧义地叫它确定型图灵机（Deterministic Turing Machine，DTM） 。</p><p>传统的图灵机使用简单的安排：用一个纸带头（tape head）指向纸带的一个特定位置，并且只能在那个位置读取或写入字符。每一步计算之后，纸带头都可以向左或者向右移动一个方格，这意味着一台图灵机为了到达远处的位置只能费力地在纸带上往复移动。使用移动缓慢的纸带头不会影响机器访问纸带上任何数据的能力，只会影响花费的时间，因此为了保持简单付出这个代价是值得的。</p><p>能访问纸带之后，除了能够接受或者拒绝字符串，我们又能解决新的问题了。例如，我们可以设计一台在纸带上就地递增一个二进制数的 DTM。为此，我们需要知道如何递增一个二进制数的一位数字。幸好这很简单：如果这位的数字是 0，就用 1 替换；如果这位数是 1，就用 0 替换，然后立即使用同样的方法增加它左边的数字（ “进 1 位” ） 。图灵机只需要使用这个过程递增二进制数的最右位，然后把纸带头移到起始位置。</p><ul><li>给机器赋予三个状态（状态 1、状态 2、状态 3） ，状态 3 作为接受状态</li><li>机器从状态 1 开始，纸带头指向一个二进制数的最右位</li><li>处于状态 1 并且读到一个 0（或者空白）时，就用 1 覆写，把纸带头向右移，然后回到 状态 2</li><li>处于状态 1 并且读到一个 1 时，就用 0 覆写，然后把纸带头向左移</li><li>处于状态 2 并且读到一个 0 或者 1 时，就把纸带头向右移</li><li>处于状态 2 并且读到空白时，就把纸带头向左移并转移到状态 3</li></ul><p>在机器试图递增一位数字的时候，它处于状态 1，在移回起始位置时处于状态 2，结束的时候处于状态 3。下面是初始纸带上字符串为 ‘1011’ 时对机器执行的跟踪。纸带头当前指向的字符会由括号包围，而下划线表示输入字符串某一端的空白方格。</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2019-01-02-151512.png" alt=""></p><h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><blockquote><p>让我们想象一下，由机器执行的操作被分解成“简单的操作” ，这些操作都非常基本，以至于无法想象它们能进一步分解。……操作实际上是由计算者的思维状态和被观察的符号决定的……具体来讲，操作执行之后，计算者的思维状态就确定了。<br>我们现在可以构造一台做这种计算者工作的机器了。  ——阿兰•图灵， 《论可计算数及其在判定性问题上的应用》</p></blockquote><p>在每一步计算中，可能都有几个“简单的操作”需要图灵机执行：在纸带头的当前位置读取字符，在那个位置写入一个新字符，把纸带头左移或者右移，或者改变状态。简单起见，我们没有为所有这些动作指定不同种类的规则，而只是像处理下推自动机时那样，只设计了一种能灵活适应各种条件的规则格式。</p><p>这个统一的规则格式有 5 部分：</p><ul><li>机器的当前状态</li><li>必须出现在纸带头当前位置的字符</li><li>机器的下一状态</li><li>要写入纸带头当前位置的字符</li><li>写入纸带之后纸带头的移动方向（向左还是向右）</li></ul><p>这里我们假设一台图灵机每次执行规则，都要改变状态并向纸带写一个字符。就像通常对状态机的处理那样，如果我们想要一个规则不实际改变状态，可以让“下一个状态”与当前状态相同；与之类似的是，如果想要一个规则不改变纸带内容，可以把与读到的字符一样的字符写入纸带。</p><h2 id="非确定性图灵机"><a href="#非确定性图灵机" class="headerlink" title="非确定性图灵机"></a>非确定性图灵机</h2><p>我们看到非确定性没有让有限自动机有什么不同。增加不确定性不会使一台图灵机更加强大。因为 DFA 和 DTM 都有足够的能力模拟其非确定性的对应机器。</p><h2 id="最大能力"><a href="#最大能力" class="headerlink" title="最大能力"></a>最大能力</h2><p>确定型图灵机代表了从有限计算机器到全能机器的临界点。实际上，通过升级图灵机规范以使其更强大的任何尝试都注定失败，因为它们本来就有能力模拟任何潜在的增强了。尽管增加某些特性会使图灵机更小巧或者更高效，但无法从根本上增强它们的能力。</p><p>例如对传统图灵机的 4 个其他扩展——内部存储、子例程、多纸带以及多维纸带，没有任何一个可以增加计算能力。</p><h2 id="通用机器"><a href="#通用机器" class="headerlink" title="通用机器"></a>通用机器</h2><p>尽管到目前为止我们看到的机器都有严重的缺陷：它们的规则都是硬编码的，这让它们无法适应不同的任务。一台能接受与一个特定正则表达式匹配的字符串的 DFA，不可能学会接受一个不同集合的字符串；一台能识别回文的 NPDA 将只能识别回文；一台递增二进制数的图灵机将永远不能做其他用途。</p><p>大多数现实中的计算机不是这么工作的。现代计算机不是专门做某一项特殊工作的，而是为了通用目的而设计的并且能通过编程执行不同的任务。尽管一台可编程计算机的指令集和 CPU 设计是固定的，但能通过软件控制它的硬件并根据用户需要改变它的行为。</p><p>我们的简单机器能做这样的事情吗？在做一件不同的工作时，不必每次去设计一台新的机器，而是设计一台简单机器，它会从输入读取一个程序，然后做这个程序定义的任何工作。这办得到吗？</p><p>或许不足为奇的是，一台图灵机足够强大，它能从纸带读取一台简单机器的描述——比如说，一台确定性有限自动机——然后运行这台机器的模拟以找出它的工作内容。</p><p>一台完整的图灵机以字符串的形式写在另一台图灵机的纸带上，准备通过模拟开始自己的生命周期。</p><p>它的规则手册、接受状态以及起始配置——都以编码的格式存在于UTM 的纸带上。为了执行模拟的一步，UTM 要在规则、当前状态和所模拟机器的纸带之间来回移动纸带头，以搜索出能应用到当前配置的一条规则。它找到一条规则的时候，就会根据规则里定义的字符和方向，更新所模拟的纸带，并把所模拟的机器放到新的状态上去。</p><p>这个过程会一直重复，直到所模拟的机器进入到一个接受状态，或者到达某个配置后因为没有规则应用处于卡死的状态。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
            <tag> 图灵机 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，深入剖析程序和计算机 - 增加计算能力</title>
      <link href="/2018/12/30/reading-plan-01-05/"/>
      <url>/2018/12/30/reading-plan-01-05/</url>
      <content type="html"><![CDATA[<p>之前部分探讨了有限自动机，这是一种假想的机器，它去掉了真实计算机的复杂性并把其规约成了最简单的形式。我们详细考察了这些机器的行为并了解了它们的用处，而且还发现，非确定性有限自动机虽然有一些奇特的执行方法，但计算能力并不比确定性有限自动机强。那如何增加计算能力呢？</p><a id="more"></a><h2 id="计算能力"><a href="#计算能力" class="headerlink" title="计算能力"></a>计算能力</h2><p>我们没法通过为有限自动机增加非确定性和自由移动这种奇特的特性来提高它的计算能力。</p><p>这个事实表明，我们已经停留在这些简单机器的计算水平上无法前进了。而且如果不从根本上改变机器的工作方式，将无法脱离这种停滞不前的境地。那么，所有这些机器到底有多强的能力呢？好吧，没有多少能力。它们被限制在非常有限的应用上（只能接受或者拒绝字符序列） ，而且即使在这么小的范围内，仍然很容易碰到机器无法识别的语言。</p><h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><p>举个例子，假设要设计一台有限自动机，要求它能读取带有左右括号的字符串，并且只有字符串中的左右括号是平衡的（即每一个右括号都能在字符串中找到与其匹配的左括号） ，它才会接受。</p><p>可以设计如下 NFA 来实现：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-121522.jpg" alt=""></p><p>一次读取一个字符，同时跟踪一个表示当前嵌套级别的数字：读入一个左括号时增加嵌套级别，读入一个右括号时降低嵌套级别。只要嵌套级别到零了，就表示当前读到的这些括号已经都匹配上了（因为嵌套级别增加和减少的数量是一样的） ，并且如果我们试图把嵌套级别降低到小于零的值，那就表明当前的右括号多了（如 ‘())’） ，不管还有什么字符没有读取，字符串里的括号一定已经不平衡了。</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>可是这种设计有一个严重的缺陷：如果括号的嵌套等级超过 3，它就会失败。它没有足够多的状态跟踪 ‘(((())))’ 这样的字符串的嵌套，因此即使括号明显是平衡的它也会拒绝。</p><p>我们可以通过临时增加更多的状态来修正此问题。一台拥有 5 个状态的 NFA 可以识别任意嵌套级别小于 5 的平衡字符串，而一台拥有 10 个、100 个或者 1000 个状态的 NFA，可以识别嵌套级别在机器硬限制以内的任意平衡字符串。但是，我们如何设计支持任意嵌套级别、能识别任意平衡字符串的 NFA 呢？结论是设计不出来：一台有限自动机的状态数总是有限的，因此任何机器能支持的嵌套级别也总是有限的，我们只要提供一个比它能处理的嵌套级别多一级的字符串，它就无法处理了。</p><p>根本问题是一台有限自动机只有固定的状态集合，因而其存储是有限的，因此没法跟踪任意数量的信息。在平衡字符串问题当中，一台 NFA 很容易递增到设计时限制的某个最大数目，但无法继续计数以适应任何可能大小的输入。</p><p>本质上大小固定的任务（比如对字符串 ‘abc’ 进行匹配） ，或者无需跟踪重复次数的任务（比如对正则表达式 ab*c 进行匹配） ，都不受这个问题的影响，但在信息数目不可预知，需要在计算过程中存储并在之后重用的场景下，这个问题会让有限自动机无能为力。</p><h2 id="增加计算能力"><a href="#增加计算能力" class="headerlink" title="增加计算能力"></a>增加计算能力</h2><p>为了解决存储问题，我们可以使用专门的原始空间扩展有限状态自动机，它负责在计算过程中存储数据。除状态提供的有限内部存储之外，这个空间给了机器一种外部存储（external memory） 。就像我们将会发现的那样，拥有外部存储对于一台机器的计算能力关系重大。</p><p>为有限自动机增加存储的简单方式就是让它可以访问栈，这是一个后进先出的数据结构，可以把字符推入和弹出。栈是简单而且有限制的数据结构——在任意时间都只有顶端的字符可以访问。为了查明栈下面位置的数据，我们只能丢弃顶层的字符，而一旦向栈内推入一串字符，我们就只能按相反的顺序把它们弹出——但它确实可以很好地解决有限存储的问题。对于栈的大小并没有内在的限制，因此原则上它可以根据需要存储数据。</p><p>自带栈的有限状态机叫作下推自动机（PushDown Automaton，PDA） ，如果这台机器的规则是确定性的，我们就叫它确定性下推自动机（Deterministic PushDown Automaton，DPDA）。</p><h2 id="问题解决方案-确定性下推自动机-PDA"><a href="#问题解决方案-确定性下推自动机-PDA" class="headerlink" title="问题解决方案 - 确定性下推自动机 PDA"></a>问题解决方案 - 确定性下推自动机 PDA</h2><p>能对栈进行访问带来了新的可能性，例如，很容易设计一台 DPDA 来识别括号组成的平衡字符串。</p><ul><li>给机器两个状态：1 和 2，状态 1 作为接受状态。</li><li>状态 1 作为机器的起始状态，此时栈为空。</li><li>如果处于状态 1 并且读入一个左括号，就把某个字符——我们使用 b 表示“括号”——入栈，并转移到状态 2。</li><li>如果处于状态 2 并且读入一个左括号，就把字符 b 入栈。</li><li>如果处于状态 2 并且读入一个右括号，就把字符 b 从栈中弹出。</li><li>如果处于状态 2 且栈为空，就转移回状态 1。</li></ul><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-121507.png" alt=""></p><h2 id="非确定性下推自动机-NPDA"><a href="#非确定性下推自动机-NPDA" class="headerlink" title="非确定性下推自动机 NPDA"></a>非确定性下推自动机 NPDA</h2><p>尽管处理平衡括号问题的机器确实需要栈来完成工作，但它其实只是将栈作为一个计数器，并且它的规则只区分“栈为空”和“栈不为空” 。更复杂的 DPDA 将会把一种以上的符号推入栈中，并在执行计算时使用这些信息。一个简单的例子是一台机器，它能识别包含相等数目的两种字符的字符串，比如 a 和 b。</p><p>DPDA 没有利用栈的全部优点。为了真正开发出栈的潜能，我们需要一个更难的问题强迫我们存储结构化信息。经典的例子是识别回文字符串：随着一个字符一个字符地读取输入字符串，我们需要记住所看到的数据；一旦字符串读取过了一半，就要检查内存以确定之前看到的字符是否为当前呈现字符的逆序。下面这个 DPDA 能够识别一个回文字符串，这个字符串由字符 a 和 b 组成，并且在中间的位置有一个字符 m（表示中间位置） ：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-122426.png" alt=""></p><p>这台机器从状态 1 开始，不断从输入读取 a 和 b，然后把它们推入栈中。它读到 m 的时候，会转移到状态 2，在那里一直读取输入字符同时尝试把每一个字符都弹出栈。如果字符串后半部分的每一个字符都与栈中弹出的内容匹配，机器就停留在状态 2 并最终碰到栈底的 $，此时转移到状态 3 并接受这个输入字符串。处于状态 2 的时候，如果读入的任何字符与栈顶的字符不匹配，那就没有规则可以遵守，因此它将进入阻塞状态并拒绝这个字符串。</p><p>没有确定性约束的下推自动机叫作非确定性下推自动机（nondeterministic pushdown automaton） 。下面是一台能识别由偶数个字母组成的回文字符串的非确定性下推自动机：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-30-122540.png" alt=""></p><h2 id="使用下推自动机进行分析"><a href="#使用下推自动机进行分析" class="headerlink" title="使用下推自动机进行分析"></a>使用下推自动机进行分析</h2><p>下推自动机有一个重要的实际应用：它们能用来解析编程语言。传统的方式是把解析过程分成两个独立的阶段:</p><ul><li><p>词法分析<br>读取一个原始字符串然后把它转换成一个单词 token 序列。每一个单词 token 代表程序语法的一个组成部分，例如“变量名” 、 “左括号”或者“while 关键字” 。词法分析器使用称为词法的规则集合来决定什么样的字符应该产生什么样的单词。这个阶段处理杂乱的字符级别的细节，比如变量命名规则、注释和空格，它为下一阶段的处理准备好清楚的单词序列。</p></li><li><p>语法分析<br>读入一个单词序列并根据正在分析的语言语法判断它们是否代表一个有效的程序。如果程序有效，那么语法解析器会生成一些关于程序结构的附加信息（如一个解析树）。</p></li></ul><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>词法分析阶段通常相当直接。这可以通过正则表达式实现（因而也就是通过一台 NFA 实现） ，因为它把字符序列与一些规则简单匹配以判断那些字符是否为关键字、变量名、运算符或者其他什么符号。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p>使用下推自动机是可以识别单词的有效序列。</p><p>分析的过程依赖于非确定性，但在实际程序中，最好能避免非确定性，因为一个确定性的 PDA 模拟起来要比非确定性的快得多而且容易得多。幸运的是，在每个阶段几乎都可以使用输入单词本身决定该应用哪个符号规则，这样就可能把非确定性去掉——这个技术叫作递推（lookahead）——但这让从 CFG 到 PDA 的转换更为复杂。</p><p>在实践中，我们可以让 PDA 模拟记录它到达接受状态过程中的规则序列，以此来创建结构化表示，这个规则序列提供了构建一个分析树所需的足够信息。</p><h2 id="计算能力-1"><a href="#计算能力-1" class="headerlink" title="计算能力"></a>计算能力</h2><p>我们见到了两个新的计算能力的级别：DPDA 比 DFA 和 NFA 更强大，而NPDA 要比 DPDA 更强大。能访问栈之后，看起来下推自动机比有限自动机要强大和复杂一些。</p><p>拥有栈的主要结果就是能识别某些有限自动机不能识别的语言了，如回文和平衡括号字符串。栈提供的无限存储使 PDA 能在计算中记住任意数量的信息并在随后再次使用它。</p><p>PDA 能识别回文，但它不能识别 ‘abab’ 和 ‘baaabaaa’ 这样“双倍”的字符串，因为一旦信息被推入到栈中，就只能以相反的顺序处理了。</p><p>如果我们抛开识别字符串的特定问题，而把这些机器看成通用目的的计算机，就可以看到DFA、NFA 和 PDA 还远远不够有用。首先，它们都没有像样的输出机制：它们通过进入接受状态表达成功，但不能输出哪怕一个字符（更不用说由字符组成的字符串了）来表示详细的结果。无法将信息发送回世界意味着它们连把两个数相加这样的简单算法都实现不了。而像有限自动机一样，PDA 有一个固定的程序；没有明显的方法构建出一台 PDA 能以某种方式从输入读取一个程序然后运行。</p><p>所有这些缺点意味着我们需要一个更好的计算模型，去真正地研究计算机能干什么。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
            <tag> NFA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，深入剖析程序和计算机 - 非确定性有限自动机（NFA）</title>
      <link href="/2018/12/27/reading-plan-01-04/"/>
      <url>/2018/12/27/reading-plan-01-04/</url>
      <content type="html"><![CDATA[<p>NFA 以及正则表达式的原理。</p><a id="more"></a><h2 id="非确定性"><a href="#非确定性" class="headerlink" title="非确定性"></a>非确定性</h2><p>假设我们想要一台有限自动机，它能接受由 a 和 b 组成的第三个字符是 b 的任意字符串。此时很容易想出一个合适的 DFA 设计：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-152704.png" alt=""></p><p>如果想要一台机器能接受倒数第三个字符是 b 的字符串，怎么办呢？那将如何工作呢？似乎更加困难：上面的 DFA 能保证在读第三个字符的时候处于状态 3，但是一台机器无法预先知道什么时候能读到倒数第三个字符，因为在结束读取之前它不知道这个字符串有多长。甚至这样的一台 DFA 是否可能存在都不一定能立刻清楚。</p><p>但是，如果我们放松确定性的限制，并且允许规则手册对于一个状态和输入包含多条规则（或者根本没有规则） ，那么就可以设计一台能完成任务的机器：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-152925.png" alt=""></p><p>这是一台非确定性有限自动机（NFA） ，对每一个输入序列不再只有一条执行路径。处于状态 1 并且读入 b 的时候，它可能会按照一条规则仍保持在状态 1，但也可能会按照另一条规则进入状态 2。反过来，一旦进入状态 4，它找不到任何规则可以遵守，因此没法再继续读取输入。一台 DFA 的下一状态总是完全由它的当前状态和输入决定，但是一台NFA 在向下一个状态转移时会有多种可能性，而且有时候根本无法转移。</p><p>如果一台 DFA 读取一个字符串然后完全按照规则执行，并且最终终止于一个接受状态，那它就能接受这个字符串。那么对于一台 NFA 来说，什么才能表示一台 NFA 接受或者拒绝一个字符串呢？很自然的回答是，如果存在某条路径能让 NFA 按照它的某些规则执行并终止于一个接受状态，那它就能接受这个字符串 ; 这就是说，即使不是必然的，只要终止于一个接受状态是可能的就可以。</p><p>例如，这台 NFA 接受字符串 ‘baa’，因为从状态 1 开始，有一条路径可以让这台机器读取一个 b 转移到状态 2，再读取一个 a 转移到状态 3，最后读一个 a 终止于状态 4，这是一个接受态。它还接受字符串 ‘bbbbb’，因为 NFA 可以在读取前两个 b 的时候，按照另一条规则执行并停留在状态 1，然后在读第三个 b 的时候使用规则转移到状态 2，再读取字符串的其他部分，并向以前那样终止于状态 4。</p><p>另一方面，没有读取 ‘abb’ 并终止于状态 4 的方法（取决于遵照的不同规则，它最终只能终止于状态 1、2 或者 3） ，因此这台 NFA 不接受 ‘abb’。’bbabb’ 也不行，它最多只能到达状态 3：如果读入第一个 b 的时候直接转移到状态 2，它将很快终止于状态 4，这样留下两个字符没有处理但是已经没有规则可用了。</p><p>能被一台特定机器接受的字符串集合称为一种语言：我们说这台机器识别了这种语言。不是所有的语言都有一台 DFA 或者 NFA 能识别它们（详见第 4 章） ，但那些能被有限自动机识别的语言称为正则语言（regular language） 。</p><h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><p>在确定性计算机上模拟一台 NFA，关键是找到一种方法探索出这台机器所有可能的执行。<br>这种暴力方法把所有的可能全都摆出来，以此避免了只模拟一种可能执行时所需要的“幽灵般”的预见性。一台 NFA 读到一个字符的时候，它下一步转移到什么状态只会有有限数目的可能性，因此我们模拟非确定性时可以尝试遍历所有可能，然后看它们中哪个最终到达一个接受状态。</p><p>尝试遍历所有可能时可以采用递归的方式：每当所模拟的 NFA 读取一个字符并且有多个可用的规则时，遵照其中的一条规则，然后尝试读取输入的后续部分；如果这没有让机器到达一个可接受状态，就回退到早期状态，把输入也倒回早期的位置，然后按照另一个不同的规则再次尝试；如此重复，直到某次选择的规则让机器到达一个接受状态，或者所有可能的选择进行遍历的结果都不成功为止。</p><p>还有一个策略是采用并行的方式模拟所有可能：每当机器有超过一条规则可以遵守时就创建新线程，并把需要模拟的 NFA 复制过去以便复制的每一份都能尝试一条新规则，然后观察它的结果。所有这些线程都能同时执行，每个都从它自己的输入字符串副本中读取。<br>如果任何一个线程让机器读取了整个字符串，并且停止于一个接受状态，那么可以说这个字符串已经被接受了。</p><h2 id="自由移动"><a href="#自由移动" class="headerlink" title="自由移动"></a>自由移动</h2><p>很容易设计一台 DFA，能接受长度是 2 的倍数的、由字符 a 组成的字符串（’aa’、’aaaa’……） ：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153504.png" alt=""></p><p>但是如何设计一台机器，让它能接受长度是 2 或 3 的倍数的字符串呢？我们知道非确定性让一台机器可以走多于一条的执行路径，因此或许可以设计一台 NFA，它有一条“2 的倍数”的路径和一条“3 的倍数”的路径。一个初步的尝试可能看起来像这个样子：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153536.png" alt=""></p><p>这台 NFA 的思想是，在状态 1 和状态 2 之间移动以接受像 ‘aa’ 和 ‘aaaa’ 这样的字符串，在状态 1、状态 3 和状态 4 之间移动以接受像 ‘aaa’ 和 ‘aaaaaaaaa’ 这样的字符串。这工作得很好，但问题是这台机器还会接受字符串 ‘aaaaa’，因为它可以从状态 1 转移到状态 2 然后读完前两个字符的时候回到状态 1，再在状态 3 和状态 4 之间转移，之后在读完接下来的三个字符之后回到状态 1，终止于一个接受状态，即使这个字符串的长度不是 2 或者3 的倍数。</p><p>这次，一台 NFA 是否能完成这个工作还不是很明显，但是我们可以引入一个叫作自由移动的机器特性来解决此问题。这些规则让机器无需读取任何输入就能自发遵照执行，并且它们在这儿提供帮助是因为能让 NFA 在两组状态之间做一个初步选择：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-27-153623.png" alt=""></p><p>自由移动表示成从状态 1 到状态 2 和状态 4 的无标记虚线箭头。机器仍然接受字符串’aaaa’，它会先自发地转移到状态 2，然后随着读取输入在状态 2 和状态 3 之间转移。类似地，如果它开始先自由移动到状态 4 也能接受 ‘aaaaaaaaa’。但是现在它没法接受字符串 ‘aaaaa’ 了：不管做任何可能的执行，它都一定要从到状态 2 或者状态 4 的转移开始，而且一旦选择了其中一条路径转移之后，就没法退回来了。一旦处于状态 2，就只能接受一个长度是 2 的倍数的字符串，同样一旦处于状态 4，就只能接受长度是 3 的倍数的字 符串。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>非确定性和自由移动增强了有限自动机的表达能力。</p><p>有限自动机完全适合这个工作。就像我们即将看到的，把任何正则表达式转成一个等价的 NFA 是可能的——每一个与正则表达式匹配的字符串都能被这台 NFA 接受，反过来也一样——把字符串输入给一台模拟的 NFA 看它是否能被接受，从而判断字符串是否与正则表达式匹配。用第 2 章的话说，我们可以把这个看成是为正则表达式提供了一种指称语义：我们不一定知道如何直接执行一个正则表达式，但是可以展示如何把它表示成一台NFA，并且因为有了 NFA 的操作语义（ “通过读取字符然后执行规则改变状态” ） ，所以可以执行这个指称（denotation）实现同样的结果。</p><h2 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h2><p>把任何非确定性有限自动机转成接受完全相同字符串的确定性自动机是可能的。</p><p>非确定性和自由移动只是一台 DFA 已经能做的工作的再包装，就像编程语言里中的语法糖一样，它们不是让我们超越确定性约束的新能力。</p><p>理论上说，为一台简单的机器增加更多的特性却没有为它根本上增加更多的能力非常有趣，但实际上这是很有用的，因为一台 DFA 比一台 NFA 更容易模拟：只有一个当前状态要跟踪，并且一台 DFA 用硬件或者机器代码实现起来足够简单，可以使用程序存储位置作为状态，用条件分支作为规则。这意味着一个正则表达式的实现可以把一个模式先转换成一台 NFA 然后再转换成一台 DFA，得到一台能被快速高效模拟的非常简单的机器。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
            <tag> NFA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，深入剖析程序和计算机 - 确定性有限自动机（Deterministic Finite Automaton，DFA）</title>
      <link href="/2018/12/24/reading-plan-01-03/"/>
      <url>/2018/12/24/reading-plan-01-03/</url>
      <content type="html"><![CDATA[<p>现实中，计算机通常都有大量的易失存储器（RAM）和非多核易失存储器（硬盘或者SSD） ，有许多输入输出设备，还有能同时执行多个指令的处理器。有限状态机（finite state machine） ，也叫有限自动机（finite automaton） ，是一台计算机的极简模型，为了容易理解、推导并且容易用硬件或软件实现，它放弃了上面所有的这些特性。<br><a id="more"></a></p><h2 id="状态、规则和输入"><a href="#状态、规则和输入" class="headerlink" title="状态、规则和输入"></a>状态、规则和输入</h2><p>下面是一台有限自动机的结构图：</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-24-142901.png" alt=""></p><p>两个圆代表自动机的两个状态 1 和 2。凭空出现的箭头表明这台自动机从状态 1 开始，1 是它的起始状态。两个状态之间的箭头代表机器的规则：</p><ul><li>处于状态 1 并且读入字符 a 时，切换到状态 2；</li><li>处于状态 2 并且读入字符 a 时，切换到状态 1。</li></ul><p>这让我们有足够的信息研究机器如何处理一个输入流。</p><ul><li>这台机器从状态 1 开始。</li><li>这台机器只有从输入流读入字符a 的规则，因此这是唯一能发生的事情。读取到 a 的时候，它会从状态 1 切换到状态 2。</li><li>当这台机器又读取到了一个 a 时，它会切换回状态 1。</li></ul><p>一旦回到状态 1，它又将开始重复自身，这就是这台机器的行为范围。我们可以认为当前状态的信息存在于机器内部, 它像一个“黑盒”一样运转，并不会展现其内部工作状况——这台无聊的机器毫无用处，没有任何能观察到的输出。即使这台机器一直在状态 1 和状态 2 之间切换，机器之外也没有一个人能看出来有什么事情在发生。因此在这种情况下，我们可能还要增加一个状态，这样就不用再为任何内部结构操心了。</p><p><em>备注</em>：每台有限自动机没有通用的 CPU 执行任意程序，而是硬编码了一些规则集合，以决定在相应的输入下如何从一个状态切换到另一个状态。自动机先从一个特定的状态开始，然后从输入流中读入字符——按照规则它每次读取一个字符，有限自动机没有键盘、鼠标和接收输入的网络接口，只有一个外部的字符输入流可以一次读取一个字符。</p><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>只是把一些状态标记成特别状态，并且认为机器的单比特输出提供了当前是否处于特别状态的信息。对于这台机器，我们将状态 2 作为特别状态，并在图中用双重的圆形表示它。</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-24-143328.png" alt=""></p><p>这些特定状态通常称为接受状态，表明这台机器对某个输入序列是接受还是拒绝。如果这台自动机从状态 1 开始并读入一个 a，它将会停留在状态 2，这是一个接受状态，因此我们可以说这台机器接受字符串 ‘a’。另外，如果它先读到一个 a，然后又读取了另一个 a，它将终止于状态 1，这不是一个接受状态，所以这台机器拒绝字符串 ‘aa’。事实上很容易看到，这台机器接受任何奇数个数的 a 组成的字符串：’a’、’aaa’、’aaaaa’ 都能被接受，但是 ‘aa’、’aaaa’ 和 ‘’（空字符串）会被拒绝。</p><h2 id="确定性"><a href="#确定性" class="headerlink" title="确定性"></a>确定性</h2><p>很明显，这种自动机具有确定性：不管它当前处于什么状态，并且不管读入什么字符，最终所处的状态总是完全确定的。只要满足下面两个约束，就能保证这种确定性。</p><ul><li><p>没有冲突<br>不存在这样的状态： 它的下一次转换状态因为有彼此冲突的规则而有二义性。<br>（这意味着一个状态对于同样的输入，不能有多个规则。 ）</p></li><li><p>没有遗漏　<br>不存在这样的状态：它的下一次转换状态因为缺失规则而未知。 （这意味着每个状态都必须针对每个可能的输入字符有至少一个规则。 ）</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，如果遵循上述约定，这就是一台确定性有限自动机（DFA）。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，计算机的本质：深入剖析程序和计算机 - 程序的含义</title>
      <link href="/2018/12/20/reading-plan-01-02/"/>
      <url>/2018/12/20/reading-plan-01-02/</url>
      <content type="html"><![CDATA[<p>100 天计划第一期，决定读一些经典的技术类书籍。作为 IT 从业者，虽然是科班出身，但是基础知识结构仍然有很多需要夯实。</p><p>《计算机的本质：深入剖析程序和计算机》这本书涵盖了计算理论和编程语言设计，阐释了形式语义、自动机理论，以及通过 lambda 演算进行函数式编程等计算问题，可以帮助更好的理解计算机科学和计算原理。</p><a id="more"></a><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-19-132932.png" alt="drawing" width="250"></p><p>本文主要是阅读过程中的一些摘录和整理。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>传统的计算机程序是长长的字符串。每一种编程语言都有一系列规则，描述在那种语言中什么样的字符串被认为是有效程序。这些规则定义了这种语言的语法。</p><p>语法关心的只是程序的表面是什么样的，而不是它的含义。程序有可能语法正确但没有任何实际意义。例如，程序 y = x + 1 本身可能没有任何意义，因为并没有事先说明 x 是什么，而程序 z = true + 1 可能会在运行时候报错，因为它试图在一个布尔型值上加数字。<br>（当然，这依赖于具体编程语言的其他属性。 ）</p><h2 id="操作语义"><a href="#操作语义" class="headerlink" title="操作语义"></a>操作语义</h2><p>操作语义学（operational semantic）的基础，这种方法为程序在某种机器上的执行定义一些规则，以此来捕捉编程语言的含义。这个机器常常是一种抽象的机器：为了解释这种语言所写的程序如何执行而设计出来的一个想象的、理想化的计算机。为了更好地捕获编程语言的运行时行为，通常需要针对不同种类的编程语言设计不同的抽象机器。</p><h3 id="小步语义"><a href="#小步语义" class="headerlink" title="小步语义"></a>小步语义</h3><p>假想一台机器，用这台机器直接按照这种语言的语法进行操作一小步一小步地对其进行反复规约，从而对一个程序求值。不管最后得到的结果含义是什么，我们每一步都能让程序更接近最终结果。</p><p>这种小步规约类似于对代数式求值的方式。</p><p>例如，为了对 (1×2) + (3×4) 求值，我们知道应该：(1) 执行左侧的乘法（1×2 变成了 2） ，这样表达式就规约成了 2 + (3×4)；(2) 执行右侧的乘法（3×4 变成了 12） ，这样表达式规约成了 2 + 12；(3) 执行加法（2 + 12 变成了 14） ，最终得到 14。</p><h3 id="大步语义"><a href="#大步语义" class="headerlink" title="大步语义"></a>大步语义</h3><p>大步语义的思想是，定义如何从一个表达式或者语句直接得到它的结果。这必然需要把程序的执行当成一个递归的而不是迭代的过程：大步语义说的是，为了对一个更大的表达式求值，我们要对所有比它小的子表达式求值，然后把结果结合起来得到最终答案。</p><p>大步语义经常会写成更为松散的形式，只会说哪些子计算会执行，而不会指明它们按什么顺序执行。</p><h2 id="指称语义"><a href="#指称语义" class="headerlink" title="指称语义"></a>指称语义</h2><p>指称语义（denotational semantic）关心从程序本来的语言到其他表示的转换。</p><p>指称语义确实是一种比操作语义更抽象的方法，因为它只是用一种语言替换另一种语言，而不是把一种语言转换成真实的行为。</p><h2 id="形式化语义"><a href="#形式化语义" class="headerlink" title="形式化语义"></a>形式化语义</h2><p>形式化的语义通常都是由数学化的工具完成的。</p><p>形式化语义的一个重要应用是为一种编程语言的含义给出一个无歧义的定义，而不是让其依赖于像自然语言规范文档和“由实现规范”这样更加随意的方法。形式化的定义还有其他用途，例如证明某种语言通常情况下的特性，以及特定程序在特定情况下的特性，证明语言中程序之间的等价性，研究如何在不改变程序行为的情况下安全地变换程序而使其效率更高。</p><p>例如，既然操作语义与解释器的实现极为接近，那么计算机科学家就可以把一个适当的解释器看成一种语言的操作语义，然后证明它在那种语言的指称语义方面的正确性——这意味着证明了由解释器给出的含义和由指称语义给出的含义之间存在着明显的联系。</p><p>指称语义的一个优点是比操作语义抽象层次更高，它忽略了程序如何执行的细节，而只关心如何把它转换成一个不同的表示。例如，如果存在一种指称语义可以把两种语言翻译成某种共通的表示，就使对不同语言写成的两个程序进行比较成为可能。</p><p>抽象程度会使指称语义看起来有点兜圈子。如果问题是如何解释一种程序设计语言的含义，那么把一种语言翻译成另一种语言是如何让我们更接近问题答案的呢？一个指称只不过与它的含义一样好；尤其是，如果指称的语言有某种操作性的含义，那么一个指称语义只是让我们更接近于能实际执行一个程序，这个语言的语义本身展示了它是如何执行的，而不是如何翻译成另一种语言的。</p><p>形式化的指称语义使用抽象的数学对象（通常是函数）来表示表达式和语句这样的编程语言结构，并且因为数学上的约定会规定如何对函数求值这样的事情，这就有了一种直接在操作意义上思考指称的方式。我们已经使用了不太正式的方式，把指称语义看成是一种语言到另一种语言的编译器，而事实上这是多数编程语言最终得以执行的方式：一个 Java 程序将会由 javac 编译成字节码，字节码将会被 java 的虚拟机即时编译成 x86 的指令，然后一个 CPU 会把每一条 x86 指令解码成类 RISC（精简指令集）的微指令放到一个核上去执行</p><h2 id="treetop"><a href="#treetop" class="headerlink" title="treetop"></a>treetop</h2><p><a href="https://github.com/nathansobo/treetop" target="_blank" rel="noopener">treetop</a> 是本书中推荐的一个 ruby 的语法解释器。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>偷偷的放一下本书的资源吧，<a href="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/pdf/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90%E7%A8%8B%E5%BA%8F%E5%92%8C%E8%AE%A1%E7%AE%97%E6%9C%BA.pdf" target="_blank" rel="noopener">点我下载</a>, 侵权删。</p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>100 天阅读计划，第一期</title>
      <link href="/2018/12/19/reading-plan-01-01/"/>
      <url>/2018/12/19/reading-plan-01-01/</url>
      <content type="html"><![CDATA[<p>100 天阅读计划，第一期。</p><a id="more"></a><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><p>起止时间：2018.12.19 ~ 2019.3.29</p><h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><ol start="0"><li>背景：独学而无友(你多久没阅读了?)。</li><li>目标：每天分享学到的一个知识点。</li><li>内容：不做限制，可以装逼，但要经得起灵魂拷问</li><li>依据：布鲁姆认知领域六层次目标理论。</li><li>实操：六层次目标理论实际操作可以简化为对知识的理解，应用和分享，而分享才代表你真正掌握。</li><li>规则：免押入群，不能超过连续三天不打卡的情况（特殊情况群里报备），违规收取 100 RMB 罚款。每次分享形式不做限定，推荐形式为博客，笔记截图，或者干脆来一次在线分享。</li><li>周期：100 天。期满，罚款汇总作为团建基金。到时候会有不限形式的总结，分享或者轰趴等活动。</li></ol><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><h3 id="如何理解布鲁姆认知领域六层次目标理论？"><a href="#如何理解布鲁姆认知领域六层次目标理论？" class="headerlink" title="如何理解布鲁姆认知领域六层次目标理论？"></a>如何理解布鲁姆认知领域六层次目标理论？</h3><p>具体定义请看百科。这里给出自己的理解，该理论简化而言就是认知过程过程可分为三大层级，或者是三个步骤，逐级加深。</p><p>首先是通过阅读一手，或者 N 手材料，消化并且理解了某个知识点，举例而言，通过 Python 官方文档学会了基本语法，该阶段的特点是吸收的快，忘掉的也快，这个跟理解的深度有关系，对事物理解的越透彻，越是能看清本质，比较容易加深印象，不容易忘记。</p><p>第二阶段，能运用，关键是动手实践，所谓知行合一，比如学会了 Python 的语法，理解了该语言编程范式，可以用它来做一些项目，中间必然会遇到一些问题，可能会反复查阅文档，解决，如此往复可能需要一段时间才能熟练运用。</p><p>第三阶段，分享。经过动手实践，仅仅能代表自己掌握了该知识点并作为自己的一项技能来熟练运用，而大多数人往往止步于此。同时，分享是更高层级的认知活动。举例，有人邀请你做一场关于 Python 的分享活动，那么你自然会站在更高的层级来看待这个问题，比如你会有自己的评判（Python 是不是世界上最好的编程原因），一些奇淫技巧，或者是某些最佳实践，这些都可以认为是在实践过程中，对之前掌握的知识点的一个提炼。分享的同时也是在创造价值。</p><h3 id="为什么是-100-天？"><a href="#为什么是-100-天？" class="headerlink" title="为什么是 100 天？"></a>为什么是 100 天？</h3><p>一般而言，掌握一项技能，大概需要 3 个月。中间可能会有不可抗拒的外力，多出来的 10 天作为 Buffer。</p><h3 id="为什么要分享？"><a href="#为什么要分享？" class="headerlink" title="为什么要分享？"></a>为什么要分享？</h3><p>分享是更高层级的认知活动。如果一个毫无经验的人可以从你的分享中受益，首先你必须真正掌握了改知识点以及相关外围知识，其次你的表达能力也会得到锻炼。而表达，很重要！（有多少人，自认为自己很熟悉某个知识，但无法表达出来！！！）。</p><h3 id="分享的内容"><a href="#分享的内容" class="headerlink" title="分享的内容"></a>分享的内容</h3><p>每个人都不一样。阅读和分享的内容固然重要，但是学习知识的过程可能更重要。授人以鱼不如授人以渔。希望这 100 天不仅可以让自己真正学会某些东西，也能让自己的学习能力得到锻炼，争取成为一个高效的学习者。</p><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>可能坚持 10 天，20 天，拍脑袋想，没那么难，但是 100 天绝对是一个巨大的挑战，不要盲目自信，拭目以待吧。</p><h2 id="想加入吗？"><a href="#想加入吗？" class="headerlink" title="想加入吗？"></a>想加入吗？</h2><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-12-19-141820.png" alt="drawing" width="250"></p>]]></content>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
            <tag> 阅读 </tag>
            
            <tag> 100 天 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>obfuscator (OLLVM）</title>
      <link href="/2018/11/12/ollvm/"/>
      <url>/2018/11/12/ollvm/</url>
      <content type="html"><![CDATA[<p>OLLVM（Obfuscator-LLVM）是瑞士西北应用科技大学安全实验室于2010年6月份发起的一个项目，该项目旨在提供一套开源的针对LLVM的代码混淆工具，以增加对逆向工程的难度。后期转向商业项目strong.protect。目前，OLLVM已经支持LLVM-4.0版本。</p><p>本文主要记录了 OLLVM 的编译，使用流程。</p><a id="more"></a><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank" rel="noopener">obfuscator</a> 在 2010年由 HEIG-VD 发起，为 LLVM 提供了代码混淆编译组件。Obfuscator 作用在 LLVM 的 IR 层，因此，它和其他所有可经由 LLVM 编译的语言都兼容，比如 C，C++, OC, Ada 等，并且也支持所有的平台（x86, x86-64, PowerPC, PowerPC-64, ARM, Thumb, SPARC, Alpha, CellSPU, MIPS, MSP430, SystemZ, and XCore）。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p><a href="https://github.com/obfuscator-llvm/obfuscator" target="_blank" rel="noopener">obfuscator</a> 有多个分支，我们选 llvm-4.0, 它基于 LLVM 官方版本 4.0.1。</p><p>编译 obfuscator 需要安装 CMake，克隆代码需要 git， 读者自行补齐。</p><p>只需要执行如下系列命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git</span><br><span class="line">$ cd obfuscator</span><br><span class="line">$ mkdir build</span><br><span class="line">$ cd build</span><br><span class="line">$ cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">$ make -j7</span><br></pre></td></tr></table></figure></p><p>大概需要个个把小时，就会有结果。编译结果的二进制文件在 obfuscator/build/bin 目录下，比如 clang 命令。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>假设我们有源文件 cff.c, 路径位于相对于源码根目录 ./obfuscator 下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main(int argc, char** argv) &#123;</span><br><span class="line">  int a = 0;</span><br><span class="line">  if(a == 0)</span><br><span class="line">    return 1;</span><br><span class="line">  else</span><br><span class="line">    return 10;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们先用系统自带的 clang 编译，产生结果文件（在 cff.c 源码路径）:<br><code>$ clang cff.c -o original</code></p><p>然后我们使用自己编译的 clang +  ‘Control Flow Flattening’ 模式混淆。</p><p>在编译结果 bin 路径执行如下命令：<br><code>./clang-4.0 ../../obfuscator/cff.c -o ../../obfuscator/obs -mllvm -fla</code></p><p>然后我们用 Hopper 分别打开 original 和 obs 两个对象文件:</p><p><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-124222.jpg" alt=""></p><p>对比发现，经过 cfa 混淆后，原本程序的控制流被打破，增加了阅读门槛。</p><h2 id="几种混淆模式"><a href="#几种混淆模式" class="headerlink" title="几种混淆模式"></a>几种混淆模式</h2><h3 id="指令替换模式（Instructions-Substitution）"><a href="#指令替换模式（Instructions-Substitution）" class="headerlink" title="指令替换模式（Instructions Substitution）"></a>指令替换模式（Instructions Substitution）</h3><p>本质上指令替换就是用等价的更加复杂的指令替换原本可读性更好的指令。比如，加减以及布尔指令。</p><p>编译时，使用 -mllvm -sub 参数即可。</p><h3 id="控制流平展模式（Control-Flow-Flattening）"><a href="#控制流平展模式（Control-Flow-Flattening）" class="headerlink" title="控制流平展模式（Control Flow Flattening）"></a>控制流平展模式（Control Flow Flattening）</h3><p>该模式改变原本程序的控制流。<br>例如在 _使用_ 示例，原本程序的控制流如下：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-124942.jpg" alt=""></p><p>经过控制流平展后，控制流变成：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/static/2018-11-12-125100.jpg" alt=""></p><p>编译时使用 -mllvm -fla 参数。</p><h3 id="控制流伪造模式-（Bogus-Control-Flow）"><a href="#控制流伪造模式-（Bogus-Control-Flow）" class="headerlink" title="控制流伪造模式 （Bogus Control Flow）"></a>控制流伪造模式 （Bogus Control Flow）</h3><p>也是对程序的控制流做操作，不同的是，BCF模式会在原代码块的前后随机插入新的代码块，新插入的代码块不是确定的，然后新代码块再通过条件判断跳转到原代码块中。更要命地是，原代码块可能会被克隆并插入随机的垃圾指令。</p><p>编译时加 -mllvm -bcf 参数即可。</p><h3 id="字符串混淆"><a href="#字符串混淆" class="headerlink" title="字符串混淆"></a>字符串混淆</h3><p>注意该模式 obfuscator 没有实现，这里只是提及一下，也是一种常见的混淆模式。混淆后的字符串没办法直接搜索到，变成一系列操作后的合成产物，提高了反编译成本。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>有的时候，由于效率或其他原因的考虑，我们只想给指定的函数混淆或不混淆该函数，OLLVM也提供了对这一特性的支持，你只需要给对应的函数添加attributes即可。比如，想对函数foo()使用fla混淆，只需要给函数foo()增加fla属性即可。</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int foo() __attribute((__annotate__((&quot;fla&quot;))));</span><br><span class="line">int foo() &#123;</span><br><span class="line">   return 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><p><a href="https://www.jianshu.com/p/a631b5584de6" target="_blank" rel="noopener">https://www.jianshu.com/p/a631b5584de6</a></p></li><li><p><a href="https://github.com/obfuscator-llvm/obfuscator/wiki/Functions-annotations" target="_blank" rel="noopener">https://github.com/obfuscator-llvm/obfuscator/wiki/Functions-annotations</a></p></li></ol>]]></content>
      
      
        <tags>
            
            <tag> LLVM </tag>
            
            <tag> obfuscator </tag>
            
            <tag> 混淆 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>曲线救国之修复腾讯 X5 内核文件上传的兼容性问题</title>
      <link href="/2018/09/11/Fix-TBS-magic-bug/"/>
      <url>/2018/09/11/Fix-TBS-magic-bug/</url>
      <content type="html"><![CDATA[<p>来说说可恶的腾讯 X5 内核，记录下今天问题的排查，定位，和修复过程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Android 项目中的 WebView 集成了腾讯的 X5 内核，由于 X5 在展示方面的兼容性问题深受前端们的喜爱（我能说，他们的 H5 页面的样式兼容问题，全部推锅到移动开发吗, 除了最新版本的 Chrome 内核，是否可以考虑下别的浏览器…）。</p><p>然而，就在今天，一个不幸的上午，捕获到了如下异常：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">UncaughtException detected: android.os.FileUriExposedException: file:///storage/emulated/0/DCIM/Camera/1536649175379.jpg exposed beyond app through ClipData.Item.getUri()</span><br><span class="line">       at android.os.StrictMode.onFileUriExposed(StrictMode.java:1958)</span><br><span class="line">       at android.net.Uri.checkFileUriExposed(Uri.java:2356)</span><br><span class="line">       at android.content.ClipData.prepareToLeaveProcess(ClipData.java:941)</span><br><span class="line">       at android.content.Intent.prepareToLeaveProcess(Intent.java:9747)</span><br><span class="line">       at android.content.Intent.prepareToLeaveProcess(Intent.java:9732)</span><br><span class="line">       at android.app.Instrumentation.execStartActivity(Instrumentation.java:1611)</span><br><span class="line">       at android.app.Activity.startActivityForResult(Activity.java:4536)</span><br><span class="line">       at android.support.v4.app.BaseFragmentActivityApi16.startActivityForResult(BaseFragmentActivityApi16.java:54)</span><br><span class="line">       at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:65)</span><br><span class="line">       at android.app.Activity.startActivityForResult(Activity.java:4494)</span><br><span class="line">       at android.support.v4.app.FragmentActivity.startActivityForResult(FragmentActivity.java:711)</span><br><span class="line">       at android.app.Activity.startActivity(Activity.java:4855)</span><br><span class="line">       at android.app.Activity.startActivity(Activity.java:4823)</span><br><span class="line">       at android.content.ContextWrapper.startActivity(ContextWrapper.java:376)</span><br><span class="line">       at org.chromium.android_webview.ResourcesContextWrapperFactory$WebViewContextWrapper.startActivity(Unknown Source:11)</span><br><span class="line">       at com.tencent.tbs.core.partner.b.a$2.onClick(Unknown Source:406)</span><br><span class="line">       at android.view.View.performClick(View.java:6266)</span><br><span class="line">       at android.view.View$PerformClick.run(View.java:24730)</span><br><span class="line">       at android.os.Handler.handleCallback(Handler.java:789)</span><br><span class="line">       at android.os.Handler.dispatchMessage(Handler.java:98)</span><br><span class="line">       at android.os.Looper.loop(Looper.java:171)</span><br><span class="line">       at android.app.ActivityThread.main(ActivityThread.java:6672)</span><br><span class="line">       at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">       at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:246)</span><br><span class="line">       at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:783)</span><br></pre></td></tr></table></figure><h2 id="一回头"><a href="#一回头" class="headerlink" title="一回头"></a>一回头</h2><p>幸运的是找到了出现问题的调用： <code>&lt;input type=&quot;file&quot; acctType=&quot;image/*&quot;/&gt;</code>。</p><p>上述标签，最终会调用到 WebChromeClient 的 <code>onShowFileChooser</code> 方法（不同 Android 版本有所差异，&gt;= 5.0 是此方法），然而，经过测试，这次崩溃并没有调用到此处（一脸懵逼)。</p><p>乍一看是跨 APP 文件共享导致的问题，恰好最近项目刚把 <code>targetSdkVersion</code> 从 22 升级到 26，也就是必须要兼容 Android 6.0 的动态权限以及 7.0 的跨应用文件共享。</p><p>但是，仔细分析堆栈信息，没有发现项目主动调用的代码，可疑点锁定到这一行 <code>at com.tencent.tbs.core.partner.b.a$2.onClick(Unknown Source:406)</code>。但是下载下来的<br>腾讯内核 jar 文件中并没有包含 <code>com.tencent.tbs.core.partner.**</code>，由于 X5 内核只提供了轻量级的 jar 文件，实际内核的下载和更新是 APP 安装后动态进行的，于是乎去了<br> <code>/data/data/{packageUd}/app_tbs</code>, 并且把所有文件都导到电脑上，里面主要包含了包含资源文件的 apk, .so 文件以及一个 dex 文件，经过 dex2jar 这些操作后，仍然没有找到可疑的类文件。</p><h2 id="二回头"><a href="#二回头" class="headerlink" title="二回头"></a>二回头</h2><p>上一条路被堵死。<br>很幸运，恰好今天帮测试解决 <code>UI Automator</code> 的问题，顺道也用了一下, 获得如下布局：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/onm05.jpg" alt=""></p><p>emmm, 出问题的关键就是点击拍照，项目中没有主动显示这种样式的弹窗，因此可能是系统做了拦截处理，或者就是 X5。</p><p>换了几台不同厂商的测试机实验，样式都是一样，基本排除是系统拦截处理的锅。最可疑的就是 X5 了。</p><p><em>中午还去了浜烧市场吃了顿饭，心好大….</em></p><h2 id="三回头"><a href="#三回头" class="headerlink" title="三回头"></a>三回头</h2><p>基本锁定问题后，就开始各种预先申请权限，StrictMode 上折腾，试图解决权限问题，无果。</p><p>但每次 APP 崩溃几次后，再次调用，发现又会调用到 WebChromeClient 的 <code>onShowFileChooser</code> 方法，由于我们自己做过权限处理，一切又恢复正常。<br>(后来发现是 X5 发现崩溃后，降级逻辑)。</p><h2 id="四回头"><a href="#四回头" class="headerlink" title="四回头"></a>四回头</h2><p>测试发现，出问题的点只是拍照这一个地方，可恶的腾讯 X5 内核并没有做兼容 7.0 的逻辑处理，并且恶意拦截 input file 标签，美美的弹出自己的文件选择框。<br>兼容都没有做好，有碧莲弹窗。。。。佩服！！！</p><h2 id="五回头"><a href="#五回头" class="headerlink" title="五回头"></a>五回头</h2><p>不知怎么滴灵光一现，就想如果我们去掉拍照这个按钮，问题不就解决了吗？分析布局，目测是 X5 在 WebView 后面动态 add 了一个 <code>android.widget.LinearLayout</code>, 别问我怎么知道的…</p><p>于是乎诞生了如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">项目中 WebView.java</span><br><span class="line"></span><br><span class="line">    LinearLayout fuckTbsLayout;</span><br><span class="line">    List&lt;TextView&gt; fuckTextViews;</span><br><span class="line">    @Override</span><br><span class="line">    public void onViewAdded(View child) &#123;</span><br><span class="line">        if (child.getClass().getName().startsWith(&quot;com.tencent.tbs.&quot;)</span><br><span class="line">                &amp;&amp;</span><br><span class="line">                child instanceof LinearLayout</span><br><span class="line">                &amp;&amp;</span><br><span class="line">                ((LinearLayout) child).getChildCount() &gt; 0</span><br><span class="line">                ) &#123;</span><br><span class="line">            fuckTbsLayout = (LinearLayout) child;</span><br><span class="line">            TextView fuckItem;</span><br><span class="line">            if (fuckTbsLayout.getChildAt(0) instanceof TextView) &#123;</span><br><span class="line">                fuckItem = (TextView) fuckTbsLayout.getChildAt(0);</span><br><span class="line">                String fuckTitle = fuckItem.getText().toString();</span><br><span class="line">                if (fuckTitle.contains(&quot;请选择上传方式&quot;) || fuckTitle.contains(&quot;相册&quot;) || fuckTitle.contains(&quot;拍照&quot;) || fuckTitle.contains(&quot;其它方式&quot;)) &#123;</span><br><span class="line">                    fuckTextViews = new ArrayList&lt;&gt;();</span><br><span class="line">                    for (int i = 0; i &lt; fuckTbsLayout.getChildCount(); i++) &#123;</span><br><span class="line">                        TextView fuckTextView = null;</span><br><span class="line">                        if (fuckTbsLayout.getChildAt(i) instanceof TextView) &#123;</span><br><span class="line">                            fuckTextView = (TextView) fuckTbsLayout.getChildAt(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (fuckTextView != null &amp;&amp; fuckTextView.getText().toString().trim().contains(&quot;拍照&quot;)) &#123;</span><br><span class="line">                            fuckTextViews.add(fuckTextView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (fuckTextViews != null &amp;&amp; fuckTextViews.size() &gt; 0) &#123;</span><br><span class="line">                        for (TextView todoRemoveFuckTextView : fuckTextViews) &#123;</span><br><span class="line">                            fuckTbsLayout.removeView(todoRemoveFuckTextView);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    fuckTextViews = null;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        super.onViewAdded(child);</span><br><span class="line">    &#125;</span><br><span class="line">//sorry for the F words.</span><br></pre></td></tr></table></figure><p>主要思想就是在 WebView 的 onViewAdded 方法中做手脚，此方法是作甚的呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Called when a new child is added to this ViewGroup. Overrides should always</span><br><span class="line"> * call super.onViewAdded.</span><br><span class="line"> *</span><br><span class="line"> * @param child the added child view</span><br><span class="line"> */</span><br><span class="line">public void onViewAdded(View child) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非常通俗易懂，当 X5 偷偷的去动态 addView 的时候，所在的父组件此方法必定会被调用，只要过滤一下，记录下来拍照的所属的 View，然后从父组件上调用  removeView 移除掉就好了。</p><h2 id="再回头脖子就要断了"><a href="#再回头脖子就要断了" class="headerlink" title="再回头脖子就要断了"></a>再回头脖子就要断了</h2><p>上述问题，曲线救国得以解决。</p><h2 id="方案的缺点"><a href="#方案的缺点" class="headerlink" title="方案的缺点"></a>方案的缺点</h2><ul><li>脏</li><li>脏</li><li>脏</li><li>TextView 变化，文案变化，会再次失效</li></ul><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><ul><li><p>在问题排查以及解决过程中，腾讯的 X5 文档，以及论坛，QQ 群形同虚设，几乎没有什么有价值的线索，狂吐槽。</p></li><li><p>X5 估计自己都没有做兼容测试，就动态下发错误的逻辑代码，属实是狂傲。</p></li><li><p>X5 检测应用崩溃后，降级逻辑总算是有点良心，降低对用户的影响，但是我们的 crash 率飙升了…唉</p></li></ul>]]></content>
      
      
        <tags>
            
            <tag> TBS </tag>
            
            <tag> X5 </tag>
            
            <tag> 文件上传 </tag>
            
            <tag> 问题记录 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 20</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-20/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-20/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 20 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-20" target="_blank" rel="noopener">Github</a></p><h2 id="扑克牌洗牌模拟器"><a href="#扑克牌洗牌模拟器" class="headerlink" title="扑克牌洗牌模拟器"></a>扑克牌洗牌模拟器</h2><p>在之前的 19 篇博客中，我把实现编程语言的每一步都详细的记录下来了。如果不拿这门语言，练练手，做个东西玩，那就没什么意思了，对不？</p><p>我准备实现一个扑克牌的洗牌模拟器。思路是提供一定数量的玩家，指定每个玩家的扑克牌的数量。作为输出，每个玩家都能获得一定数量的随机扑克牌。</p><h3 id="Card-类"><a href="#Card-类" class="headerlink" title="Card 类"></a>Card 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Card &#123;</span><br><span class="line"></span><br><span class="line">    string color</span><br><span class="line">    string pattern</span><br><span class="line"></span><br><span class="line">    Card(string cardColor,string cardPattern) &#123;</span><br><span class="line">        color = cardColor</span><br><span class="line">        pattern = cardPattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getColor() &#123;</span><br><span class="line">        color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string getPattern() &#123;</span><br><span class="line">        pattern</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    string toString() &#123;</span><br><span class="line">        return &quot;&#123;&quot; + color + &quot;,&quot; + pattern + &quot;&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有黑科技，就是一个对象，并且是不可变的。</p><h3 id="CardDrawer-类"><a href="#CardDrawer-类" class="headerlink" title="CardDrawer 类"></a>CardDrawer 类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">CardDrawer &#123;</span><br><span class="line">    start &#123;</span><br><span class="line">        var cards = new List() //creates java.util.ArrayList </span><br><span class="line">        addNumberedCards(cards) //calling method with 3 arguments (last 2 are default)</span><br><span class="line">        addCardWithAllColors(&quot;Ace&quot;,cards) </span><br><span class="line">        addCardWithAllColors(&quot;Queen&quot;,cards)</span><br><span class="line">        addCardWithAllColors(&quot;King&quot;,cards)</span><br><span class="line">        addCardWithAllColors(&quot;Jack&quot;,cards)</span><br><span class="line">        //Calling with named arguments (and in differnet order)</span><br><span class="line">        //The last parameter (cardsPerPlayer) is ommited (it&apos;s default value is 5)</span><br><span class="line">        drawCardsForPlayers(playersAmount -&gt; 5,cardsList -&gt; cards) </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addNumberedCards(List cardsList,int first=2, int last=10) &#123;</span><br><span class="line">        for i from first to last &#123;  //loop from first to last (inclusive)</span><br><span class="line">            var numberString = new java.lang.Integer(i).toString()</span><br><span class="line">            addCardWithAllColors(numberString,cardsList)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addCardWithAllColors(string pattern,List cardsList) &#123;</span><br><span class="line">        cardsList.add(new Card(&quot;Clubs&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Diamonds&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Hearts&quot;,pattern))</span><br><span class="line">        cardsList.add(new Card(&quot;Spades&quot;,pattern))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    drawCardsForPlayers(List cardsList,int playersAmount = 3,int cardsPerPlayer = 5) &#123;</span><br><span class="line">        if(cardsList.size() &lt; (playersAmount * cardsPerPlayer)) &#123;</span><br><span class="line">            print &quot;ERROR - Not enough cards&quot; //No exceptions yet :)</span><br><span class="line">            return</span><br><span class="line">        &#125;</span><br><span class="line">        var random = new java.util.Random()</span><br><span class="line">        for i from 1 to playersAmount &#123;</span><br><span class="line">            var playernumberString = new java.lang.Integer(i).toString()</span><br><span class="line">            print &quot;player &quot; + playernumberString  + &quot; is drawing:&quot;</span><br><span class="line">            for j from 1 to cardsPerPlayer &#123;</span><br><span class="line">                var dawnCardIndex = random.nextInt(cardsList.size() - 1)</span><br><span class="line">                var drawedCard = cardsList.remove(dawnCardIndex)</span><br><span class="line">                print &quot;    drawed:&quot; + drawedCard</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>首先我们需要编译 Card 类。然后编译 CardDrawer 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar: com.kubadziworski.compiler.Compiler EnkelExamples/RealApp/Card.enk</span><br><span class="line">java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/RealApp/CardDrawer.enk</span><br><span class="line"></span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java CardDrawer </span><br><span class="line">player 1 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,Queen&#125;</span><br><span class="line">    drawed:&#123;Spades,7&#125;</span><br><span class="line">    drawed:&#123;Hearts,Jack&#125;</span><br><span class="line">    drawed:&#123;Spades,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,2&#125;</span><br><span class="line">player 2 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,Ace&#125;</span><br><span class="line">    drawed:&#123;Diamonds,Jack&#125;</span><br><span class="line">    drawed:&#123;Spades,Queen&#125;</span><br><span class="line">    drawed:&#123;Spades,King&#125;</span><br><span class="line">player 3 is drawing:</span><br><span class="line">    drawed:&#123;Diamonds,Ace&#125;</span><br><span class="line">    drawed:&#123;Clubs,2&#125;</span><br><span class="line">    drawed:&#123;Clubs,3&#125;</span><br><span class="line">    drawed:&#123;Spades,8&#125;</span><br><span class="line">    drawed:&#123;Clubs,7&#125;</span><br><span class="line">player 4 is drawing:</span><br><span class="line">    drawed:&#123;Spades,Ace&#125;</span><br><span class="line">    drawed:&#123;Diamonds,3&#125;</span><br><span class="line">    drawed:&#123;Clubs,4&#125;</span><br><span class="line">    drawed:&#123;Clubs,6&#125;</span><br><span class="line">    drawed:&#123;Diamonds,2&#125;</span><br><span class="line">player 5 is drawing:</span><br><span class="line">    drawed:&#123;Hearts,4&#125;</span><br><span class="line">    drawed:&#123;Hearts,Queen&#125;</span><br><span class="line">    drawed:&#123;Hearts,10&#125;</span><br><span class="line">    drawed:&#123;Clubs,Jack&#125;</span><br><span class="line">    drawed:&#123;Diamonds,8&#125;</span><br></pre></td></tr></table></figure><p>完美！</p><h2 id="再见，Enkel"><a href="#再见，Enkel" class="headerlink" title="再见，Enkel"></a>再见，Enkel</h2><p>为了实现 Enkel 和分享整个过程我花费了大量的精力。写代码是一回事，能够表达和分享是另一回事（能够让读者通俗易懂本身就是一个很大的挑战）。</p><p>在这个过程中我学习到了很多，也希望屏幕前面的你也能有所收获。</p><p>很不幸的是，这是系列中的最后一篇了，这个项目将继续下去，所以，保持关注吧！</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 19</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-19/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-19/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 19 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-19" target="_blank" rel="noopener">Github</a></p><p><img src="http://jakubdziworski.github.io/assets/media/enkel_19/equals.gif" alt=""></p><h2 id="Java-中的对象比较"><a href="#Java-中的对象比较" class="headerlink" title="Java 中的对象比较"></a>Java 中的对象比较</h2><p>对于 Java 初学者来说，对象比较或许是最让人头疼的事情了。</p><p>我们来看如下示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = 15;</span><br><span class="line">Integer b = 15;</span><br><span class="line">boolean areEqual = a == b;</span><br></pre></td></tr></table></figure><p>这里有个隐式的的类型装箱，Integer.valueOf(15) 会返回缓存的缓存的 Integer 对象，因为引用一样，所以 areEqual 是 true。</p><p>上面代码执行完后，Java 菜逼理所当然的想，我可以用 == 来比较对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nteger a = 155;</span><br><span class="line">Integer b = 155;</span><br><span class="line">boolean areEqual = a == b;</span><br></pre></td></tr></table></figure><p>areEqual 是 false, 这是因为 155 超过了缓存的阈值。</p><p>Strings 也有陷阱。比如通过 new 创建的对象获得一个新的引用，如果你通过双引号字符串给变量赋值，拿到的是一个缓存对象。</p><p>问题在于，在超过 99% 的情境下，我们比较的是对象是否相等，而不是引用是否相等。我希望 == 意味着相等，而 &lt;, &gt;, &lt;=, &gt;= 调用 compareTo。</p><p>我们一起来实现这个功能吧。</p><h2 id="条件表达式的字节码生成"><a href="#条件表达式的字节码生成" class="headerlink" title="条件表达式的字节码生成"></a>条件表达式的字节码生成</h2><p>在第十部分，条件表达式中，我们引入了比较原始类型的操作。这里我们引入 compareTo，只需要在生成字节码的部分修改就可以了。</p><p>基本思路是，判断值，如果是原始类型，调用 compareTo， 如果是引用，调用 equals。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">public class ConditionalExpressionGenerator &#123;</span><br><span class="line">     </span><br><span class="line">    //Constructor and fields</span><br><span class="line"></span><br><span class="line">    public void generate(ConditionalExpression conditionalExpression) &#123;</span><br><span class="line">        Expression leftExpression = conditionalExpression.getLeftExpression();</span><br><span class="line">        Expression rightExpression = conditionalExpression.getRightExpression();</span><br><span class="line">        CompareSign compareSign = conditionalExpression.getCompareSign();</span><br><span class="line">        if (conditionalExpression.isPrimitiveComparison()) &#123;</span><br><span class="line">            generatePrimitivesComparison(leftExpression, rightExpression, compareSign);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            generateObjectsComparison(leftExpression, rightExpression, compareSign);</span><br><span class="line">        &#125;</span><br><span class="line">        Label endLabel = new Label();</span><br><span class="line">        Label trueLabel = new Label();</span><br><span class="line">        methodVisitor.visitJumpInsn(compareSign.getOpcode(), trueLabel);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">        methodVisitor.visitJumpInsn(Opcodes.GOTO, endLabel);</span><br><span class="line">        methodVisitor.visitLabel(trueLabel);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ICONST_1);</span><br><span class="line">        methodVisitor.visitLabel(endLabel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generateObjectsComparison(Expression leftExpression, Expression rightExpression, CompareSign compareSign) &#123;</span><br><span class="line">        Parameter parameter = new Parameter(&quot;o&quot;, new ClassType(&quot;java.lang.Object&quot;), Optional.empty()); // #1 </span><br><span class="line">        List&lt;Parameter&gt; parameters = Collections.singletonList(parameter);</span><br><span class="line">        Argument argument = new Argument(rightExpression, Optional.empty());</span><br><span class="line">        List&lt;Argument&gt; arguments = Collections.singletonList(argument);</span><br><span class="line">        switch (compareSign) &#123; // #2</span><br><span class="line">            case EQUAL:</span><br><span class="line">            case NOT_EQUAL:</span><br><span class="line">                FunctionSignature equalsSignature = new FunctionSignature(&quot;equals&quot;, parameters, BultInType.BOOLEAN); // #3</span><br><span class="line">                FunctionCall equalsCall = new FunctionCall(equalsSignature, arguments, leftExpression);</span><br><span class="line">                equalsCall.accept(expressionGenerator); // #4</span><br><span class="line">                methodVisitor.visitInsn(Opcodes.ICONST_1); </span><br><span class="line">                methodVisitor.visitInsn(Opcodes.IXOR); // #5</span><br><span class="line">                break;</span><br><span class="line">            case LESS:</span><br><span class="line">            case GREATER:</span><br><span class="line">            case LESS_OR_EQUAL:</span><br><span class="line">            case GRATER_OR_EQAL:</span><br><span class="line">                FunctionSignature compareToSignature = new FunctionSignature(&quot;compareTo&quot;, parameters, BultInType.INT); // #6</span><br><span class="line">                FunctionCall compareToCall = new FunctionCall(compareToSignature, arguments, leftExpression);</span><br><span class="line">                compareToCall.accept(expressionGenerator);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void generatePrimitivesComparison(Expression leftExpression, Expression rightExpression, CompareSign compareSign) &#123;</span><br><span class="line">        leftExpression.accept(expressionGenerator);</span><br><span class="line">        rightExpression.accept(expressionGenerator);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ISUB); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要注意的是:</p><ul><li>1 Equals 方法在 Object 类中声明如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">        return (this == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此参数需要是 java.lang.Object 类型，没有默认值（Optional.empty）</p><ul><li>2 需要强制区分是否相等（== 或者 !=）, 或者比较操作符（&gt; &lt; &gt;= &lt;=）。我们可以使用 compareTo 但是并不是所有的类都实现了 Comparable 接口。</li><li>3 如前面所述，equals 方法的入参是 java.lang.Object 并且返回值是布尔值。</li><li>4 为 equals 方法调用生成字节码。具体参考 CallExpressionGenerator 类。</li><li>5 如果对象相等，equals 返回 true ，否则返回 false, 原始类型的对比通过相减的方式，如果结果是 0 意味着相等。为了让对象可比较，我用了XOR（异或）逻辑指令，compareTo 方法和原始类型非常像。如果相同返回 0</li><li>6 创建 compareTo 的调用。他接受 java.lang.Object 类型参数，但是返回 int 类型的值。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EqualitySyntax &#123;</span><br><span class="line"></span><br><span class="line"> start &#123;</span><br><span class="line">    var a = new java.lang.Integer(455)</span><br><span class="line">    var b = new java.lang.Integer(455)</span><br><span class="line">    print a == b</span><br><span class="line">    print a &gt; b</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成字节码反编译成 Java 如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class EqualitySyntax &#123;</span><br><span class="line">    public void start() &#123;</span><br><span class="line">        Integer var1 = new Integer(455);</span><br><span class="line">        Integer var2 = new Integer(455);</span><br><span class="line">        System.out.println(var1.equals(var2));</span><br><span class="line">        System.out.println(var1.compareTo(var2) &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        (new EqualitySyntax()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如你所见，== 被映射成 equals， &gt; 被映射成 compareTo 操作。</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 18</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-18/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-18/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 18 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-18" target="_blank" rel="noopener">Github</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>语法规则和 Java 非常类似，但是更加简单，没有复杂的修饰符（比如 static, volatile, transient）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fields &#123;</span><br><span class="line"></span><br><span class="line">    int field</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        field = 5</span><br><span class="line">        print field</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><p>在本篇之前我们只能在类中定义方法，现在我们开启定义字段的大门吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classBody :  field* function* ;</span><br><span class="line">field : type name;</span><br></pre></td></tr></table></figure><p>赋值语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assignment : name EQUALS expression;</span><br></pre></td></tr></table></figure><h3 id="为何这么久都没实现赋值语句"><a href="#为何这么久都没实现赋值语句" class="headerlink" title="为何这么久都没实现赋值语句"></a>为何这么久都没实现赋值语句</h3><p>字段用来赋值，但是这么久以来我们一直没有实现赋值语句来给声明的变量赋值，我这么做是因为有以下考量。</p><p>我希望变量是不可变的，赋值意味着改变状态，这会导致许多问题，比如同步，副作用，还有内存泄漏。</p><p>比如有如下的 Java 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Stuff trustMeIWontModifyYourArg(SomeObject arg) &#123;</span><br><span class="line">    ... 999 lines of code </span><br><span class="line">    arg = null; //or some other nasty hidden stuff</span><br><span class="line">    ...another 999 lines of code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法签名，我们可能理所当然的想，方法会修改参数吗，他没有 final 修饰，但是大多数 Java 程序员会忽略。仅仅通过名字判断出来方法不会修改变量，那我们就用他吧。</p><p>过了两个小时后，出现了 NullPointerException，方法还是修改了参数。</p><p>如果方法没有副作用，那么可以很方便的实现并发而不用担心同步的问题，这种方法没有状态，也没有副作用，实现避免副作用方法最简单的办法就是尽可能的使用常量。</p><h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><h3 id="声明字段"><a href="#声明字段" class="headerlink" title="声明字段"></a>声明字段</h3><p>使用 ASM 的 visitField 来声明字段。它添加字段到 fields[]，fields_count 会自动增加计数器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class FieldGenerator &#123;</span><br><span class="line"></span><br><span class="line">    private final ClassWriter classWriter;</span><br><span class="line"></span><br><span class="line">    public FieldGenerator(ClassWriter classWriter) &#123;</span><br><span class="line">        this.classWriter = classWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Field field) &#123;</span><br><span class="line">        String name = field.getName();</span><br><span class="line">        String descriptor = field.getType().getDescriptor();</span><br><span class="line">        FieldVisitor fieldVisitor = classWriter.visitField(Opcodes.ACC_PUBLIC, name,descriptor, null, null);</span><br><span class="line">        fieldVisitor.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取字段"><a href="#读取字段" class="headerlink" title="读取字段"></a>读取字段</h3><p>读取字段，你需要:</p><ul><li>字段名</li><li>字段类型修饰符</li><li>持有者的全限定名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ReferenceExpressionGenerator &#123;</span><br><span class="line"></span><br><span class="line">     //constructor and fields</span><br><span class="line"></span><br><span class="line">    public void generate(FieldReference fieldReference) &#123;</span><br><span class="line">        String varName = fieldReference.geName();</span><br><span class="line">        Type type = fieldReference.getType();</span><br><span class="line">        String ownerInternalName = fieldReference.getOwnerInternalName();</span><br><span class="line">        String descriptor = type.getDescriptor();</span><br><span class="line">        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, ownerInternalName,varName,descriptor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>ALOAD， 0  获得 this ，也就是局部变量索引值为 0 的值。在 非 static 语境中，this 默认都会在索引为 0 的位置。</li><li>GETFIELD 读取变量的指令</li></ul><h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AssignmentStatementGenerator &#123;</span><br><span class="line"></span><br><span class="line">    //constructor and fields</span><br><span class="line">    </span><br><span class="line">    public void generate(Assignment assignment) &#123;</span><br><span class="line">        String varName = assignment.getVarName();</span><br><span class="line">        Expression expression = assignment.getExpression();</span><br><span class="line">        Type type = expression.getType();</span><br><span class="line">        if(scope.isLocalVariableExists(varName)) &#123;</span><br><span class="line">            int index = scope.getLocalVariableIndex(varName);</span><br><span class="line">            methodVisitor.visitVarInsn(type.getStoreVariableOpcode(), index);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        Field field = scope.getField(varName);</span><br><span class="line">        String descriptor = field.getType().getDescriptor();</span><br><span class="line">        methodVisitor.visitVarInsn(Opcodes.ALOAD,0);</span><br><span class="line">        expression.accept(expressionGenerator);</span><br><span class="line">        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD,field.getOwnerInternalName(),field.getName(),descriptor);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果局部变量和字段名字冲突了，那么局部变量有更高的优先级。</p><p>PUTFIELD 和 GETFIELD 相似，但是会出栈顶数据，表达式的值会被赋值到变量</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Fields &#123;</span><br><span class="line"></span><br><span class="line">    int field</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        field = 5</span><br><span class="line">        print field</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成字节码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Fields &#123;</span><br><span class="line">  public int field;</span><br><span class="line"></span><br><span class="line">  public void start();</span><br><span class="line">    Code:           </span><br><span class="line">       0: aload_0               //get &quot;this&quot;</span><br><span class="line">       1: ldc           #9      // load constant &quot;5&quot; from constant pool </span><br><span class="line">       3: putfield      #11     // Field field:I - pop 5 off the stack and write to field</span><br><span class="line">       6: getstatic     #17     // Field java/lang/System.out:Ljava/io/PrintStream; </span><br><span class="line">       9: aload_0               //get &quot;this&quot; reference</span><br><span class="line">      10: getfield      #11     // Field field:I</span><br><span class="line">      13: invokevirtual #22     // Method &quot;Ljava/io/PrintStream;&quot;.println:(I)V</span><br><span class="line">      16: return</span><br><span class="line"></span><br><span class="line"> //autogenerated constructor and main method</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 17</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-17/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-17/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 17 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-17" target="_blank" rel="noopener">Github</a></p><h2 id="字节码-JVM-语言的通用描述"><a href="#字节码-JVM-语言的通用描述" class="headerlink" title="字节码 - JVM 语言的通用描述"></a>字节码 - JVM 语言的通用描述</h2><p>所有基于 JVM 的编程语言最终被编译到字节码，然后被虚拟机加载解释执行，这意味着虚拟机并不知道是什么语言生成了字节码。只要类在 classpath 上。</p><p>这为 Enkel 调用 Java 库以及其他框架提供了具体可能性。</p><h2 id="查找类方法和构造器"><a href="#查找类方法和构造器" class="headerlink" title="查找类方法和构造器"></a>查找类方法和构造器</h2><p>为了能够引用到其他类，有如下两种选择：</p><ul><li>运行时  相信程序员并且不检验生成的字节码，这可能会导致如果 classpath 不存在，JVM 会抛出异常</li><li>编译时  在生成字节码之前验证。如果验证失败，会终止编译过程。</li></ul><p>在 Enkel 中，我决定使用第二种方式，主要是出于安全考量。我们可以使用反射 API 来实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class ClassPathScope &#123;</span><br><span class="line"></span><br><span class="line"> public Optional&lt;FunctionSignature&gt; getMethodSignature(Type owner, String methodName, List&lt;Type&gt; arguments) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Class&lt;?&gt; methodOwnerClass = owner.getTypeClass();</span><br><span class="line">         Class&lt;?&gt;[] params = arguments.stream()</span><br><span class="line">                 .map(Type::getTypeClass).toArray(Class&lt;?&gt;[]::new);</span><br><span class="line">         Method method = methodOwnerClass.getMethod(methodName,params);</span><br><span class="line">         return Optional.of(ReflectionObjectToSignatureMapper.fromMethod(method));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         return Optional.empty();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> public Optional&lt;FunctionSignature&gt; getConstructorSignature(String className, List&lt;Type&gt; arguments) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Class&lt;?&gt; methodOwnerClass = Class.forName(className);</span><br><span class="line">         Class&lt;?&gt;[] params = arguments.stream()</span><br><span class="line">                 .map(Type::getTypeClass).toArray(Class&lt;?&gt;[]::new);</span><br><span class="line">         Constructor&lt;?&gt; constructor = methodOwnerClass.getConstructor(params);</span><br><span class="line">         return Optional.of(ReflectionObjectToSignatureMapper.fromConstructor(constructor));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         return Optional.empty();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果方法或者构造器不存在，会抛异常并且终止编译：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Scope.java</span><br><span class="line">return new ClassPathScope().getMethodSignature(owner.get(), methodName, argumentsTypes)</span><br><span class="line">                .orElseThrow(() -&gt; new MethodSignatureNotFoundException(this,methodName,arguments));</span><br></pre></td></tr></table></figure><p>这种方式看起来更加安全，但是同时也会慢一点。所有的依赖需要在编译的时候通过反射的方式来解决依赖。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="调用其他-Enkel-类"><a href="#调用其他-Enkel-类" class="headerlink" title="调用其他 Enkel 类"></a>调用其他 Enkel 类</h3><p>下面我们从 Client 类中调用 Library 的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Client &#123;</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        print &quot;Client: Calling my own &apos;Library&apos; class:&quot;</span><br><span class="line">        var myLibrary = new Library()</span><br><span class="line">        var addition = myLibrary.add(5,2)</span><br><span class="line">        print &quot;Client: Result returned from &apos;Library.add&apos; = &quot; + addition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Library &#123;</span><br><span class="line"></span><br><span class="line">    int add(int x,int y) &#123;</span><br><span class="line">        print &quot;Library: add() method called&quot;</span><br><span class="line">        return x+y</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们需要先编译 Library（我们目前不支持多文件同时编译），否则  Client 没办法编译通过。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/ClassPathCalls/Library.enk </span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java -classpath compiler/target/compiler-1.0-SNAPSHOT-jar-with-dependencies.jar:. com.kubadziworski.compiler.Compiler EnkelExamples/ClassPathCalls/Client.enk </span><br><span class="line">kuba@kuba-laptop:~/repos/Enkel-JVM-language$ java Client </span><br><span class="line">Client: Calling my own &apos;Library&apos; class:</span><br><span class="line">Library: add() method called</span><br><span class="line">Client: Result returned from &apos;Library.add&apos; = 7</span><br></pre></td></tr></table></figure><h3 id="调用-Java-的-API"><a href="#调用-Java-的-API" class="headerlink" title="调用 Java 的 API"></a>调用 Java 的 API</h3><figure class="highlight plain"><figcaption><span>&#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        var someString = &quot;someString&quot;</span><br><span class="line">        print someString + &quot; to upper case : &quot; +  someString.toUpperCase()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java Client </span><br><span class="line">cos to upper case = COS</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 16</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-16/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-16/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 16 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-16" target="_blank" rel="noopener">Github</a></p><h2 id="OOP-和-statics"><a href="#OOP-和-statics" class="headerlink" title="OOP 和 statics"></a>OOP 和 statics</h2><p>面向对象语言中最大的优点是啥？我个人认为是多态， 如何实现多态，使用继承呗，可以在静态语义下使用继承么？肯定不行呀。</p><p>在我认为，静态语义违反了面向对象的思想，不应该出现在面向对象中，为了避免使用多态，你可以用单例呀。</p><p>因此，为何有 static 情况下，Java 还声称自己是面向对象的呢？我认为，Java 是为了迎合 C++ 更加方便的接纳 Java 才引入的历史因素。</p><h2 id="去掉-static"><a href="#去掉-static" class="headerlink" title="去掉 static"></a>去掉 static</h2><p>直到上一篇博客，Enkel 中一直存在 static。包括 main 方法和其他的静态方法，这么是为了方便实现语言的其他特性，比如变量，条件表达式，循环，方法调用，然后才转成 OO。</p><p>那么我们来实现没有静态的 OO 吧。</p><h3 id="main-方法"><a href="#main-方法" class="headerlink" title="main 方法"></a>main 方法</h3><p>static main 方法需要 Java 程序员手动编写。Enkel 是这样处理的：</p><ul><li>编译器自动生成</li><li>在 main 方法中，用默认的构造器创建一个对象</li><li>然后调用 start 方法</li><li>程序员需要提供 start 方法定义</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private Function getGeneratedMainMethod() &#123;</span><br><span class="line">     FunctionParameter args = new FunctionParameter(&quot;args&quot;, BultInType.STRING_ARR, Optional.empty());</span><br><span class="line">     FunctionSignature functionSignature = new FunctionSignature(&quot;main&quot;, Collections.singletonList(args), BultInType.VOID);</span><br><span class="line">     ConstructorCall constructorCall = new ConstructorCall(scope.getClassName());</span><br><span class="line">     FunctionSignature startFunSignature = new FunctionSignature(&quot;start&quot;, Collections.emptyList(), BultInType.VOID);</span><br><span class="line">     FunctionCall startFunctionCall = new FunctionCall(startFunSignature, Collections.emptyList(), scope.getClassType());</span><br><span class="line">     Block block = new Block(new Scope(scope), Arrays.asList(constructorCall,startFunctionCall));</span><br><span class="line">     return new Function(functionSignature, block);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>start 方法是非静态的，但其实是 main 方法的一种变体。</p><h2 id="INVOSTATIC-vs-INVOKEVIRTUAL"><a href="#INVOSTATIC-vs-INVOKEVIRTUAL" class="headerlink" title="INVOSTATIC vs INVOKEVIRTUAL"></a>INVOSTATIC vs INVOKEVIRTUAL</h2><p>在第七部分，我用了 INVOKESTATIC 来做方法调用，是时候换成 INVOKEVIRTUAL 了。</p><p>INVOKEVIRTUAL 有一点和 INVOKESTATIC 有很大的差异，INVOKEVIRTUAL 需要一个所有者，INVOKESTATIC 从栈中出栈参数，INVOKEVIRTUAL 首先是把所有者出栈，然后才是出栈参数。</p><p>如果没有显示的提供所有者信息，默认用 this。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Mapping antlr generated FunctionCallContext to FunctionCall </span><br><span class="line">@Override</span><br><span class="line">public Expression visitFunctionCall(@NotNull EnkelParser.FunctionCallContext ctx) &#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    boolean ownerIsExplicit = ctx.owner != null;</span><br><span class="line">    if(ownerIsExplicit) &#123;</span><br><span class="line">        Expression owner = ctx.owner.accept(this);</span><br><span class="line">        return new FunctionCall(signature, arguments, owner);</span><br><span class="line">    &#125;</span><br><span class="line">    ClassType thisType = new ClassType(scope.getClassName());</span><br><span class="line">    return new FunctionCall(signature, arguments, new VarReference(&quot;this&quot;,thisType)); //pass &quot;this&quot; as a owner </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Generating bytecode using mapped FunctionCall object</span><br><span class="line">public void generate(FunctionCall functionCall) &#123;</span><br><span class="line">    functionCall.getOwner().accept(this); //generate owner (pushses it onto stack)</span><br><span class="line">    generateArguments(functionCall);  //generate arguments</span><br><span class="line">    String functionName = functionCall.getIdentifier();</span><br><span class="line">    String methodDescriptor = DescriptorFactory.getMethodDescriptor(functionCall.getSignature());</span><br><span class="line">    String ownerDescriptor = functionCall.getOwnerType().getInternalName();</span><br><span class="line">    //Consumes owner and arguments off the stack</span><br><span class="line">    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, ownerDescriptor, functionName, methodDescriptor, false); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HelloStart &#123;</span><br><span class="line"></span><br><span class="line">    start &#123;</span><br><span class="line">        print &quot;Hey I am non-static &apos;start&apos; method&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class HelloStart &#123;</span><br><span class="line">  public void start();</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #12                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #14                 // String Hey I am non-static  &apos;start&apos; method</span><br><span class="line">       5: invokevirtual #19                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">       8: return</span><br><span class="line"></span><br><span class="line">  //Constructor</span><br><span class="line">  public HelloStart();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0   //get &quot;this&quot;</span><br><span class="line">       1: invokespecial #22                 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V - call super</span><br><span class="line">       4: return</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: new           #2                  // class HelloStart - create new object</span><br><span class="line">       3: dup       //duplicate new object so that invokespecial does not consumes it</span><br><span class="line">       4: invokespecial #25                 // Method &quot;&lt;init&gt;&quot;:()V - call constructor</span><br><span class="line">       7: invokevirtual #27                 // Method start:()V</span><br><span class="line">      10: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与之对应 Java 类如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class HelloStart &#123;</span><br><span class="line">    public HelloStart() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        (new HelloStart()).start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void start() &#123;</span><br><span class="line">        System.out.println(&quot;Hey I am non-static \&apos;start\&apos; method&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 15</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-15/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-15/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 15 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-15" target="_blank" rel="noopener">Github</a></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Enkel 的构造器声明和调用的语法和 Java 保持一致。<br>声明实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cat ( String name ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Cat ( &quot;Molly&quot; )</span><br></pre></td></tr></table></figure><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><p>Java 中构造器的声明是一个没有返回值的函数。Enkel 中也是一样。</p><p>对于构造器的调用呢？解析器如何区别方法调用和构造器调用呢？因此，Enkel 引入了关键字 <code>new</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//other rules</span><br><span class="line">expression : //other rules alternatives</span><br><span class="line">           | &apos;new&apos; className &apos;(&apos;argument? (&apos;,&apos; argument)* &apos;)&apos; #constructorCall</span><br></pre></td></tr></table></figure><h2 id="匹配-Antlr-上下文对象"><a href="#匹配-Antlr-上下文对象" class="headerlink" title="匹配 Antlr 上下文对象"></a>匹配 Antlr 上下文对象</h2><p>新的语法规则 constructCall 带来一个新的解析回调：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Expression visitConstructorCall(@NotNull EnkelParser.ConstructorCallContext ctx) &#123;</span><br><span class="line">    String className = ctx.className().getText();</span><br><span class="line">    List&lt;EnkelParser.ArgumentContext&gt; argumentsCtx = ctx.argument();</span><br><span class="line">    List&lt;Expression&gt; arguments = getArgumentsForCall(argumentsCtx, className);</span><br><span class="line">    return new ConstructorCall(className, arguments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方法调用要求名字，返回值，以及参数和持有者的信息。构造器的调用仅仅需要类名和参数。</p><ul><li>构造器需要类型吗？ 不需要。因为返回值类型都是固定的，就是类本身</li><li>构造器需要持有者信息吗？不需要。因为构造器的调用都是通过 new 关键字，<code>someObject.new SomeObject()</code> 这种调用时没有任何意义的</li></ul><p>对于方法声明，我们又该如何区分呢? 有一种简单的办法就是对比方法的名字和类型是否一致。这也就是意味着普通方法的命名不能跟类名重复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Function visitFunction(@NotNull EnkelParser.FunctionContext ctx) &#123;</span><br><span class="line">        List&lt;Type&gt; parameterTypes = ctx.functionDeclaration().functionParameter().stream()</span><br><span class="line">                .map(p -&gt; TypeResolver.getFromTypeName(p.type())).collect(toList());</span><br><span class="line">        FunctionSignature signature = scope.getMethodCallSignature(ctx.functionDeclaration().functionName().getText(),parameterTypes);</span><br><span class="line">        scope.addLocalVariable(new LocalVariable(&quot;this&quot;,scope.getClassType()));</span><br><span class="line">        addParametersAsLocalVariables(signature);</span><br><span class="line">        Statement block = getBlock(ctx);</span><br><span class="line">        //Check if method is not actually a constructor</span><br><span class="line">        if(signature.getName().equals(scope.getClassName())) &#123;</span><br><span class="line">            return new Constructor(signature,block);</span><br><span class="line">        &#125;</span><br><span class="line">        return new Function(signature, block);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="默认的构造器"><a href="#默认的构造器" class="headerlink" title="默认的构造器"></a>默认的构造器</h2><p>如果你没有手动创建构造器，Enkel 会创建默认的构造器：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public ClassDeclaration visitClassDeclaration(@NotNull EnkelParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">    //some other stuff</span><br><span class="line">    boolean defaultConstructorExists = scope.parameterLessSignatureExists(className);</span><br><span class="line">    addDefaultConstructorSignatureToScope(name, defaultConstructorExists);</span><br><span class="line">    //other stuff</span><br><span class="line">    if(!defaultConstructorExists) &#123;</span><br><span class="line">        methods.add(getDefaultConstructor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">private void addDefaultConstructorSignatureToScope(String name, boolean defaultConstructorExists) &#123;</span><br><span class="line">    if(!defaultConstructorExists) &#123;</span><br><span class="line">        FunctionSignature constructorSignature = new FunctionSignature(name, Collections.emptyList(), BultInType.VOID);</span><br><span class="line">        scope.addSignature(constructorSignature);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Constructor getDefaultConstructor() &#123;</span><br><span class="line">    FunctionSignature signature = scope.getMethodCallSignatureWithoutParameters(scope.getClassName());</span><br><span class="line">    Constructor constructor = new Constructor(signature, Block.empty(scope));</span><br><span class="line">    return constructor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你或许好奇为何构造器返回 void。简单来说就是 JVM 把对象的创建分为两个步骤：首先分配内存空间，然后才是调用构造器（构造器主要职责是做初始化，因此我们可以在构造函数内调用 this 变量）。</p><h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><p>到目前为止，我们已经可以解析构造函数的声明以及调用了。接下来就是如何生成字节码了。</p><p>对象的创建的字节码有两个指令：</p><ul><li>NEW 在堆中分类内存，初始化成员变量为默认值</li><li>INVOKESPECIAL 调用构造器</li></ul><p>Java 中你无需在构造器中手动调用 super() 。实际上这是必须的，否则无法创建对象，但是 Java 编译器帮我们做了这一步。</p><p>调用 super 会用到 INVOKESPECIAL 指令，Enkel 编译器跟 Java 编译器保持一致，也会自动处理调用。</p><h3 id="构造器调用的字节码生成"><a href="#构造器调用的字节码生成" class="headerlink" title="构造器调用的字节码生成"></a>构造器调用的字节码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void generate(ConstructorCall constructorCall) &#123;</span><br><span class="line">        String ownerDescriptor = scope.getClassInternalName(); //example : java/lang/String</span><br><span class="line">        methodVisitor.visitTypeInsn(Opcodes.NEW, ownerDescriptor); //NEW instruction takes object decriptor as an input</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.DUP); //Duplicate (we do not want invokespecial to &quot;eat&quot; our brand new object</span><br><span class="line">        FunctionSignature methodCallSignature = scope.getMethodCallSignature(constructorCall.getIdentifier(),constructorCall.getArguments());</span><br><span class="line">        String methodDescriptor = DescriptorFactory.getMethodDescriptor(methodCallSignature);</span><br><span class="line">        generateArguments(constructorCall);</span><br><span class="line">        methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, ownerDescriptor, &quot;&lt;init&gt;&quot;, methodDescriptor, false);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>你可能会好奇为什么用到了 DUP 指令。在 NEW 指令执行后，栈中保存了新建创的对象。INVOKESPECIAL 指令会从栈顶取数据，然后初始化。如果我们不赋值对象，这样会导致新创建的对象被构造器指令出栈，然后对象会丢失在堆中等待 GC 去做垃圾回收。</p><p>如下的语句：<br><code>new Cat().meow()</code></p><p>会生成如下的字节码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0: new           #2                  // class Cat</span><br><span class="line">3: dup</span><br><span class="line">4: invokespecial #23                 // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">7: invokevirtual #26                 // Method meow:()V</span><br></pre></td></tr></table></figure><h3 id="构造器声明的字节码生成"><a href="#构造器声明的字节码生成" class="headerlink" title="构造器声明的字节码生成"></a>构造器声明的字节码生成</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public void generate(Constructor constructor) &#123;</span><br><span class="line">    Block block = (Block) constructor.getRootStatement();</span><br><span class="line">    Scope scope = block.getScope();</span><br><span class="line">    int access = Opcodes.ACC_PUBLIC;</span><br><span class="line">    String description = DescriptorFactory.getMethodDescriptor(constructor);</span><br><span class="line">    MethodVisitor mv = classWriter.visitMethod(access, &quot;&lt;init&gt;&quot;, description, null, null);</span><br><span class="line">    mv.visitCode();</span><br><span class="line">    StatementGenerator statementScopeGenrator = new StatementGenerator(mv,scope);</span><br><span class="line">    new SuperCall().accept(statementScopeGenrator); //CALL SUPER IMPLICITILY BEFORE BODY ITSELF</span><br><span class="line">    block.accept(statementScopeGenrator); //CALL THE BODY DEFINED BY PROGRAMMER</span><br><span class="line">    appendReturnIfNotExists(constructor, block,statementScopeGenrator);</span><br><span class="line">    mv.visitMaxs(-1,-1);</span><br><span class="line">    mv.visitEnd();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面我们提到，构造器中的 super 调用时必须的，Java 中我们没有手动调用（除非父类没有无参构造器）。这样做不是非必须的而是 Java 编译器帮我们做了自动生成。Enkel 也要有这么炫酷的功能。</p><p><code>new SuperCall().accept(statementScopeGenrator);</code></p><p>触发：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public void generate(SuperCall superCall) &#123;</span><br><span class="line">    methodVisitor.visitVarInsn(Opcodes.ALOAD,0); //LOAD &quot;this&quot; object</span><br><span class="line">    generateArguments(superCall);</span><br><span class="line">    String ownerDescriptor = scope.getSuperClassInternalName();</span><br><span class="line">    methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, ownerDescriptor, &quot;&lt;init&gt;&quot;, &quot;()V&quot; , false);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个方法（甚至是构造器）把参数当做帧中的局部变量来对待。如果方法 <code>int add(int x,int y)</code> 在静态上下文中被调用，他的初始 frame 中存在两个变量（x, y）。如果在非静态上下文中，this(被调用者）也存在局部变量中。因此，如果 add 方法是在非静态上下文中被调用，那么有三个局部变量(this, x, y)。</p><p>Cat 类的构造器（构造器内没有内容）生成的字节码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0: aload_0      //load &quot;this&quot;</span><br><span class="line">1: invokespecial #8                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V - call super on &quot;this&quot; (the Cat dervies from Object)</span><br><span class="line">12: return</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 14</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-14/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-14/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 14 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-14" target="_blank" rel="noopener">Github</a></p><h2 id="支持新的类型"><a href="#支持新的类型" class="headerlink" title="支持新的类型"></a>支持新的类型</h2><p>目前为止 Enkel 仅支持了整数类型和字符串类型。是时候支持其他的原始类型了。这也是为创建面向对象特性做准备。</p><h2 id="指令集的抽象"><a href="#指令集的抽象" class="headerlink" title="指令集的抽象"></a>指令集的抽象</h2><p>字节码指令中有很多指令仅仅是在数据类型上有区别，以 return 指令举例：</p><ul><li>return - 方法返回</li><li>ireturn - 返回interger</li><li>freturn - 返回float</li><li>dreturn - 返回double</li><li>lreturn - 返回long</li><li>areturn - 返回引用</li></ul><p>字节码生成的时候，我们多写一点 case 语句可以实现，但是很丑陋。因此我用 TypeSpecificOpcodes 枚举存储了所有类型对应的字节码指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public enum TypeSpecificOpcodes &#123; </span><br><span class="line"></span><br><span class="line">    INT (ILOAD, ISTORE, IRETURN,IADD,ISUB,IMUL,IDIV), //values (-127,127) - one byte.</span><br><span class="line">    LONG (LLOAD, LSTORE, LRETURN,LADD,LSUB,LMUL,LDIV),</span><br><span class="line">    FLOAT (FLOAD, FSTORE, FRETURN,FADD,FSUB,FMUL,FDIV),</span><br><span class="line">    DOUBLE (DLOAD, DSTORE, DRETURN,DADD,DSUB,DMUL,DDIV),</span><br><span class="line">    VOID(ALOAD, ASTORE, RETURN,0,0,0,0),</span><br><span class="line">    OBJECT (ALOAD,ASTORE,ARETURN,0,0,0,0);</span><br><span class="line"></span><br><span class="line">    TypeSpecificOpcodes(int load, int store, int ret, int add, int sub, int mul, int div) &#123;</span><br><span class="line">        //assign each parameter to the field</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //getters</span><br></pre></td></tr></table></figure><p>类型相关的字节码指令，目前我们用到了：</p><ul><li>load - 从局部变量表中加载变量</li><li>store - 存储至局部变量表</li><li>ret - 返回</li><li>add - 操作数栈中两个数相加</li><li>sub - 栈中操作数相减</li><li>mul - 栈中操作数相乘</li><li>div - 栈中操作数相除</li></ul><p>TypeSpecificOpcodes 是在 BultInType 类中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum BultInType implements Type &#123;</span><br><span class="line">    BOOLEAN(&quot;bool&quot;,boolean.class,&quot;Z&quot;, TypeSpecificOpcodes.INT),</span><br><span class="line">    </span><br><span class="line">    //other members</span><br><span class="line">    </span><br><span class="line">    BultInType(String name, Class&lt;?&gt; typeClass, String descriptor, TypeSpecificOpcodes opcodes) &#123;</span><br><span class="line">        //assign to fields</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int getMultiplyOpcode() &#123;</span><br><span class="line">        return opcodes.getMultiply();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>无论何时，两个数相乘，只要知道类型就可以了，再也不用查找类型对应的字节码指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void generate(Multiplication expression) &#123;</span><br><span class="line">    evaluateArthimeticComponents(expression);</span><br><span class="line">    Type type = expression.getType();</span><br><span class="line">    methodVisitor.visitInsn(type.getMultiplyOpcode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main(string[] args) &#123;</span><br><span class="line">        var stringVar = &quot;str&quot;</span><br><span class="line">        var booleanVar = true</span><br><span class="line">        var integerVar = 2745 + 33</span><br><span class="line">        var doubleVar = 2343.05</span><br><span class="line">        var sumOfDoubleVars =  23.0 + doubleVar</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>编译后的字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class AllPrimitiveTypes &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #8                  // String str</span><br><span class="line">       2: astore_1                          //store it variable</span><br><span class="line">       3: ldc           #9                  // int 1 - bool values are represented as ints in JVM</span><br><span class="line">       5: istore_2                          //store as int </span><br><span class="line">       6: ldc           #10                 // int 2745 </span><br><span class="line">       8: ldc           #11                 // int 33</span><br><span class="line">      10: iadd                              // iadd - add integers</span><br><span class="line">      11: istore_3                          //store result in integer varaible</span><br><span class="line">      12: ldc           #12                 // float 2343.05f </span><br><span class="line">      14: fstore        4                   //store in float variable</span><br><span class="line">      16: ldc           #13                 // float 23.0f </span><br><span class="line">      18: fload         4                   //load integer varaible (from index 4)</span><br><span class="line">      20: fadd                              //add float variables</span><br><span class="line">      21: fstore        5                   //store float result</span><br><span class="line">      23: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 13</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-13/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-13/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 13 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-13" target="_blank" rel="noopener">Github</a></p><h2 id="范围-for-循环"><a href="#范围-for-循环" class="headerlink" title="范围 for 循环"></a>范围 for 循环</h2><p>本节中我们来实现范围循环，在范围内迭代值，在 Java 中大概张这个样子：<br><code>for (int i=0;i&lt;=5;i++)</code></p><p>Enkel 的等价形式：<br><code>for i from 0 to 5</code></p><p>我实现另外一个特性，循环会自动检测是递增还是递减：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for i from 0 to 5 //increment i from 0 to 5  - for (int i=0;i&lt;=5;i++)</span><br><span class="line"></span><br><span class="line">for i from 5 to 0 //decremenet i from 5 to 0 - for (int i=5;i&gt;=0;i--)</span><br></pre></td></tr></table></figure><p>递增或者递减必须在运行时推断，因为范围的值可能是方法调用的返回值。</p><p>for while 循环或者容器迭代器都很相似，本节不做描述。</p><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">statement : block</span><br><span class="line">           //other statement alternatives</span><br><span class="line">           | forStatement ;</span><br><span class="line"></span><br><span class="line">forStatement : &apos;for&apos; (&apos;(&apos;)? forConditions (&apos;)&apos;)? statement ;</span><br><span class="line">forConditions : iterator=varReference  &apos;from&apos; startExpr=expression range=&apos;to&apos; endExpr=expression ;</span><br></pre></td></tr></table></figure><ul><li>forConditions 是迭代的条件表达式</li><li>= 提高可读性</li><li>迭代器必须是变量的名字</li><li>startExpression 用来初始化迭代器</li><li>endExpressions 是迭代器的终止值</li></ul><p><code>for (i from 0 to 5) print i</code> 图形化的解析树如下所示：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_13/parse_tree.gif" alt=""></p><h2 id="匹配-Antlr-上下文对象"><a href="#匹配-Antlr-上下文对象" class="headerlink" title="匹配 Antlr 上下文对象"></a>匹配 Antlr 上下文对象</h2><p>Antlr 根据语法规则会生成 ForStatementContext 对象，我们用它生成对编译器更加友好的类。可以解决迭代器变量未生明的问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class ForStatementVisitor extends EnkelBaseVisitor&lt;RangedForStatement&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //other stuff</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public RangedForStatement visitForStatement(@NotNull ForStatementContext ctx) &#123;</span><br><span class="line">        EnkelParser.ForConditionsContext forExpressionContext = ctx.forConditions();</span><br><span class="line">        Expression startExpression = forExpressionContext.startExpr.accept(expressionVisitor);</span><br><span class="line">        Expression endExpression = forExpressionContext.endExpr.accept(expressionVisitor);</span><br><span class="line">        VarReferenceContext iterator = forExpressionContext.iterator;</span><br><span class="line">        String varName = iterator.getText();</span><br><span class="line">        //If variable referenced by iterator already exists in the scope</span><br><span class="line">        if(scope.localVariableExists(varName)) &#123; </span><br><span class="line">            //register new variable value</span><br><span class="line">            Statement iteratorVariable = new AssignmentStatement(varName, startExpression); </span><br><span class="line">            //get the statement (usually block))</span><br><span class="line">            Statement statement = ctx.statement().accept(statementVisitor); </span><br><span class="line">            return new RangedForStatement(iteratorVariable, startExpression, endExpression,statement, varName, scope); </span><br><span class="line">        //Variable has not been declared in the scope</span><br><span class="line">        &#125; else &#123; </span><br><span class="line">            //create new local variable and add to the scope</span><br><span class="line">            scope.addLocalVariable(new LocalVariable(varName,startExpression.getType())); </span><br><span class="line">            //register variable declaration statement</span><br><span class="line">            Statement iteratorVariable = new VariableDeclarationStatement(varName,startExpression); </span><br><span class="line">            Statement statement = ctx.statement().accept(statementVisitor);</span><br><span class="line">            return new RangedForStatement(iteratorVariable, startExpression, endExpression,statement, varName,scope);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器变量可能在作用中存在或者未生明，这两种情况都需要被妥善处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var iterator = 0</span><br><span class="line">for (iterator from 0 to 5) print iterator</span><br></pre></td></tr></table></figure><p>迭代器已经声明过，赋值给 startExpression。<br><code>new AssignmentStatement(varName,startExpression);</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (iterator from 0 to 5) print iterator</span><br></pre></td></tr></table></figure><p>迭代器没有声明，首先声明，然后赋值给 startExpression。<br><code>new VariableDeclarationStatement(varName,startExpression);</code></p><h2 id="字节码生成"><a href="#字节码生成" class="headerlink" title="字节码生成"></a>字节码生成</h2><p>RangedForStatement 生成后，下面我们开始生成字节码。</p><p>JVM 中没有为 for 循环设计特殊的指令。一种实现方式就是使用控制流指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public void generate(RangedForStatement rangedForStatement) &#123;</span><br><span class="line">    Scope newScope = rangedForStatement.getScope();</span><br><span class="line">    StatementGenerator scopeGeneratorWithNewScope = new StatementGenerator(methodVisitor, newScope);</span><br><span class="line">    ExpressionGenrator exprGeneratorWithNewScope = new ExpressionGenrator(methodVisitor, newScope);</span><br><span class="line">    Statement iterator = rangedForStatement.getIteratorVariableStatement();</span><br><span class="line">    Label incrementationSection = new Label();</span><br><span class="line">    Label decrementationSection = new Label();</span><br><span class="line">    Label endLoopSection = new Label();</span><br><span class="line">    String iteratorVarName = rangedForStatement.getIteratorVarName();</span><br><span class="line">    Expression endExpression = rangedForStatement.getEndExpression();</span><br><span class="line">    Expression iteratorVariable = new VarReference(iteratorVarName, rangedForStatement.getType());</span><br><span class="line">    ConditionalExpression iteratorGreaterThanEndConditional = new ConditionalExpression(iteratorVariable, endExpression, CompareSign.GREATER);</span><br><span class="line">    ConditionalExpression iteratorLessThanEndConditional = new ConditionalExpression(iteratorVariable, endExpression, CompareSign.LESS);</span><br><span class="line"></span><br><span class="line">    //generates varaible declaration or variable reference (istore)</span><br><span class="line">    iterator.accept(scopeGeneratorWithNewScope);</span><br><span class="line"></span><br><span class="line">    //Section below checks whether the loop should be iterating or decrementing</span><br><span class="line">    //If the range start is smaller than range end (i from 0 to 5)  then iterate (++)</span><br><span class="line">    //If the range start is greater than range end (i from 5 to 0) then decrement (--)</span><br><span class="line"></span><br><span class="line">    //Pushes 0 or 1 onto the stack </span><br><span class="line">    iteratorLessThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    //IFNE - is value on the stack (result of conditional) different than 0 (success)?</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFNE,incrementationSection);</span><br><span class="line"></span><br><span class="line">    iteratorGreaterThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFNE,decrementationSection);</span><br><span class="line"></span><br><span class="line">    //Incrementation section</span><br><span class="line">    methodVisitor.visitLabel(incrementationSection);</span><br><span class="line">    rangedForStatement.getStatement().accept(scopeGeneratorWithNewScope); //execute the body</span><br><span class="line">    methodVisitor.visitIincInsn(newScope.getLocalVariableIndex(iteratorVarName),1); //increment iterator</span><br><span class="line">    iteratorGreaterThanEndConditional.accept(exprGeneratorWithNewScope); //is iterator greater than range end?</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFEQ,incrementationSection); //if it is not go back loop again </span><br><span class="line">    //the iterator is greater than end range. Break out of the loop, skipping decrementation section</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.GOTO,endLoopSection); </span><br><span class="line"></span><br><span class="line">    //Decrementation section</span><br><span class="line">    methodVisitor.visitLabel(decrementationSection);</span><br><span class="line">    rangedForStatement.getStatement().accept(scopeGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitIincInsn(newScope.getLocalVariableIndex(iteratorVarName),-1); //decrement iterator</span><br><span class="line">    iteratorLessThanEndConditional.accept(exprGeneratorWithNewScope);</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.IFEQ,decrementationSection);</span><br><span class="line"></span><br><span class="line">    methodVisitor.visitLabel(endLoopSection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这看起来有点复杂，因为递增递减的推测逻辑是在运行时决定的。</p><p>以 <code>for (i from 0 to 5)</code> 为例，我们来看一下整个流程:</p><ol><li>声明迭代器变量 i 并且赋予初始值 0</li><li>检测迭代器的值 0 是否大于结束值 5</li><li>因为 0 &lt; 5, 因此递增，跳到递增部分</li><li>执行 for 循环体内的语句</li><li>递增 1</li><li>检查迭代器的值是否大于 5</li><li>如果条件不成立，跳到 4</li><li>循环体执行 5 次后，跳到结束部分</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Loops &#123;</span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">        for i from 1 to 5 &#123;</span><br><span class="line">            print i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成后的字节码反编译后的 Java 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Loops &#123;</span><br><span class="line">    public static void main(String[] var0) &#123;</span><br><span class="line">        int var1 = 1;</span><br><span class="line">        if(var1 &gt;= 5 ) &#123; //should it be decremented?</span><br><span class="line">            do &#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">                --var1;</span><br><span class="line">            &#125; while(var1 &gt;= 5);</span><br><span class="line">        &#125; else &#123; //should it be incremented?</span><br><span class="line">            do &#123;</span><br><span class="line">                System.out.println(var1);</span><br><span class="line">                ++var1;</span><br><span class="line">            &#125; while(var1 &lt;= 5);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ java Loops </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 12</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-12/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-12/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 12 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-12" target="_blank" rel="noopener">Github</a></p><h2 id="为什么需要命名参数"><a href="#为什么需要命名参数" class="headerlink" title="为什么需要命名参数"></a>为什么需要命名参数</h2><p>在 Java 中（多数语言中也是如此）方法调用的参数匹配是通过索引值，如果方法调用的参数比较少并且参数的类型有差别的情况，是合理的。不幸的是，如果方法调用的参数有很多个，并且类型相同，这是个悲剧。</p><p>例如：<br><code>Rect createRectangle(int x1,int y1,int x2, int y2) //createRectangle signature</code></p><p>我打赌你很有可能会传错参数。</p><p>你发现问题了吗？这种情况开发者很容易搞混参数的顺序，由于是相同类型，编译器也没办帮你检查问题。</p><p>这就是命名参数的有点，你可以给参数指定名字，而不是仅仅通过索引值来指定参数。<br>使用命名参数有很多好处：</p><ul><li>参数的顺序不受限制</li><li>代码可读性提高</li><li>不用再两个文件中跳转对比方法的签名和实际传参是否一致</li></ul><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">functionCall : functionName &apos;(&apos;argument? (&apos;,&apos; argument)* &apos;)&apos;;</span><br><span class="line">argument : expression              //unnamed argument</span><br><span class="line">         | name &apos;-&gt;&apos; expression   ; //named argument</span><br></pre></td></tr></table></figure><p>方法调用的参数之间用逗号分割。argument 有两种格式，命名参数和未命名参数，这两种格式不允许同时存在。</p><h2 id="记录参数"><a href="#记录参数" class="headerlink" title="记录参数"></a>记录参数</h2><p>在第七部分描述到，方法的解析分为两个步骤: 首先记录所有的方法签名（方法的声明），下一步是解析方法体，这样保证在解析方法体的时候，所有的方法签名都已经被解析过了。</p><p>实现命名参数的思路是把命名参数的调用转换成未命名参数的调用，参数索引位置通过方法签名去获得：</p><ul><li>在方法签名中查找匹配的参数名字</li><li>获得参数的索引</li><li>如果参数的索引值和实际不一致，记录下来</li></ul><p><img src="http://jakubdziworski.github.io/assets/media/enkle_12/diagram.gif" alt=""></p><p>上图中的示例，x1 的索引和 y1 对调。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    @Override</span><br><span class="line">    public Expression visitFunctionCall(@NotNull EnkelParser.FunctionCallContext ctx) &#123;</span><br><span class="line">        String funName = ctx.functionName().getText();</span><br><span class="line">        FunctionSignature signature = scope.getSignature(funName); </span><br><span class="line">        List&lt;EnkelParser.ArgumentContext&gt; argumentsCtx = ctx.argument();</span><br><span class="line">        //Create comparator that compares arguments based on their index in signature</span><br><span class="line">        Comparator&lt;EnkelParser.ArgumentContext&gt; argumentComparator = (arg1, arg2) -&gt; &#123;</span><br><span class="line">            if(arg1.name() == null) return 0; //If the argument is not named skip</span><br><span class="line">            String arg1Name = arg1.name().getText();</span><br><span class="line">            String arg2Name = arg2.name().getText();</span><br><span class="line">            return signature.getIndexOfParameter(arg1Name) - signature.getIndexOfParameter(arg2Name);</span><br><span class="line">        &#125;;</span><br><span class="line">        List&lt;Expression&gt; arguments = argumentsCtx.stream() //parsed arguments (wrong order)</span><br><span class="line">                .sorted(argumentComparator) //Order using created comparator</span><br><span class="line">                .map(argument -&gt; argument.expression().accept(this)) //Map parsed arguments into expressions</span><br><span class="line">                .collect(toList());</span><br><span class="line">        return new FunctionCall(signature, arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式对字节码的生成是透明的，字节码生成阶段无需了解方法调用参数是命名还是未命名</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下的 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NamedParamsTest &#123;</span><br><span class="line"></span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">        createRect(x1-&gt;25,x2-&gt;-25,y1-&gt;50,y2-&gt;-50)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    createRect (int x1,int y1,int x2, int y2) &#123;</span><br><span class="line">        print &quot;Created rect with x1=&quot; + x1 + &quot; y1=&quot; + y1 + &quot; x2=&quot; + x2 + &quot; y2=&quot; + y2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的字节码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class NamedParamsTest &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        25          //x1 (1 index in call)</span><br><span class="line">       2: bipush        50          //y1 (3 index in call)</span><br><span class="line">       4: bipush        -25         //x2 (2 index in call)</span><br><span class="line">       6: bipush        -50         //y2 (4 index in call)</span><br><span class="line">       8: invokestatic  #10                 // Method createRect:(IIII)V</span><br><span class="line">      11: return</span><br><span class="line"></span><br><span class="line">  public static void createRect(int, int, int, int);</span><br><span class="line">    Code:</span><br><span class="line">      //normal printing code </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><code>Created rect with x1=25 y1=50 x2=-25 y2=-50</code></p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 11</title>
      <link href="/2018/09/04/Creating-JVM-Language-Part-11/"/>
      <url>/2018/09/04/Creating-JVM-Language-Part-11/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 11 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-11" target="_blank" rel="noopener">Github</a></p><h2 id="Java-以及默认参数"><a href="#Java-以及默认参数" class="headerlink" title="Java 以及默认参数"></a>Java 以及默认参数</h2><p>Java 中没有默认参数是我感觉最不爽的一点。有些人建议我使用 Builder 模式，但是我觉得这样会产生大量的模板代码。我一直搞不懂为何 Java 这么久以来忽略了这个特性。虽然实现起来并不困难。</p><h2 id="实参-Argument-VS-形参-（Parameter）"><a href="#实参-Argument-VS-形参-（Parameter）" class="headerlink" title="实参(Argument) VS 形参 （Parameter）"></a>实参(Argument) VS 形参 （Parameter）</h2><p>这两个概念非常容易被混淆。简单说来就是：</p><ul><li>形参 - 方法的签名</li><li>实参 - 方法调用的传参</li></ul><p>方法调用的时候传递的表达式是实际参数，而形参是用来表示一个方法的签名。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>思路：在方法调用的时候，查找对应的方法签名，并且获得参数的默认值。这样字节码生成部分无需修改。方法调用的时候，把没明确给出值的参数用默认值代替，模拟正常的调用。</p><h2 id="语法规则更改"><a href="#语法规则更改" class="headerlink" title="语法规则更改"></a>语法规则更改</h2><p>语法规则变动仅发生在 functionParameterRule:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">functionParameter : type ID functionParamdefaultValue? ;</span><br><span class="line">functionParamdefaultValue : &apos;=&apos; expression ;</span><br></pre></td></tr></table></figure></p><p>方法参数包含了类型以及名字，以及后面可选的 <code>=</code> 以及紧随其后的默认值。</p><h2 id="匹配-Antlr-上下文对象"><a href="#匹配-Antlr-上下文对象" class="headerlink" title="匹配 Antlr 上下文对象"></a>匹配 Antlr 上下文对象</h2><p>这部分的改动也是很小的。在 FunctionParameter 类中添加新的字段 defaultValue ，字段中保存了 <code>Optional&lt;Expression&gt;</code> 。如果解析器发现 defaultValue 有明确传值，那么 Optional 中有值，否则是 empty。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class FunctionSignatureVisitor extends EnkelBaseVisitor&lt;FunctionSignature&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public FunctionSignature visitFunctionDeclaration(@NotNull EnkelParser.FunctionDeclarationContext ctx) &#123;</span><br><span class="line">       //other stuff</span><br><span class="line">        for(int i=0;i&lt;argsCtx.size();i++) &#123; //for each parsed argument</span><br><span class="line">        //other stuff</span><br><span class="line">            Optional&lt;Expression&gt; defaultValue = getParameterDefaultValue(argCtx);</span><br><span class="line">            FunctionParameter functionParameters = new FunctionParameter(name, type, defaultValue);</span><br><span class="line">            parameters.add(functionParameters);</span><br><span class="line">        &#125;</span><br><span class="line">        //other stuff</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Optional&lt;Expression&gt; getParameterDefaultValue(FunctionParameterContext argCtx) &#123;</span><br><span class="line">        if(argCtx.functionParamdefaultValue() != null) &#123;</span><br><span class="line">            EnkelParser.ExpressionContext defaultValueCtx = argCtx.functionParamdefaultValue().expression();</span><br><span class="line">            return Optional.of(defaultValueCtx.accept(expressionVisitor));</span><br><span class="line">        &#125;</span><br><span class="line">        return Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成字节码"><a href="#生成字节码" class="headerlink" title="生成字节码"></a>生成字节码</h2><p>方法调用的字节码生成需要添加如下处理:</p><ul><li>检查实际传参的数量是否多余方法签名参数数量</li><li>对于没有传递的参数，需要对默认的表达式求值</li></ul><p>缺失参数的索引值是这样安排的：参数的索引在方法签名的最后一个参数之前（闭区间）和方法调用的实际传参索引之间（开区间）。</p><p>举例:<br><code>signature: fun(int x,int x2=5,int x3=4)</code></p><p><code>call: fun(2)</code></p><p>缺失的参数是 x2 (索引是 1）和 x3(索引值是2)，因为方法调用的参数索引是0， 方法签名的索引值最大是 2，所以缺失参数的索引分别是 1 和 2。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class ExpressionGenrator &#123;</span><br><span class="line">    public void generate(FunctionCall functionCall) &#123;</span><br><span class="line">        //other stuff</span><br><span class="line">        if(arguments.size() &gt; parameters.size()) &#123;  </span><br><span class="line">            throw new BadArgumentsToFunctionCallException(functionCall);</span><br><span class="line">        &#125;</span><br><span class="line">        arguments.forEach(argument -&gt; argument.accept(this));</span><br><span class="line">        for(int i=arguments.size();i&lt;parameters.size();i++) &#123;</span><br><span class="line">            Expression defaultParameter = parameters.get(i).getDefaultValue()</span><br><span class="line">                    .orElseThrow(() -&gt; new BadArgumentsToFunctionCallException(functionCall));</span><br><span class="line">            defaultParameter.accept(this);</span><br><span class="line">        &#125;</span><br><span class="line">        //other stuff   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下 Enkel 代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DefaultParamTest &#123;</span><br><span class="line"></span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">         greet(&quot;andrew&quot;)</span><br><span class="line">         print &quot;&quot;</span><br><span class="line">         greet(&quot;kuba&quot;,&quot;enkel&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    greet (string name,string favouriteLanguage=&quot;java&quot;) &#123;</span><br><span class="line">        print &quot;Hello my name is &quot;</span><br><span class="line">        print name</span><br><span class="line">        print &quot;and my favourite langugage is &quot;</span><br><span class="line">        print favouriteLanguage</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的字节码输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultParamTest &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #8                  //push String &quot;andrew&quot; onto the stack</span><br><span class="line">       2: ldc           #10   // push String &quot;java&quot; onto the stack  &lt;-- implicit argument value</span><br><span class="line">       4: invokestatic  #14                 // invoke static method greet:(Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line">       7: getstatic     #20                 // get static field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      10: ldc           #22                 // push  empty String (empty line)</span><br><span class="line">      12: invokevirtual #27                 // call Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V to print empty line</span><br><span class="line">      15: ldc           #29                 // push String &quot;kuba&quot;</span><br><span class="line">      17: ldc           #31   // push String &quot;enkel&quot; &lt;-- explicit argument value</span><br><span class="line">      19: invokestatic  #14                 //invoke static method greet:(Ljava/lang/String;Ljava/lang/String;)V</span><br><span class="line">      22: return</span><br><span class="line"></span><br><span class="line">  public static void greet(java.lang.String, java.lang.String);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: ldc           #33                 // String Hello my name is</span><br><span class="line">       5: invokevirtual #27                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">       8: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      11: aload_0                           // load (push onto stack) variable at index 0 (first parameter of a method)</span><br><span class="line">      12: invokevirtual #27                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">      15: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      18: ldc           #35                 // String and my favourite langugage is</span><br><span class="line">      20: invokevirtual #27                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">      23: getstatic     #20                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      26: aload_1                           // load (push onto stack) variable at index 1 (second parameter of a method)</span><br><span class="line">      27: invokevirtual #27                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">      30: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行输出是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Hello my name is </span><br><span class="line">andrew</span><br><span class="line">and my favourite langugage is </span><br><span class="line">java</span><br><span class="line"></span><br><span class="line">Hello my name is </span><br><span class="line">kuba</span><br><span class="line">and my favourite langugage is </span><br><span class="line">enkel</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 10</title>
      <link href="/2018/08/25/Creating-JVM-Language-Part-10/"/>
      <url>/2018/08/25/Creating-JVM-Language-Part-10/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 10 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-10" target="_blank" rel="noopener">Github</a></p><h2 id="1-语法规则更改"><a href="#1-语法规则更改" class="headerlink" title="1. 语法规则更改"></a>1. 语法规则更改</h2><p>实现条件语句需要对语法规则作如下两处改动：</p><ul><li>添加新规则 ifStatement</li><li>添加 conditionalExpressions 表达式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifStatement :  &apos;if&apos;  &apos;(&apos;? expression &apos;)&apos;? trueStatement=statement (&apos;else&apos; falseStatement=statement)?;</span><br><span class="line">expression : varReference #VARREFERENCE</span><br><span class="line">           | value        #VALUE</span><br><span class="line">           //other expression alternatives</span><br><span class="line">           | expression cmp=&apos;&gt;&apos; expression #conditionalExpression</span><br><span class="line">           | expression cmp=&apos;&lt;&apos; expression #conditionalExpression</span><br><span class="line">           | expression cmp=&apos;==&apos; expression #conditionalExpression</span><br><span class="line">           | expression cmp=&apos;!=&apos; expression #conditionalExpression</span><br><span class="line">           | expression cmp=&apos;&gt;=&apos; expression #conditionalExpression</span><br><span class="line">           | expression cmp=&apos;&lt;=&apos; expression #conditionalExpression</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure><p>ifStatement 规则定义：</p><ul><li>expression 是一个真值表达式</li><li>真值表达式放到括号里是非必要的，问号 ？意味着是可选的</li><li>为 true 时 trueStatement 会被执行</li><li>if 后面可以跟随者 else</li><li>当 false 时 falseStatement 会被执行</li><li>ifStatement 是语句，因此可以子在 trueStatement 或者 falseStatement 使用（形如 if … else if …else ）</li></ul><p>条件表达式的目的是比较两个表达式，并且返回另一个表达式（布尔值）。</p><p>为了更好的理解 if 和 else 是如何被用来表示 else if，请看下面代码片段：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(0) &#123;</span><br><span class="line">        </span><br><span class="line">&#125; else if(1) &#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AST 表示如下图所示：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_10/if_parse.gif" alt=""></p><p>如图所示，第二个 if 其实就是 else 的子语句。他们在不同的层级。因此没有必要指明 else if 规则。ifstatement 规则本质是一个语句，因此其他 ifStatements 可以嵌套用在 ifStatements。</p><h2 id="2-匹配-Antlr-上下文对象"><a href="#2-匹配-Antlr-上下文对象" class="headerlink" title="2. 匹配 Antlr 上下文对象"></a>2. 匹配 Antlr 上下文对象</h2><p>Antlr 会生成 IfStatementContext 对象并转化成 POJO IfStatement 对象：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class StatementVisitor extends EnkelBaseVisitor&lt;Statement&gt; &#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    @Override</span><br><span class="line">    public Statement visitIfStatement(@NotNull EnkelParser.IfStatementContext ctx) &#123;</span><br><span class="line">        ExpressionContext conditionalExpressionContext = ctx.expression();</span><br><span class="line">        Expression condition = conditionalExpressionContext.accept(expressionVisitor); //Map conditional expression</span><br><span class="line">        Statement trueStatement = ctx.trueStatement.accept(this); //Map trueStatement antlr object</span><br><span class="line">        Statement falseStatement = ctx.falseStatement.accept(this); //Map falseStatement antlr object</span><br><span class="line"></span><br><span class="line">        return new IfStatement(condition, trueStatement, falseStatement);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>条件表达式会被匹配成下面这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class ExpressionVisitor extends EnkelBaseVisitor&lt;Expression&gt; &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public ConditionalExpression visitConditionalExpression(@NotNull EnkelParser.ConditionalExpressionContext ctx) &#123;</span><br><span class="line">        EnkelParser.ExpressionContext leftExpressionCtx = ctx.expression(0); //get left side expression ( ex. 1 &lt; 5  -&gt; it would mean get &quot;1&quot;)</span><br><span class="line">        EnkelParser.ExpressionContext rightExpressionCtx = ctx.expression(1); //get right side expression</span><br><span class="line">        Expression leftExpression = leftExpressionCtx.accept(this); //get mapped (to POJO) left expression using this visitor</span><br><span class="line">        //rightExpression might be null! Example: &apos;if (x)&apos; checks x for nullity. The solution for this case is to assign integer 0 to the rightExpr </span><br><span class="line">        Expression rightExpression = rightExpressionCtx != null ? rightExpressionCtx.accept(this) : new Value(BultInType.INT,&quot;0&quot;); </span><br><span class="line">        CompareSign cmpSign = ctx.cmp != null ? CompareSign.fromString(ctx.cmp.getText()) : CompareSign.NOT_EQUAL; //if there is no cmp sign use &apos;!=0&apos; by default</span><br><span class="line">        return new ConditionalExpression(leftExpression, rightExpression, cmpSign);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CompareSign 是一个对象，表示比较符号（==，&lt; 等）。它保存了字节码指令（IF_ICMPEQ, IF_ICMPLE 等）。</p><h2 id="3-生成字节码"><a href="#3-生成字节码" class="headerlink" title="3. 生成字节码"></a>3. 生成字节码</h2><p>JVM 中有一些指令来做分支判断：</p><ul><li>if&lt;eq,ne,lt,le,gt,ge&gt; - 操作数栈出栈，和 0 比较</li><li>if_icmp_&lt;eq,ne,lt,le,gt,ge&gt; - 从栈上出栈两个值，比较是否相等</li><li>if[non]null - 检查空值 </li></ul><p>本节中我们只是用第二个指令。 该指令的操作数是分支的偏移量（遇到 if 后，需要执行的指令）。</p><h2 id="4-生成条件表达式"><a href="#4-生成条件表达式" class="headerlink" title="4. 生成条件表达式"></a>4. 生成条件表达式</h2><p>ifcmpne（比较两个值不相等）会在 ConditionalExpression 中首次被用到。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public void generate(ConditionalExpression conditionalExpression) &#123;</span><br><span class="line">    Expression leftExpression = conditionalExpression.getLeftExpression();</span><br><span class="line">    Expression rightExpression = conditionalExpression.getRightExpression();</span><br><span class="line">    Type type = leftExpression.getType();</span><br><span class="line">    if(type != rightExpression.getType()) &#123;</span><br><span class="line">        throw new ComparisonBetweenDiferentTypesException(leftExpression, rightExpression); //not yet supported</span><br><span class="line">    &#125;</span><br><span class="line">    leftExpression.accept(this);</span><br><span class="line">    rightExpression.accept(this);</span><br><span class="line">    CompareSign compareSign = conditionalExpression.getCompareSign();</span><br><span class="line">    Label trueLabel = new Label(); //represents an adress in code (to which jump if condition is met)</span><br><span class="line">    Label endLabel = new Label();</span><br><span class="line">    methodVisitor.visitJumpInsn(compareSign.getOpcode(),trueLabel);</span><br><span class="line">    methodVisitor.visitInsn(Opcodes.ICONST_0);</span><br><span class="line">    methodVisitor.visitJumpInsn(Opcodes.GOTO, endLabel);</span><br><span class="line">    methodVisitor.visitLabel(trueLabel);</span><br><span class="line">    methodVisitor.visitInsn(Opcodes.ICONST_1);</span><br><span class="line">    methodVisitor.visitLabel(endLabel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareSign.getOpcode()</code> 返回条件表达式的字节码指令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum CompareSign &#123;</span><br><span class="line">    EQUAL(&quot;==&quot;, Opcodes.IF_ICMPEQ),</span><br><span class="line">    NOT_EQUAL(&quot;!=&quot;, Opcodes.IF_ICMPNE),</span><br><span class="line">    LESS(&quot;&lt;&quot;,Opcodes.IF_ICMPLT),</span><br><span class="line">    GREATER(&quot;&gt;&quot;,Opcodes.IF_ICMPGT),</span><br><span class="line">    LESS_OR_EQUAL(&quot;&lt;=&quot;,Opcodes.IF_ICMPLE),</span><br><span class="line">    GRATER_OR_EQAL(&quot;&gt;=&quot;,Opcodes.IF_ICMPGE);</span><br><span class="line">    //getters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>条件指令的操作数是分支的偏移量。<code>compareSign.getOpcode()</code> 从操作数栈上出栈两个值，比较。</p><p>如果表达式是真，那么指令跳到 trueLabel 处继续执行。trueLabel 指令包含 <code>methodVisitor.visitInsn(Opcodes.ICONST_1);</code>，即把值 1 入栈。</p><p>如果表达式假，不会发生指令跳转。接下来的指令是 ICONST_0， 把值 0 入栈。然后 GOTO （非分支指令）跳到 endLabel 处。这样，表达式为真的时候执行的语句块则会略过不执行。</p><p>上述过程保证了真值表达式只可能是 1 或者 0（入栈的整数）。</p><p>这样 conditonalExpression 可以用作表达式。可以赋值给变量，作为参数传递给函数，打印或者当做返回值。</p><h2 id="5-生成-IfStatement"><a href="#5-生成-IfStatement" class="headerlink" title="5. 生成 IfStatement"></a>5. 生成 IfStatement</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void generate(IfStatement ifStatement) &#123;</span><br><span class="line">        Expression condition = ifStatement.getCondition();</span><br><span class="line">        condition.accept(expressionGenrator);</span><br><span class="line">        Label trueLabel = new Label();</span><br><span class="line">        Label endLabel = new Label();</span><br><span class="line">        methodVisitor.visitJumpInsn(Opcodes.IFNE,trueLabel);</span><br><span class="line">        ifStatement.getFalseStatement().accept(this);</span><br><span class="line">        methodVisitor.visitJumpInsn(Opcodes.GOTO,endLabel);</span><br><span class="line">        methodVisitor.visitLabel(trueLabel);</span><br><span class="line">        ifStatement.getTrueStatement().accept(this);</span><br><span class="line">        methodVisitor.visitLabel(endLabel);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>IfStatement 依赖了 ConditionalExpression 用到的思想，它保证了最终会在入栈 0 或者 1。</p><p>这样简化了对表达式的求值（<code>condition.accept(expressionGenrator);</code>）并且检查值是否入栈（<code>condition.accept(expressionGenrator);</code>）。如果不等于 0 ，跳到 trueLable 处执行(<code>ifStatement.getTrueStatement().accept(this);</code>), 否则继续执行 falseStatement, 并且跳到（GOTO）endLabel 处。</p><h2 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h2><p>假设有如何 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SumCalculator &#123;</span><br><span class="line"></span><br><span class="line">    main(string[] args) &#123;</span><br><span class="line">        var expected = 8</span><br><span class="line">        var actual = sum(3,5)</span><br><span class="line"></span><br><span class="line">        if( actual == expected ) &#123;</span><br><span class="line">            print &quot;test passed&quot;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print &quot;test failed&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum (int x ,int y) &#123;</span><br><span class="line">        x+y</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成后的字节码如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c  SumCalculator</span><br><span class="line">public class SumCalculator &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        8</span><br><span class="line">       2: istore_1          //store 8 in local variable 1 (expected)</span><br><span class="line">       3: bipush        3   //push 3 </span><br><span class="line">       5: bipush        5   //push 5</span><br><span class="line">       7: invokestatic  #10 //Call metod sum (5,3)</span><br><span class="line">      10: istore_2          //store the result in variable 2 (actual)</span><br><span class="line">      11: iload_2           //push the value from variable 2 (actual=8) onto the stack</span><br><span class="line">      12: iload_1           //push the value from variable 1 (expected=8) onto the stack</span><br><span class="line">      13: if_icmpeq     20  //compare two top values from stack (8 == 8) if false jump to label 20</span><br><span class="line">      16: iconst_0          //push 0 onto the stack</span><br><span class="line">      17: goto          21  //go to label 21 (skip true section)</span><br><span class="line">      20: iconst_1          //label 21 (true section) -&gt; push 1 onto the stack</span><br><span class="line">      21: ifne          35  //if the value on the stack (result of comparison 8==8 != 0 jump to label 35</span><br><span class="line">      24: getstatic     #16  // get static Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      27: ldc           #18  // push String test failed</span><br><span class="line">      29: invokevirtual #23  // call print Method &quot;Ljava/io/PrintStream;&quot;.println:(Ljava/lang/String;)V</span><br><span class="line">      32: goto          43   //jump to end (skip true section)</span><br><span class="line">      35: getstatic     #16                 </span><br><span class="line">      38: ldc           #25  // String test passed</span><br><span class="line">      40: invokevirtual #23                 </span><br><span class="line">      43: return</span><br><span class="line"></span><br><span class="line">  public static int sum(int, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: iadd</span><br><span class="line">       3: ireturn</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 9</title>
      <link href="/2018/08/24/Creating-JVM-Language-Part-9/"/>
      <url>/2018/08/24/Creating-JVM-Language-Part-9/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 9 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-9" target="_blank" rel="noopener">Github</a></p><h2 id="1-语法规则改动"><a href="#1-语法规则改动" class="headerlink" title="1. 语法规则改动"></a>1. 语法规则改动</h2><p>我们新建一个规则 “returnStatement”。<br>那为什么不叫 “returnExpression” 呢？毕竟表达式总是返回值的，语句没有返回值么?<br>这听起来有点绕口，但是返回值并不总是返回一个值。在 Java 中，代码 <code>int x = return 5;</code> 没有意义， 在 Enkel 中也是如此。换句话说，表达式总可以给一个变量赋值。这就是为什么返回是语句，而不是表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">statement : variableDeclaration</span><br><span class="line">           //other statements rules</span><br><span class="line">           | returnStatement ;</span><br><span class="line"></span><br><span class="line">variableDeclaration : VARIABLE name EQUALS expression;</span><br><span class="line">printStatement : PRINT expression ;</span><br><span class="line">returnStatement : &apos;return&apos; #RETURNVOID</span><br><span class="line">                | (&apos;return&apos;)? expression #RETURNWITHVALUE;</span><br></pre></td></tr></table></figure><p>返回语句有两种形式：</p><ul><li>RETURNVOID - 用在没有返回值的方法中。return 关键字是必须的，后面不需要表达式</li><li>RETURNWITHVALUE - 用在有返回值的方法中。return 关键字不是必须的，但是需要一个表达式</li></ul><p>因此，方法可以显示或者隐士的返回一个值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SomeClass &#123;</span><br><span class="line">    fun1 &#123;</span><br><span class="line">       return  //explicitly return from void method</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fun2 &#123;</span><br><span class="line">        //implicitly return from void method</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int fun2 &#123;</span><br><span class="line">        return 1  //explicitly return &quot;1&quot; from int method</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int fun3 &#123;</span><br><span class="line">        1  //implicitly return &quot;1&quot; from int method</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码经过解析后，AST 图形展示如下：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_9/parse_tree.gif" alt=""></p><p>我们可以看到，AST 中并没有处理 fun2 中的隐士返回值。这是因为方法是空的语句块，匹配空的语句块作为返回值并不是一个好的想法。因此，确实的返回语句会在字节码生成阶段手动添加。</p><h2 id="2-匹配-Antlr-上下文对象"><a href="#2-匹配-Antlr-上下文对象" class="headerlink" title="2. 匹配 Antlr 上下文对象"></a>2. 匹配 Antlr 上下文对象</h2><p>经过解析后，返回语句从 antlr 的上下文对象转换成 POJO 类 <code>ReturnStatement</code> 。这一步的目的是仅匹配字节码生成需要的数据，而不是直接从 antlr 生成的对象中取数据，这样会让代码看起来很丑陋。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class StatementVisitor extends EnkelBaseVisitor&lt;Statement&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //other stuff</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Statement visitRETURNVOID(@NotNull EnkelParser.RETURNVOIDContext ctx) &#123;</span><br><span class="line">        return new ReturnStatement(new EmptyExpression(BultInType.VOID));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Statement visitRETURNWITHVALUE(@NotNull EnkelParser.RETURNWITHVALUEContext ctx) &#123;</span><br><span class="line">        Expression expression = ctx.expression().accept(expressionVisitor); </span><br><span class="line">        return new ReturnStatement(expression);</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-检测隐士空返回"><a href="#3-检测隐士空返回" class="headerlink" title="3. 检测隐士空返回"></a>3. 检测隐士空返回</h2><p>假设方法中包含有隐士返回，在解析阶段是不会生成返回语句的，这就是为什么我们需要检测这种情景，并且在字节码生成阶段手动添加返回语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MethodGenerator &#123;</span><br><span class="line">    //other stuff</span><br><span class="line">    private void appendReturnIfNotExists(Function function, Block block,StatementGenerator statementScopeGenrator) &#123;</span><br><span class="line">        Statement lastStatement = block.getStatements().get(block.getStatements().size() - 1);</span><br><span class="line">        boolean isLastStatementReturn = lastStatement instanceof ReturnStatement;</span><br><span class="line">        if(!isLastStatementReturn) &#123;</span><br><span class="line">            EmptyExpression emptyExpression = new EmptyExpression(function.getReturnType());</span><br><span class="line">            ReturnStatement returnStatement = new ReturnStatement(emptyExpression);</span><br><span class="line">            returnStatement.accept(statementScopeGenrator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述方法检测方法最后的语句是不是返回语句，如果不是就添加返回指令。</p><h2 id="4-生成字节码"><a href="#4-生成字节码" class="headerlink" title="4. 生成字节码"></a>4. 生成字节码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class StatementGenerator &#123;</span><br><span class="line">    //oher stuff</span><br><span class="line">    public void generate(ReturnStatement returnStatement) &#123;</span><br><span class="line">        Expression expression = returnStatement.getExpression();</span><br><span class="line">        Type type = expression.getType();</span><br><span class="line">        expression.accept(expressionGenrator); //generate bytecode for expression itself (puts the value of expression onto the stack)</span><br><span class="line">        if(type == BultInType.VOID) &#123;</span><br><span class="line">            methodVisitor.visitInsn(Opcodes.RETURN);</span><br><span class="line">        &#125; else if (type == BultInType.INT) &#123;</span><br><span class="line">            methodVisitor.visitInsn(Opcodes.IRETURN);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，<code>return 5</code> 会经过如下阶段：</p><ul><li>从返回语句中获得表达式（这里是5，类型是值）</li><li>生成 5 对应的字节码。（expression.accept(expressionGenerator) 调用 ExpressionGenerator.generate(Value value)）</li><li>字节码生成阶段，会生成一个新的值 5 并压入操作数栈</li><li>IRETURN 指令将操作数栈栈顶数据出栈，并返回</li></ul><p>字节码表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bipush        5</span><br><span class="line">ireturn</span><br></pre></td></tr></table></figure></p><h2 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h2><p>假设我们又如下 Enkel 代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SumCalculator &#123;</span><br><span class="line"></span><br><span class="line">    void main(string[] args) &#123;</span><br><span class="line">        print sum(5,2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum (int x ,int y) &#123;</span><br><span class="line">        x+y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>生成的字节码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c  SumCalculator</span><br><span class="line">public class SumCalculator &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #12                 //get static field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: bipush        5</span><br><span class="line">       5: bipush        2</span><br><span class="line">       7: invokestatic  #16                 // call method sum (with the values on operand stack 5,2)</span><br><span class="line">      10: invokevirtual #21                 // call method println (with the value on stack - the result of method sum)</span><br><span class="line">      13: return                           //return</span><br><span class="line"></span><br><span class="line">  public static int sum(int, int);</span><br><span class="line">    Code:</span><br><span class="line">       0: iload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: iadd</span><br><span class="line">       3: ireturn //return the value from operand stack (result of iadd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 8</title>
      <link href="/2018/08/24/Creating-JVM-Language-Part-8/"/>
      <url>/2018/08/24/Creating-JVM-Language-Part-8/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 8 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-8" target="_blank" rel="noopener">Github</a></p><h2 id="1-语法改动"><a href="#1-语法改动" class="headerlink" title="1. 语法改动"></a>1. 语法改动</h2><p>基本的算数操作包括：</p><ul><li>+</li><li>-</li><li>*</li><li>/</li></ul><p>本节需要改动的语法规则仅是 “expression”。<br>表达式通俗来讲就是求值（方法调用，值，变量引用等）。<br>而语句会做一些操作，但不一定会产生值，例如 if 语句。<br>既然算数操作总是返回值，那么他就是表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">expression : varReference #VARREFERENCE</span><br><span class="line">           | value        #VALUE</span><br><span class="line">           | functionCall #FUNCALL</span><br><span class="line">           |  &apos;(&apos;expression &apos;*&apos; expression&apos;)&apos; #MULTIPLY</span><br><span class="line">           | expression &apos;*&apos; expression  #MULTIPLY</span><br><span class="line">           | &apos;(&apos; expression &apos;/&apos; expression &apos;)&apos; #DIVIDE</span><br><span class="line">           | expression &apos;/&apos; expression #DIVIDE</span><br><span class="line">           | &apos;(&apos; expression &apos;+&apos; expression &apos;)&apos; #ADD</span><br><span class="line">           | expression &apos;+&apos; expression #ADD</span><br><span class="line">           | &apos;(&apos; expression &apos;-&apos; expression &apos;)&apos; #SUBSTRACT</span><br><span class="line">           | expression &apos;-&apos; expression #SUBSTRACT</span><br><span class="line">           ;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>#</code> 标号表示为当前规则创建可选的回调。Antlr 会在 <code>ENkelVisotor</code> 中生成诸如 <code>visitDIVIDE(), visitADD()</code> 的接口。</li><li>规则的定义先后顺序至关重要。假设我们有如下表达式： <code>1 +*3</code>。这样会产生歧义，因为有很多解释：<code>1+2=3 3*3=9</code> 或者 <code>2*3=6 6+1=7</code>。Antlr 通过选择第一个符合的规则来解决歧义。因此，规则定义的顺序会影响到算数表达式的执行顺序。</li><li><code>()</code> 里的表达式优先级高于普通优先级。因此诸如 <code>(1+2)*3</code> 的表达式能被正确解析和执行。</li></ul><h2 id="2-匹配-Antlr-上下文对象"><a href="#2-匹配-Antlr-上下文对象" class="headerlink" title="2. 匹配 Antlr 上下文对象"></a>2. 匹配 Antlr 上下文对象</h2><p>Antlr 为每一条规则生成新的类和回调。为每个操作新建一个类是个不错的选择，这样会让字节码的生成看起来更加干净：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class ExpressionVisitor extends EnkelBaseVisitor&lt;Expression&gt; &#123;</span><br><span class="line"></span><br><span class="line">    //some other methods (visitFunctionCall, visitVaraibleReference etc)</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Expression visitADD(@NotNull EnkelParser.ADDContext ctx) &#123;</span><br><span class="line">        EnkelParser.ExpressionContext leftExpression = ctx.expression(0);</span><br><span class="line">        EnkelParser.ExpressionContext rightExpression = ctx.expression(1);</span><br><span class="line"></span><br><span class="line">        Expression leftExpress = leftExpression.accept(this);</span><br><span class="line">        Expression rightExpress = rightExpression.accept(this);</span><br><span class="line"></span><br><span class="line">        return new Addition(leftExpress, rightExpress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Expression visitMULTIPLY(@NotNull EnkelParser.MULTIPLYContext ctx) &#123;</span><br><span class="line">        EnkelParser.ExpressionContext leftExpression = ctx.expression(0);</span><br><span class="line">        EnkelParser.ExpressionContext rightExpression = ctx.expression(1);</span><br><span class="line"></span><br><span class="line">        Expression leftExpress = leftExpression.accept(this);</span><br><span class="line">        Expression rightExpress = rightExpression.accept(this);</span><br><span class="line"></span><br><span class="line">        return new Multiplication(leftExpress, rightExpress);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //Division</span><br><span class="line">    </span><br><span class="line">    //Substration</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Multiplcation,Addition,Division 和 Substraction 都是不可变的 POJO，存储了操作符的左侧和右侧的表达式（1+2，其中1 是左侧,2 是右侧）。</p><h2 id="3-生成字节码"><a href="#3-生成字节码" class="headerlink" title="3. 生成字节码"></a>3. 生成字节码</h2><p>当 Enkel 代码被解析和匹配到表达式对象后，我们可以进行下一步，字节码生成了。这里我们还需要创建另一个类，类方法中的参数是表达式的类型，方法体内生成对应的字节码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class ExpressionGenrator &#123;</span><br><span class="line"></span><br><span class="line">    //other methods (generateFunctionCall, generateVariableReference etc.)</span><br><span class="line"></span><br><span class="line">    public void generate(Addition expression) &#123;</span><br><span class="line">        evaluateArthimeticComponents(expression);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.IADD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Substraction expression) &#123;</span><br><span class="line">        evaluateArthimeticComponents(expression);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.ISUB);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Multiplication expression) &#123;</span><br><span class="line">        evaluateArthimeticComponents(expression);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.IMUL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Division expression) &#123;</span><br><span class="line">        evaluateArthimeticComponents(expression);</span><br><span class="line">        methodVisitor.visitInsn(Opcodes.IDIV);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void evaluateArthimeticComponents(ArthimeticExpression expression) &#123;</span><br><span class="line">            Expression leftExpression = expression.getLeftExpression();</span><br><span class="line">            Expression rightExpression = expression.getRightExpression();</span><br><span class="line">            leftExpression.accept(this);</span><br><span class="line">            rightExpression.accept(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算数表达式中用到的字节码非常通俗易懂。字节码指令将两个操作数从出栈，执行计算，结果入栈。</p><ul><li>iadd - 整数相加。</li><li>isub - 整数相减</li><li>imul - 整数相乘</li><li>idiv - 整数相除</li></ul><p>其他数据类型的指令以此类推。</p><h2 id="4-结果"><a href="#4-结果" class="headerlink" title="4. 结果"></a>4. 结果</h2><p>假设我们有如下 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">First &#123;</span><br><span class="line">        void main (string[] args) &#123;</span><br><span class="line">            var result = 2+3*4</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后的字节码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c First</span><br><span class="line">public class First &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        2 //push 2 onto the stack</span><br><span class="line">       2: bipush        3 //push 3 onto the stack</span><br><span class="line">       4: bipush        4 //push 4 onto the stack</span><br><span class="line">       6: imul          //take two top values from the stack (3 and 4) and multiply them. Put result on stack</span><br><span class="line">       7: iadd          //take two top values from stack (2 and 12-result of imul) and add em. Put result back on stack</span><br><span class="line">       8: istore_1     //store top value from the stack into local variable at index 1 in local variable array of the curennt frame</span><br><span class="line">       9: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 7</title>
      <link href="/2018/08/23/Creating-JVM-Language-Part-7/"/>
      <url>/2018/08/23/Creating-JVM-Language-Part-7/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 7 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-7" target="_blank" rel="noopener">Github</a></p><h2 id="1-方法"><a href="#1-方法" class="headerlink" title="1. 方法"></a>1. 方法</h2><p>到目前为止，我们可以在 Enkel 中声明类和变量，但是他们都处于同一个全局作用域中。下一步，我们需要支持方法。</p><p>我们的目标是可以处理如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">First &#123;</span><br><span class="line">    void main (string[] args) &#123;</span><br><span class="line">        var x = 25</span><br><span class="line">        metoda(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void metoda (int param) &#123;</span><br><span class="line">        print param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-作用域"><a href="#2-作用域" class="headerlink" title="2. 作用域"></a>2. 作用域</h2><p>为了可以访问其他的函数或者变量，他们需要在同一个作用域下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Scope &#123;</span><br><span class="line">    private List&lt;Identifier&gt; identifiers; //think of it as a variables for now</span><br><span class="line">    private List&lt;FunctionSignature&gt; functionSignatures;</span><br><span class="line">    private final MetaData metaData;  //currently stores only class name</span><br><span class="line"></span><br><span class="line">    public Scope(MetaData metaData) &#123;</span><br><span class="line">        identifiers = new ArrayList&lt;&gt;();</span><br><span class="line">        functionSignatures = new ArrayList&lt;&gt;();</span><br><span class="line">        this.metaData = metaData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Scope(Scope scope) &#123;</span><br><span class="line">        metaData = scope.metaData;</span><br><span class="line">        identifiers = Lists.newArrayList(scope.identifiers);</span><br><span class="line">        functionSignatures = Lists.newArrayList(scope.functionSignatures);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //some other methods that expose data to the outside</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象 <code>scope</code> 是在类创建的时候被创建的，然后传递给下一层级(方法）。下一层级拷贝并且添加其他的选项。</p><h2 id="3-签名"><a href="#3-签名" class="headerlink" title="3. 签名"></a>3. 签名</h2><p>函数调用的时候，需要提供函数的一些额外信息。假设有如下的伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1() &#123;</span><br><span class="line">    f2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f2()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析后如下图所示：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/b4slc.jpg" alt=""></p><p>节点的访问顺序如下：</p><ul><li>Root</li><li>函数 f1</li><li>对函数 f2 的调用//错误，此时 f2 还没有定义</li><li>函数 f2</li></ul><p>因此，当函数调用发生时，函数的定义可能没有访问到，f1 解析的时候并没有 f2 的信息。<br>为了解决这个问题，我们必须访问所有函数的定义并且把函数的签名存储到作用域中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class ClassVisitor extends EnkelBaseVisitor&lt;ClassDeclaration&gt; &#123;</span><br><span class="line"></span><br><span class="line"> private Scope scope;</span><br><span class="line"></span><br><span class="line"> @Override</span><br><span class="line"> public ClassDeclaration visitClassDeclaration(@NotNull EnkelParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">     String name = ctx.className().getText();</span><br><span class="line">     FunctionSignatureVisitor functionSignatureVisitor = new FunctionSignatureVisitor();</span><br><span class="line">     List&lt;EnkelParser.FunctionContext&gt; methodsCtx = ctx.classBody().function();</span><br><span class="line">     MetaData metaData = new MetaData(ctx.className().getText());</span><br><span class="line">     scope = new Scope(metaData);</span><br><span class="line">     //First find all signatures</span><br><span class="line">     List&lt;FunctionSignature&gt; signatures = methodsCtx.stream()</span><br><span class="line">             .map(method -&gt; method.functionDeclaration().accept(functionSignatureVisitor))</span><br><span class="line">             .peek(scope::addSignature)</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">     //Once the signatures are found start parsing methods</span><br><span class="line">     List&lt;Function&gt; methods = methodsCtx.stream()</span><br><span class="line">             .map(method -&gt; method.accept(new FunctionVisitor(scope)))</span><br><span class="line">             .collect(Collectors.toList());</span><br><span class="line">     return new ClassDeclaration(name, methods);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Invokestatic"><a href="#4-Invokestatic" class="headerlink" title="4. Invokestatic"></a>4. Invokestatic</h2><p>当所有相关的信息都被正确解析后，接下来需要生成字节码了。当前 Enkele 还没有实现对象的创建，因此方法的调用先使用 static 的方式来调用。</p><p><code>int access = Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC;</code></p><p>静态方法的调用对应的字节码指令是 <code>invokestatic</code>， 需要两个参数：</p><ul><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.2" target="_blank" rel="noopener">Filed Descriptor</a> - 方法持有类的描述  (Ljava/io/PrintStream;)</li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3.3" target="_blank" rel="noopener">Method Descriptor</a> - 例如：println:(I)V</li></ul><p>操作数栈中的会执行出栈操作，并传递给方法调用（类型和个数必须和方法描述一致）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class MethodGenerator &#123;</span><br><span class="line">    private final ClassWriter classWriter;</span><br><span class="line"></span><br><span class="line">    public MethodGenerator(ClassWriter classWriter) &#123;</span><br><span class="line">        this.classWriter = classWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void generate(Function function) &#123;</span><br><span class="line">        Scope scope = function.getScope();</span><br><span class="line">        String name = function.getName();</span><br><span class="line">        String description = DescriptorFactory.getMethodDescriptor(function);</span><br><span class="line">        Collection&lt;Statement&gt; instructions = function.getStatements();</span><br><span class="line">        int access = Opcodes.ACC_PUBLIC + Opcodes.ACC_STATIC;</span><br><span class="line">        MethodVisitor mv = classWriter.visitMethod(access, name, description, null, null);</span><br><span class="line">        mv.visitCode();</span><br><span class="line">        StatementGenerator statementScopeGenrator = new StatementGenerator(mv);</span><br><span class="line">        instructions.forEach(instr -&gt; statementScopeGenrator.generate(instr,scope));</span><br><span class="line">        mv.visitInsn(Opcodes.RETURN);</span><br><span class="line">        mv.visitMaxs(-1,-1); //asm autmatically calculate those but the call is required</span><br><span class="line">        mv.visitEnd();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-效果"><a href="#5-效果" class="headerlink" title="5. 效果"></a>5. 效果</h2><p>如下 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">First &#123;</span><br><span class="line">    void main (string[] args) &#123;</span><br><span class="line">        var x = 25</span><br><span class="line">        metoda(x)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void metoda (int param) &#123;</span><br><span class="line">        print param</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会被编译成如下所示的字节码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ javap -c First</span><br><span class="line">public class First &#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    Code:</span><br><span class="line">       0: bipush        25 //push value 25 onto the stack</span><br><span class="line">       2: istore_0         //store value from stack into variable at index 0</span><br><span class="line">       3: iload_0          //load variable at index onto the stack</span><br><span class="line">       5: invokestatic  #10 //call metod Method metoda:(I)V  </span><br><span class="line">       8: return</span><br><span class="line"></span><br><span class="line">  public static void metoda(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: getstatic     #16                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">       3: iload_0</span><br><span class="line">       4: invokevirtual #20                 // Method &quot;Ljava/io/PrintStream;&quot;.println:(I)V</span><br><span class="line">       7: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 6</title>
      <link href="/2018/08/22/Creating-JVM-Language-Part-6/"/>
      <url>/2018/08/22/Creating-JVM-Language-Part-6/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第 6 篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-6" target="_blank" rel="noopener">Github</a></p><h2 id="Visitor-vs-listener"><a href="#Visitor-vs-listener" class="headerlink" title="Visitor vs listener"></a>Visitor vs listener</h2><p>之前的章节中，我都使用了 listener 来实现 Enkel 的解析器。Antlr 提供了另一种方式– Visitor。我们需要在命令里加 <code>-visiotor</code> 来显示的开启。</p><p>我专门写了<a href="http://jakubdziworski.github.io/java/2016/04/01/antlr_visitor_vs_listener.html" target="_blank" rel="noopener">一篇博客</a>，来探讨究竟哪种方式更适合 Enkel 的编译器设计和实现。</p><p>下面我们简要列举 Visitor 模式带来的好处：</p><ul><li>更少的代码</li><li>更少的 BUG。无需把解析的结果保存到变量里。</li></ul><p>对比代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//Listener</span><br><span class="line">class ClassListener extends EnkelBaseListener&lt;ClassDeclaration&gt; &#123;</span><br><span class="line"></span><br><span class="line">        private Class parsedClass;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void enterClassDeclaration(@NotNull EnkelParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">            String className = ctx.className().getText();</span><br><span class="line">            //do some other stuff</span><br><span class="line">            parsedClass = new Class(className,methods);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Class getParsedClass() &#123;</span><br><span class="line">            return parsedClass;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//Visitor</span><br><span class="line">public class ClassVisitor extends EnkelBaseVisitor&lt;ClassDeclaration&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ClassDeclaration visitClassDeclaration(@NotNull EnkelParser.ClassDeclarationContext ctx) &#123;</span><br><span class="line">        String name = ctx.className().getText();</span><br><span class="line">        //do some other stuff</span><br><span class="line">        return new ClassDeclaration(name, methods);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此来看，切换到 Visitor 模式是一个正确的选择。</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 5</title>
      <link href="/2018/08/18/Creating-JVM-Language-Part-5/"/>
      <url>/2018/08/18/Creating-JVM-Language-Part-5/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第五篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p> <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-5" target="_blank" rel="noopener">Github</a></p><h2 id="解析规则的更改"><a href="#解析规则的更改" class="headerlink" title="解析规则的更改"></a>解析规则的更改</h2><p>上一节中，我们定义了 Enkel 语言的特性。本节中我们来实现 “类”。</p><p>原来的解析规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compilationUnit : ( variable | print )* EOF;</span><br><span class="line">variable : VARIABLE ID EQUALS value;</span><br></pre></td></tr></table></figure></p><p>变更后的规则：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compilationUnit : classDeclaration EOF ; //root rule - our code consist consist only of variables and prints (see definition below)</span><br><span class="line">classDeclaration : className &apos;&#123;&apos; classBody &apos;&#125;&apos; ;</span><br><span class="line">className : ID ;</span><br><span class="line">classBody :  ( variable | print )* ;</span><br></pre></td></tr></table></figure><ul><li>一个文件有且仅有一个类声明</li><li>类声明包含类型和大括号中的类主体</li><li>类主体包含变量和打印语句（如我们之前的定义）</li></ul><p>更改后的语法规则可视化如下所示：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_5/class_parse_tree.gif" alt=""></p><h2 id="Compiler-更改"><a href="#Compiler-更改" class="headerlink" title="Compiler 更改"></a>Compiler 更改</h2><p>主要改变是需要把原来的代码从 <code>ByteCodeGenerator</code> 移动到 <code>CompilationUnit</code> 和 <code>ClassDeclaration</code>，逻辑如下:</p><ol><li>Compiler 从 <code>SyntaxParseTreeTraverser</code> 获得 AST</li><li><p>Compiler 实例化 <code>CompilationUnit</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//Compiler.java</span><br><span class="line">final CompilationUnit compilationUnit = new SyntaxTreeTraverser().getCompilationUnit(fileAbsolutePath);</span><br><span class="line">//Check getCompilationUnit() method body on github</span><br></pre></td></tr></table></figure></li><li><p><code>CompilationUnit</code> 负责实例化 <code>ClassDeclaration</code>（需要传递类名和指令序列）</p></li><li><code>ClassDeclaration</code> 处理类定义指令，以及循环处理 <code>ClassScopeInstructions</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//ClassDeclaration.java</span><br><span class="line">MethodVisitor mv = classWriter.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;, null, null);</span><br><span class="line">instructions.forEach(classScopeInstruction -&gt; classScopeInstruction.apply(mv));</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://jakubdziworski.github.io/assets/media/enkel_5/uml.png" alt=""></p><p>另外一点改动是: 输出的 .class 文件名字以类名为依据，而不是以 .enk 文件名字为依据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String className = compilationUnit.getClassName();</span><br><span class="line">String fileName = className + &quot;.class&quot;;</span><br><span class="line">OutputStream os = new FileOutputStream(fileName);</span><br><span class="line">IOUtils.write(byteCode,os);</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 的 Unsafe 类</title>
      <link href="/2018/07/29/sun-misc-unsafe/"/>
      <url>/2018/07/29/sun-misc-unsafe/</url>
      <content type="html"><![CDATA[<p>本文主要介绍一下 JDK 里的核弹之 <code>sun.misc.Unsage</code> 类。<br><a id="more"></a></p><h2 id="0-概述"><a href="#0-概述" class="headerlink" title="0. 概述"></a>0. 概述</h2><p>本文主要介绍一下 JDK 里的核弹之 <code>sun.misc.Unsage</code> 类。这个类提供了更加底层的操作，主要是服务于 Java 的核心类库。普通用户一般情况下，并不会直接用到该类。</p><h2 id="1-获取-Unsafe-实例"><a href="#1-获取-Unsafe-实例" class="headerlink" title="1. 获取 Unsafe 实例"></a>1. 获取 <code>Unsafe</code> 实例</h2><p><code>Unsafe</code> 提供了 <code>getUnsafe</code> 方法，代码实例如下所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Unsafe.getUnsafe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，会有如下报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.SecurityException: Unsafe</span><br><span class="line">  at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)</span><br><span class="line">  at com.bendcap.java.jvm.unsafe.Main.main(Main.java:13)</span><br></pre></td></tr></table></figure><p>这是因为 <code>Unsafe</code> 类主要是 JDK 内部使用，并不提供给普通用户调用，也就是其名字所暗示的那样，这些操作不安全。</p><p>但是我们仍让可以通过反射获取到实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">createUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; unsafeClass = Class.forName(<span class="string">"sun.misc.Unsafe"</span>);</span><br><span class="line">            Field field = unsafeClass.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            Unsafe unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> unsafe;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="2-不调用构造方法方法创建对象"><a href="#2-不调用构造方法方法创建对象" class="headerlink" title="2. 不调用构造方法方法创建对象"></a>2. 不调用构造方法方法创建对象</h2><p>我们知道，JVM 在创建对象实例的时候会调用默认或者有参构造方法，在字节码中对应 <code>init</code> 方法，那如何实例话一个对象，而不调用 <code>init</code> 方法呢? 答案就是 <code>Unsafe</code>。</p><p>假设我们有一个类 <code>Person</code>:</p><figure class="highlight plain"><figcaption><span>class Person &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;Person static code block&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person() &#123;</span><br><span class="line">        System.out.println(&quot;Person default constructor&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们可以通过 <code>Unsafe</code> 在内存中直接创建 <code>Person</code> 的实例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Person <span class="title">instancePerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            person = (Person) createUnsafe().allocateInstance(Person.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        person.setName(<span class="string">"Unsafer"</span>);</span><br><span class="line">        <span class="keyword">return</span> person;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>Unsafe</code> 只会分配 <code>Person</code> 对应的内存空间，而不触发构造函数。<br><em>注</em>: Class 文件中的 <code>clinit</code> 仍然会执行。</p><p>举一个生产实例。<code>Gson</code> 中反序列化的时候，<code>ReflectiveTypeAdapterFactory</code> 类负责通过反射设置字段值，其中在或许反序列化对应的 Class 实例的时候就用到了 <code>Unsafe</code>, 关键代码摘抄如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeAllocator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UnsafeAllocator <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// try JVM</span></span><br><span class="line">    <span class="comment">// public class Unsafe &#123;</span></span><br><span class="line">    <span class="comment">//   public Object allocateInstance(Class&lt;?&gt; type);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; unsafeClass = Class.forName(<span class="string">"sun.misc.Unsafe"</span>);</span><br><span class="line">      Field f = unsafeClass.getDeclaredField(<span class="string">"theUnsafe"</span>);</span><br><span class="line">      f.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">      <span class="keyword">final</span> Object unsafe = f.get(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">final</span> Method allocateInstance = unsafeClass.getMethod(<span class="string">"allocateInstance"</span>, Class.class);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> UnsafeAllocator() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; c)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">          assertInstantiable(c);</span><br><span class="line">          <span class="keyword">return</span> (T) allocateInstance.invoke(unsafe, c);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// give up</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnsafeAllocator() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">newInstance</span><span class="params">(Class&lt;T&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Cannot allocate "</span> + c);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-改变私有字段"><a href="#3-改变私有字段" class="headerlink" title="3.改变私有字段"></a>3.改变私有字段</h2><p>假设我们有如下类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class SecretHolder &#123;</span><br><span class="line">    private int SECRET_VALUE = 0;</span><br><span class="line"></span><br><span class="line">    public boolean secretValueDisclosed() &#123;</span><br><span class="line">        return SECRET_VALUE == 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们通过 <code>Unsafe</code> 来改变私有属性 <code>SECRET_VALUE</code> 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SecretHolder secretHolder = <span class="keyword">new</span> SecretHolder();</span><br><span class="line">       Field field = <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           field = secretHolder.getClass().getDeclaredField(<span class="string">"SECRET_VALUE"</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       Unsafe unsafe = createUnsafe();</span><br><span class="line">       unsafe.putInt(secretHolder, unsafe.objectFieldOffset(field), <span class="number">1</span>);</span><br><span class="line">       <span class="keyword">return</span> secretHolder.secretValueDisclosed();</span><br></pre></td></tr></table></figure><p>我们通过 <code>unsafe.putInt</code> 直接改变了 <code>SecretHolder</code> 的私有属性的值。一旦我们通过反射获得了类的私有属性字段，我们就可以直接操作它的值。</p><h2 id="4-抛出异常而不会触发-CE-Checked-Exception"><a href="#4-抛出异常而不会触发-CE-Checked-Exception" class="headerlink" title="4. 抛出异常而不会触发 CE(Checked Exception)"></a>4. 抛出异常而不会触发 <code>CE</code>(Checked Exception)</h2><p>通过 <code>unsafe.throwExceptio</code> 创建的异常不会被编译器检查，方法的调用者也不需要处理异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throwException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Unsafe unsafe = createUnsafe();</span><br><span class="line">       unsafe.throwException(<span class="keyword">new</span> IOException());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="5-堆外内存"><a href="#5-堆外内存" class="headerlink" title="5. 堆外内存"></a>5. 堆外内存</h2><p>Java 中对象分配一般是在 <code>Heap</code> 中进行的（例外是 TLAB等），当应用内存不足的时候，可以通过触发 GC 进行垃圾回收，但是如果有大量对象存活到永久代，并且仍然引用可达，那么我们就需要堆外内存（Off-Heap Memory）来缓解频繁 GC 造成的压力。</p><p><code>Unsafe.allocateMemory</code> 给了我们在直接内存中分配对象的能力，这块内存是非堆内存，因此，不会受到 GC 的频繁分析和干扰。</p><p>虽然这样可以缓解大量对象占用内存对 GC 和 JVM 造成的压力，这也就需要我们手动管理内存，因此，在合适的事后我们需要手动调用 <code>freeMemory</code> 来释放内存。</p><p>举例，我们在内存中分配字节数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OffHeapArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> BYTE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> address;</span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OffHeapArray</span><span class="params">(<span class="keyword">long</span> size, Unsafe unsafe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.unsafe = unsafe;</span><br><span class="line">        address = unsafe.allocateMemory(size * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> i, <span class="keyword">byte</span> value)</span> </span>&#123;</span><br><span class="line">        unsafe.putByte(address + i * BYTE, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">long</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getByte(address + idx * BYTE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">freeMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        unsafe.freeMemory(address);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以通过如何代码分配内存空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> SUPER_SIZE = (<span class="keyword">long</span>) Integer.MAX_VALUE * <span class="number">2</span>;</span><br><span class="line">OffHeapArray array = <span class="keyword">new</span> OffHeapArray(SUPER_SIZE);</span><br></pre></td></tr></table></figure><p>测试用例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOffHeap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">           offHeapArray.set((<span class="keyword">long</span>) Integer.MAX_VALUE + i, (<span class="keyword">byte</span>) <span class="number">3</span>);</span><br><span class="line">           sum += offHeapArray.get((<span class="keyword">long</span>) Integer.MAX_VALUE + i);</span><br><span class="line">       &#125;</span><br><span class="line">       assertEquals(offHeapArray.size(), SUPER_SIZE);</span><br><span class="line">       assertEquals(sum, <span class="number">300</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一定不要忘了，在合适的时候释放内存。</p><h2 id="6-CAS（CompareAndSwap）"><a href="#6-CAS（CompareAndSwap）" class="headerlink" title="6. CAS（CompareAndSwap）"></a>6. CAS（CompareAndSwap）</h2><p><code>java.concurrent</code> 包中提供了大量并发相关的操作，例如 <code>AtomicInteger</code> 就用了 <code>Unsafe.compareAndSwap</code> 操作来实现 <code>lock-free</code> 的操作，保证更好的性能。</p><p>假设我们做一个累加器，开启 1000 个线程，每个线程循环累加 10_000 次。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CASCounter</span><span class="params">(Unsafe unsafe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.unsafe = unsafe;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            offset = unsafe.objectFieldOffset(CASCounter.class.getDeclaredField(<span class="string">"counter"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> before = counter;</span><br><span class="line">        <span class="keyword">while</span> (!unsafe.compareAndSwapLong(<span class="keyword">this</span>, offset, before, before + <span class="number">1</span>)) &#123;</span><br><span class="line">            before = counter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCounter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><em>注</em>： <code>counter</code> 需要声明为 <code>volatile</code> 来保证对所有线程可见（参考 Java 内存模型以及指令集重排）</p><p>这里的关键是 <code>increment</code> 方法，我们在 <code>while</code> 循环里不断尝试调用 <code>compareAndSwapLong</code>，检查在我们方法内部累加的同事，<code>counter</code> 的值有没有被其他线程改变。如有没有，就提交更改，如果不一致，那么继续尝试提交更改。</p><p>测试用例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCAS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> NUM_OF_THREADS = <span class="number">1_000</span>;</span><br><span class="line">       <span class="keyword">int</span> NUM_OF_INCREMENTS = <span class="number">10_000</span>;</span><br><span class="line">       ExecutorService service = Executors.newFixedThreadPool(NUM_OF_THREADS);</span><br><span class="line"></span><br><span class="line">       IntStream.rangeClosed(<span class="number">0</span>, NUM_OF_THREADS - <span class="number">1</span>)</span><br><span class="line">               .forEach(i -&gt; service.submit(</span><br><span class="line">                       () -&gt; IntStream</span><br><span class="line">                               .rangeClosed(<span class="number">0</span>, NUM_OF_INCREMENTS - <span class="number">1</span>)</span><br><span class="line">                               .forEach(j -&gt; casCounter.increment())</span><br><span class="line">                       )</span><br><span class="line">               );</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">5_000L</span>);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       assertEquals(NUM_OF_INCREMENTS * NUM_OF_THREADS, casCounter.getCounter());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>由于累加操作需要计算时间，我们这里暴力休眠 5s 后再验证结果。</p><h2 id="7-Park-Unpark"><a href="#7-Park-Unpark" class="headerlink" title="7. Park/Unpark"></a>7. Park/Unpark</h2><p><code>Park/Unpark</code> 主要是被 JVM 用来做线程的上下文切换。当线程需要等待某个条件的时候，JVM 会调用 <code>park</code> 来阻塞该线程。</p><p>这和 <code>Object.await</code> 非常类似，但是 <code>park</code> 是操作系统调用，因此，在某些操作系统架构上，这会带来更好的性能。</p><p>当线程阻塞后，需要再次执行， JVM 会调用 <code>unpark</code> 方法使得该线程变得活跃。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>俗话说，<em>面试造核弹，工作拧螺丝</em>，虽然 <code>Unsafe</code> 看起来不会被用到，但是能帮助我们更好的理解 JVM 以及 JDK 中 <code>lock-free</code> 的实现。还有一点就是 <code>Off-Heap Memory</code>, 如果做服务端开发中确实遇到了大内存对象并且常驻内存的情况，堆外分配不失为一个好的策略来减轻 GC 以及 GC 带来的系统负担（可参见 R 大在阿里 JVM 中所做的一些优化），与之对应的就是 <code>TLAB</code>(thread local allocation buffer)，后面有机会再整理。</p>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JDK </tag>
            
            <tag> Unsafe </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>独立型 JVM 和寄生型 JVM 比较</title>
      <link href="/2018/07/28/jvm-classification/"/>
      <url>/2018/07/28/jvm-classification/</url>
      <content type="html"><![CDATA[<p>本文系 R 大在 2013 年在 ITEYE 高级语言虚拟机论坛的开坑之作，即便是现在看来还是有很大的启发意义，于是整理了一下。<br><a id="more"></a></p><h2 id="独立型-JVM"><a href="#独立型-JVM" class="headerlink" title="独立型 JVM"></a>独立型 JVM</h2><p>有些项目是明确希望最终能得到一个可以独立运行的JVM，那就不得不做出一些取舍：必须要有编译到机器码的编译器，并且要能直接跟外部代码打交道（以实现JNI之类的功能）。Jikes RVM及衍生版MRP、Maxine VM、joeq、JNode都是此类。下文把这种叫做“独立型”。 </p><h2 id="寄生型-JVM"><a href="#寄生型-JVM" class="headerlink" title="寄生型 JVM"></a>寄生型 JVM</h2><p>也有些项目纯粹是玩票的，像Sun在90年代末做的JavaInJava，或者在其之后MIT做的Rivet JVM，或者最近一些的M-JVM。它们只能在已有的JVM（称为宿主JVM）上运行。这样的JVM可以只用Java写的解释器来实现。下文把这种叫做“寄生型”。 </p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><table><thead><tr><th></th><th>独立型</th><th>寄生型</th></tr></thead><tbody><tr><td>GC</td><td>独立型meta-JVM需要一些magic来穿透Java的语义而直接访问内存内容，以便实现GC。</td><td>寄生型则好办，直接交由低下的宿主JVM来解决即可</td></tr><tr><td>对象模型</td><td>独立型meta-JVM对对象模型、对象布局都有完全控制。</td><td>寄生型则必须用Java对象来模拟Java对象。直观的模拟方式可以用Map系或者数组（Object[]）系。</td></tr><tr><td>类加载器</td><td>独立型可以完全自己实现类加载器。</td><td>寄生型通常会混合着使用自己实现的类加载器和宿主JVM的类加载器。</td></tr><tr><td>JNI</td><td>独立型需要自己实现JNI但受限制较少。</td><td>寄生型通常要借助宿主JVM来实现JNI，这样就迫使Java对象在通过JNI跑到native code之前，要先从寄生JVM的对象模型转换为宿主JVM的对象模型。</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="http://hllvm.group.iteye.com/group/topic/39043" target="_blank" rel="noopener">ITEYE 原链</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 分类 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>macOS High Sierra 10.13.2 上安装 Bochs</title>
      <link href="/2018/07/03/Install-Bochs-on-macOS-High-Sierra/"/>
      <url>/2018/07/03/Install-Bochs-on-macOS-High-Sierra/</url>
      <content type="html"><![CDATA[<p>macOS High Sierra 10.13.2 上安装 Bochs<br><a id="more"></a></p><h1 id="macOS-High-Sierra-10-13-2-上安装-Bochs"><a href="#macOS-High-Sierra-10-13-2-上安装-Bochs" class="headerlink" title="macOS High Sierra 10.13.2 上安装 Bochs"></a>macOS High Sierra 10.13.2 上安装 Bochs</h1><p>简而言之 <a href="http://bochs.sourceforge.net/" target="_blank" rel="noopener">Bochs</a> 是一个 IA-32 (x86) PC 模拟器。更多信息参考官网介绍。这里记录下安装过程以及其中遇到的问题。</p><h2 id="Homebrew-安装"><a href="#Homebrew-安装" class="headerlink" title="Homebrew 安装"></a>Homebrew 安装</h2><p>参考 <a href="https://github.com/Shirk/homebrew-bochs。" target="_blank" rel="noopener">https://github.com/Shirk/homebrew-bochs。</a></p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p><a href="https://sourceforge.net/projects/bochs/files/bochs/2.6.8" target="_blank" rel="noopener">2.6.8</a> 下载后解压。</p><h3 id="sdl"><a href="#sdl" class="headerlink" title="sdl"></a>sdl</h3><p>需要安装依赖 sdl。<br><code>brew install sdl</code></p><h3 id="configure"><a href="#configure" class="headerlink" title="configure"></a>configure</h3><p>在源码根目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">./configure --enable-ne2000 \</span><br><span class="line">            --enable-all-optimizations \</span><br><span class="line">            --enable-cpu-level=6 \</span><br><span class="line">            --enable-x86-64 \</span><br><span class="line">            --enable-vmx=2 \</span><br><span class="line">            --enable-pci \</span><br><span class="line">            --enable-usb \</span><br><span class="line">            --enable-usb-ohci \</span><br><span class="line">            --enable-e1000 \</span><br><span class="line">            --enable-debugger \</span><br><span class="line">            --enable-disasm \</span><br><span class="line">            --disable-debugger-gui \</span><br><span class="line">            --with-sdl \</span><br><span class="line">            --prefix=/opt/bochs</span><br></pre></td></tr></table></figure></p><h3 id="make"><a href="#make" class="headerlink" title="make"></a>make</h3><p>make 会得到如下错误提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cdrom_osx.cc:194:18: error: assigning to &apos;char *&apos; from incompatible type &apos;const char *&apos;</span><br><span class="line">  if ((devname = strrchr(devpath, &apos;/&apos;)) != NULL) &#123;</span><br></pre></td></tr></table></figure></p><p>幸好有 <a href="https://raw.githubusercontent.com/Homebrew/formula-patches/e9b520dd4c/bochs/xcode9.patch" target="_blank" rel="noopener">patch</a>。</p><p>修改后，执行 make。</p><h3 id="make-install"><a href="#make-install" class="headerlink" title="make install"></a>make install</h3><p><code>sudo make install</code></p><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export BXSHARE=&quot;/opt/bochs/share/bochs&quot;</span><br><span class="line">export PATH=&quot;$PATH:/opt/bochs/bin&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.nswebfrog.com/2017/02/03/config-bochs/" target="_blank" rel="noopener">https://blog.nswebfrog.com/2017/02/03/config-bochs/</a></p>]]></content>
      
      
        <tags>
            
            <tag> Bochs </tag>
            
            <tag> 安装 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 4</title>
      <link href="/2018/06/10/Creating-JVM-Language-Part-4/"/>
      <url>/2018/06/10/Creating-JVM-Language-Part-4/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第四篇。<br>原文中的代码和原文有不一致的地方均在新的<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">代码仓库</a>中更正过，建议参考新的代码仓库。</p></blockquote><a id="more"></a><p>上一节中，我们已经实现了 Enkel 语言的原型实现。本章我们需要定义好 Enkel 的语言特性。</p><p>众所周知，Java 中有很多冗余的部分。Java 尽可能的避免让你犯错，因此我们有时候需要写大量的重复性代码。</p><p>我们的目标是让 Enkel 尽可能的简单。简单带来的缺点显而易见，但是对于实现语言原型，是个不错的选择。</p><p>下面我们定义了 Enkel 语言的和新特性。</p><table><thead><tr><th>特点</th><th>示例</th></tr></thead><tbody><tr><td>一个文件代表一个类，无需使用 class 关键字来声明类名，只需要在 import后提供类型</td><td>Car {}</td></tr><tr><td>继承</td><td>Car : Vehicle {}</td></tr><tr><td>可选的自动生成 getters,setters,builder,equals,hashcode</td><td>Car(getters,setters,hashequals,builder) : Vehicle {}</td></tr><tr><td>类型推断</td><td>var x = 5</td></tr><tr><td>默认参数</td><td>fun createPoint(Int x=0, Int y = 0)</td></tr><tr><td>可选参数命名，这在函数调用指明参数的时候非常有用</td><td>createPoint(5,0) createPoint(x-&gt;5,y-&gt;0) createPoint(y-&gt;0,x-&gt;5)</td></tr><tr><td>函数也是对象（函数是一等公民）</td><td>const f = (Int x=0, Int y=0) =&gt; x*y</td></tr><tr><td>没有静态方法</td><td><del>static void x()</del></td></tr><tr><td>默认用 == 替代 equals</td><td>object1 == object2</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JavaScript 方法调用和 this 解析</title>
      <link href="/2018/05/07/Context-of-JavaScript-Calling/"/>
      <url>/2018/05/07/Context-of-JavaScript-Calling/</url>
      <content type="html"><![CDATA[<p><a href="http://yehudakatz.com/2011/08/11/understanding-javascript-function-invocation-and-this/" target="_blank" rel="noopener">原文地址</a></p><p>一直以来，我对 JavaScript 的方法调用存有困惑。尤其是很多人一直抱怨，方法中的 <code>this</code> 语义含糊不清。</p><p>在我看来，只要理解了方法调用原语就可以解开这些疑惑，其他所有的方法调用都可以认为是原语上的语法糖。事实上，ECMAScript 规范就是这么做的，这篇文章可以认为是简化版的规范说明，基本思路是一样的。</p><a id="more"></a><h2 id="原语"><a href="#原语" class="headerlink" title="原语"></a>原语</h2><p>方法调用的原语是 <code>call</code> 这个方法：</p><ol><li>接受一个参数列表 <code>argList</code></li><li>第一个参数是 <code>thisValue</code></li><li>触发函数调用，设置 <code>thisValue</code> 为 <code>this</code>, 剩余的参数作参数列表</li></ol><p>举例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello.call(<span class="string">"Yehuda"</span>, <span class="string">"world"</span>) <span class="comment">//=&gt; Yehuda says hello world</span></span><br></pre></td></tr></table></figure><p>你会发现，<code>this</code> 的值被设置为 <code>Yehuda</code>, 只有一个参数 <code>thing</code> 被设置为 “world” 。这就是 JavaScript 的方法调用原语。可以认为其他的方法调用都是这种形式的语法糖。</p><p><em>注</em>：在 <a href="http://es5.github.com/#x15.3.4.4" target="_blank" rel="noopener">ES5规范</a> 中，<code>call</code> 被当做更底层的原语，但是仅仅是一层比较浅的封装，因此这里做了简化。</p><h2 id="简单的方法调用"><a href="#简单的方法调用" class="headerlink" title="简单的方法调用"></a>简单的方法调用</h2><p>如果一直使用 <code>call</code> 来做函数调用，会显得很麻烦，因此 JavaScript 允许我们使用 <code>hello(&quot;world&quot;)</code> 这种语法去做函数调用，JavaScript 会帮我们去糖：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this:</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to:</span></span><br><span class="line">hello.call(<span class="built_in">window</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>在 ECMAScript 5 中，如果使用 <code>strict mode</code>，行为会有所改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this:</span></span><br><span class="line">hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to:</span></span><br><span class="line">hello.call(<span class="literal">undefined</span>, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>更简短的描述可以认为 <code>fn(...args)</code> 和 <code>fn.call(window [ES5-strict: undefined], ...args)</code> 的调用是一样的。</p><p>内部函数的声明也是这样，诸如 <code>(function() {})()</code> 的函数声明和 <code>(function() {}).call(window [ES5-strict: undefined)</code> 也相同。</p><p><em>注</em>：事实上，这里有一点不是很准确，ECMAScript 5 规范中声明了 <code>undefined</code> 一定会被传递，但是当方法在非严格模式中被调用的时候，应该把 <code>thisValue</code> 的值设置为全局变量，这可以让严格模式下的调用者避免破坏已存在的非严格模式的库。</p><h2 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h2><p>另一种常见的函数调用形式就是作为成员函数被调用，<code>person.hello()</code>。这种情景下，函数调用会变成如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Brendan Eich"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this:</span></span><br><span class="line">person.hello(<span class="string">"world"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// desugars to this:</span></span><br><span class="line">person.hello.call(person, <span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>请注意，<code>hello</code> 函数作为谁的成员并不重要，我们生命 <code>hello</code> 为单独的函数，下面看一下如何动态绑定对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> + <span class="string">" says hello "</span> + thing);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person = &#123; <span class="attr">name</span>: <span class="string">"Brendan Eich"</span> &#125;</span><br><span class="line">person.hello = hello;</span><br><span class="line"></span><br><span class="line">person.hello(<span class="string">"world"</span>) <span class="comment">// still desugars to person.hello.call(person, "world")</span></span><br><span class="line"></span><br><span class="line">hello(<span class="string">"world"</span>) <span class="comment">// "[object DOMWindow]world"</span></span><br></pre></td></tr></table></figure><p>注意，<code>hello</code> 并不会一直持有 <code>this</code> 的绑定，他总是根据调用者的调用形式，在调用的时候动态设定的。</p><h2 id="使用-Function-prototype-bind"><a href="#使用-Function-prototype-bind" class="headerlink" title="使用 Function.prototype.bind"></a>使用 <code>Function.prototype.bind</code></h2><p>有时候绑定 <code>this</code> 为固定值是非常常见和方便的，因此有些时候人们会利用闭包来实现 <code>this</code> 值的绑定。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Brendan Eich"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says hello "</span> + thing);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundHello = <span class="function"><span class="keyword">function</span>(<span class="params">thing</span>) </span>&#123; <span class="keyword">return</span> person.hello.call(person, thing); &#125;</span><br><span class="line"></span><br><span class="line">boundHello(<span class="string">"world"</span>);</span><br></pre></td></tr></table></figure><p>尽管 <code>boundHello</code> 仍然被去糖，变成 <code>boundHello.call(window, &quot;world&quot;)</code> 形式的调用，我们曲线救国，重新绑定了 <code>this</code> 的值为我们想要绑定的对象。</p><p>我们可以微调一下，让这种调用更通用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bind = <span class="function"><span class="keyword">function</span>(<span class="params">func, thisValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> func.apply(thisValue, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> boundHello = bind(person.hello, person);</span><br><span class="line">boundHello(<span class="string">"world"</span>) <span class="comment">// "Brendan Eich says hello world"</span></span><br></pre></td></tr></table></figure><p>为了理解这种调用，需要注意两点：</p><ol><li><code>arguments</code> 是一个数组，代表了函数调用的所有参数</li><li><code>apply</code> 和 <code>call</code> 基本一致，除了他接受的参数是数组形式，而不是需要一个个的列举出来</li></ol><p><code>bind</code> 函数返回了一个新的函数。当函数被调用的时候，<code>bind</code> 仅仅是触发了参数中传递进来的函数，<code>this</code> 的值也是通过第二个参数重新绑定。</p><p>既然这种形式得到大家的共识，因此 ES5 在 <code>Function</code> 对象上添加了 <code>bind</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> boundHello = person.hello.bind(person);</span><br><span class="line">boundHello(<span class="string">"world"</span>) <span class="comment">// "Brendan Eich says hello world"</span></span><br></pre></td></tr></table></figure><p>当把一个纯函数作为 callback 传递的时候是非常有用的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Alex Russell"</span>,</span><br><span class="line">  hello: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">" says hello world"</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#some-div"</span>).click(person.hello.bind(person));</span><br><span class="line"></span><br><span class="line"><span class="comment">// when the div is clicked, "Alex Russell says hello world" is printed</span></span><br></pre></td></tr></table></figure><p>这种形式并不优雅，因此 TC39（一个委员会致力于下一代 ECMAScript 的标准）一直在研究一种方案，技能向前兼容，又足够优雅。</p><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>jQuery 大量使用了匿名回调，内部调用了 <code>call</code> 来设置 callback 的 <code>this</code> 为更有用的值。例如，jQuery 触发 callback 的时候把设置了事件监听的元素作为 <code>this</code> 的值，而不是不经过处理，直接把 <code>window</code> 作为 <code>this</code> 的值。</p><p>这非常有用，因为匿名回调函数里的默认 <code>this</code> 的值通常并没有什么用，对于 JavaScript 的初学者来说，<code>this</code> 的值经常容易造成困难并且很难解释清楚。</p><p>如果你掌握了把方法调用去糖为 <code>func.call(thisValue, ...args)</code> 的基本法则，你将会如鱼得水。</p><h2 id="PS-偷梁换柱"><a href="#PS-偷梁换柱" class="headerlink" title="PS: 偷梁换柱"></a>PS: 偷梁换柱</h2><p>在一些地方，我简化了 JavaScript 规范中的繁文缛节。比如，我把 <code>func.call</code> 称作原语。实际上，规范中, 对于 <code>func.call</code> 和 <code>[obj.]func()</code> 有原语的概念（<code>[[Call]]</code>）。</p><p>然而，我们可以看一下 <code>func.call</code> 的定义：</p><ol><li>如果 <code>IsCallable(func)</code> 为 false, 抛出 <code>TypeError</code> 异常</li><li><code>argList</code> 设置为空列表</li><li>如果方法被调用的参数多余一个，从 <code>arg1</code> 开始，从左至右的顺序组成 <code>argList</code></li><li>返回 func 内部的 <code>[[Call]]</code> 的调用结果，把 <code>thisArg</code> 作为 <code>this</code> 的值，<code>argList</code> 作为参数列表</li></ol><p>显而易见，这个定义其实就是 JavaScript 对原语 <code>[[Call]]</code> 的绑定。</p><p>如果你浏览一下函数触发的定义，前面几步是设置 <code>thisValue</code> 和 <code>argList</code>, 最后一步是返回 func 内部的 <code>[[Call]]</code> 的调用结果，把 <code>thisArg</code> 作为 <code>this</code> 的值，<code>argList</code> 作为参数列表。</p><p>一旦 <code>thisValue</code> 和 <code>argList</code> 确定下来，含义都是一样的。</p><p>我把 <code>call</code> 称作原语其实是偷梁换柱，正如前面所讲，这和规范中的描述其实都是一致的。</p><p>PS：有一些情况我并没有覆盖到，比如使用 <code>with</code> 关键字的情况。</p>]]></content>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> this </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 3</title>
      <link href="/2018/05/01/Creating-JVM-Language-Part-3/"/>
      <url>/2018/05/01/Creating-JVM-Language-Part-3/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第三篇。</p></blockquote><a id="more"></a><h2 id="0-自顶向下的方式"><a href="#0-自顶向下的方式" class="headerlink" title="0. 自顶向下的方式"></a>0. 自顶向下的方式</h2><p>开发一门语言不是短期任务，我将以自顶向下的视角来开发。为了避免陷入每个模块的实现细节，我准备先宏观的描述每个模块，然后在每个迭代，我将慢慢加入更多的细节加以完善。</p><h2 id="1-代码"><a href="#1-代码" class="headerlink" title="1. 代码"></a>1. 代码</h2><p>作者原来的代码是 <code>Maven</code> 工程，译者这里改成了 <code>Gradle</code>（译者熟悉 <code>Gradle</code> 并且觉得更为优雅），目录结构以及包名也做了些许改动，但是逻辑上都是等价的。<br>读者可根据喜好，自行选择。</p><ul><li>译者的 <code>Gradle</code> 工程<a href="https://github.com/KevinOfNeu/Enkel" target="_blank" rel="noopener">地址</a></li><li>作者的 <code>Maven</code> 工程<a href="https://github.com/JakubDziworski/Enkel-JVM-language" target="_blank" rel="noopener">地址</a></li></ul><p><em>约定</em>：每个章节，涉及到代码变更，译者都会打 tag, tag 的名字和章节名字保持统一，比如，当前章节的代码版本是 <code>PART-3</code>，以此类推。</p><h2 id="2-功能"><a href="#2-功能" class="headerlink" title="2. 功能"></a>2. 功能</h2><p>本章节我将为 <code>Enkel</code> 添加如下功能特性：</p><ul><li>声明 <code>int</code> 或者 <code>string</code> 类型的变量</li><li>打印变量</li><li>简单的类型推断</li></ul><p>示例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//first.enk</span><br><span class="line"> var five=5</span><br><span class="line"> print five   </span><br><span class="line"> var dupa=&quot;dupa&quot;  </span><br><span class="line"> print dupa</span><br></pre></td></tr></table></figure></p><p>下面我们将实现能最简化版本，让上述代码可以运行在 <code>JVM</code> 上。</p><h2 id="3-用-ANTLR4-实现词法分析-amp-语法分析"><a href="#3-用-ANTLR4-实现词法分析-amp-语法分析" class="headerlink" title="3. 用 ANTLR4 实现词法分析&amp;语法分析"></a>3. 用 ANTLR4 实现词法分析&amp;语法分析</h2><p>从零开始实现一个词法分析器是重复性很强的劳动。这里使用 Antlr （Antlr 4）实现。你需要做的只是创建一个语法规则文件，Antlr 帮你生成可以遍历 AST 的基础代码。</p><p>本章语法规则文件为 Enkel.g4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//header</span><br><span class="line">grammar Enkel;</span><br><span class="line"></span><br><span class="line">@header &#123;</span><br><span class="line">package com.bendcap.enkel.antlr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//RULES</span><br><span class="line">compilationUnit : ( variable | print )* EOF; //root rule - our code consist consist only of variables and prints (see definition below)</span><br><span class="line">variable : VARIABLE ID EQUALS value; //requires VAR token followed by ID token followed by EQUALS TOKEN ...</span><br><span class="line">print : PRINT ID ; //print statement must consist of &apos;print&apos; keyword and ID</span><br><span class="line">value : op=NUMBER</span><br><span class="line">      | op=STRING ; //must be NUMBER or STRING value (defined below)</span><br><span class="line"></span><br><span class="line">//TOKENS</span><br><span class="line">VARIABLE : &apos;var&apos; ; //VARIABLE TOKEN must match exactly &apos;var&apos;</span><br><span class="line">PRINT : &apos;print&apos; ;</span><br><span class="line">EQUALS : &apos;=&apos; ; //must be &apos;=&apos;</span><br><span class="line">NUMBER : [0-9]+ ; //must consist only of digits</span><br><span class="line">STRING : &apos;&quot;&apos;.*&apos;&quot;&apos; ; //must be anything in qutoes</span><br><span class="line">ID : [a-zA-Z0-9]+ ; //must be any alphanumeric value</span><br><span class="line">WS: [ \t\n\r]+ -&gt; skip ; //special TOKEN for skipping whitespaces</span><br></pre></td></tr></table></figure></p><p>语法规则很简单，需要注意的是：</p><ul><li>EOF - 文件结束</li><li>语法规则中的空格和 <code>;</code> 是必须</li></ul><p>Enkel.g4 定义好后，可以运行命令来生成后续需要的 Java 代码：<br><code>antlr Enkel.g4</code></p><p>命令执行完后，会生成四个类：</p><ul><li>EnkelLexer - 包含 Token 相关信息</li><li>EnkelParser - 解析器，Token 信息以及一些内部类来做规则解析</li><li>EnkelListener - 当访问语法节点的时候，提供回调函数</li><li>EnkelBaseListener - 空的 EnkelListener 实现</li></ul><p><em>译注</em>: 如果你使用 <code>Gradle</code> 工程的话，可以使用 <code>./gradlew :antlr:generateGrammarSource</code> 来生成上述代码。</p><p>其中最重要的是 EnkelBaseListener，这个类提供了遍历 AST 时的回调函数，我们不用关心词法分析和语法分析，Antlr 帮助我们屏蔽了这个过程。</p><p>我们可以使用 <code>javac *.java</code> 编译上述代码，来测试我们的规则正确性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ export CLASSPATH=&quot;.:$ANTLR_JAR_LOCATION:$CLASSPATH&quot;</span><br><span class="line">$ java org.antlr.v4.gui.TestRig Enkel compilationUnit -gui</span><br><span class="line">var x=5</span><br><span class="line">print x</span><br><span class="line">var dupa=&quot;dupa&quot;</span><br><span class="line">print dupa</span><br><span class="line">ctrl+D //end of file</span><br></pre></td></tr></table></figure><p>上述输入会生成如下的图形化树形结构（抽象语法书的图形化展示）：<br><img src="http://jakubdziworski.github.io/assets/media/enkel_3/parse_tree.png" alt=""></p><p><em>译者注</em>：可以使用 IDEA 插件 ANTLR 4 grammar plugin 来实现同样的效果，或许更方便一些。<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/0u37x.jpg" alt=""></p><h2 id="4-遍历语法树"><a href="#4-遍历语法树" class="headerlink" title="4. 遍历语法树"></a>4. 遍历语法树</h2><p><code>EnkelListener</code> 提供了我们遍历语法树的办法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">EnkelTreeWalkListener.java</span><br><span class="line">public class EnkelTreeWalkListener extends EnkelBaseListener &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Instruction&gt; instructionsQueue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    Map&lt;String, Variable&gt; variables = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public Queue&lt;Instruction&gt; getInstructionsQueue() &#123;</span><br><span class="line">        return instructionsQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exitVariable(@NotNull EnkelParser.VariableContext ctx) &#123;</span><br><span class="line">        final TerminalNode varName = ctx.ID();</span><br><span class="line">        final EnkelParser.ValueContext varValue = ctx.value();</span><br><span class="line">        final int varType = varValue.getStart().getType();</span><br><span class="line">        final int varIndex = variables.size();</span><br><span class="line">        final String varTextValue = varValue.getText();</span><br><span class="line">        Variable var = new Variable(varIndex, varType, varTextValue);</span><br><span class="line">        variables.put(varName.getText(), var);</span><br><span class="line">        instructionsQueue.add(new VariableDeclaration(var));</span><br><span class="line">        logVariableDeclarationStatementFound(varName, varValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exitPrint(@NotNull EnkelParser.PrintContext ctx) &#123;</span><br><span class="line">        final TerminalNode varName = ctx.ID();</span><br><span class="line">        final boolean printedVarNotDeclared = !variables.containsKey(varName.getText());</span><br><span class="line">        if (printedVarNotDeclared) &#123;</span><br><span class="line">            final String erroFormat = &quot;ERROR: WTF? You are trying to print var &apos;%s&apos; which has not been declared!!!.&quot;;</span><br><span class="line">            System.err.printf(erroFormat, varName.getText());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        final Variable variable = variables.get(varName.getText());</span><br><span class="line">        instructionsQueue.add(new PrintVariable(variable));</span><br><span class="line">        logPrintStatementFound(varName, variable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void logVariableDeclarationStatementFound(TerminalNode varName, EnkelParser.ValueContext varValue) &#123;</span><br><span class="line">        final int line = varName.getSymbol().getLine();</span><br><span class="line">        final String format = &quot;OK: You declared variable named &apos;%s&apos; with value of &apos;%s&apos; at line &apos;%s&apos;.\n&quot;;</span><br><span class="line">        System.out.printf(format, varName, varValue.getText(), line);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void logPrintStatementFound(TerminalNode varName, Variable variable) &#123;</span><br><span class="line">        final int line = varName.getSymbol().getLine();</span><br><span class="line">        final String format = &quot;OK: You instructed to print variable &apos;%s&apos; which has value of &apos;%s&apos; at line &apos;%s&apos;.&apos;\n&quot;;</span><br><span class="line">        System.out.printf(format, variable.getId(), variable.getValue(), line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getInstructionsQueue</code> 按照代码顺序返回指令。</p><p>下面我们可以注册 Listener:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">SyntaxTreeTraverser.java</span><br><span class="line">public class SyntaxTreeTraverser &#123;</span><br><span class="line">    public Queue&lt;Instruction&gt; getInstructions(String fileAbsolutePath) throws IOException &#123;</span><br><span class="line">        CharStream charStream = new ANTLRFileStream(fileAbsolutePath); //fileAbsolutePath - file containing first enk code file</span><br><span class="line"></span><br><span class="line">        EnkelLexer lexer = new EnkelLexer(charStream);  //create lexer (pass enk file to it)</span><br><span class="line"></span><br><span class="line">        CommonTokenStream tokenStream = new CommonTokenStream(lexer);</span><br><span class="line"></span><br><span class="line">        EnkelParser parser = new EnkelParser(tokenStream);</span><br><span class="line"></span><br><span class="line">        EnkelTreeWalkListener listener = new EnkelTreeWalkListener(); //EnkelTreeWalkListener extends EnkelBaseLitener - handles parse tree visiting events</span><br><span class="line">        BaseErrorListener errorListener = new EnkelTreeWalkErrorListener(); //EnkelTreeWalkErrorListener - handles parse tree visiting error events</span><br><span class="line"></span><br><span class="line">        parser.addErrorListener(errorListener);</span><br><span class="line">        parser.addParseListener(listener);</span><br><span class="line">        parser.compilationUnit(); //compilation unit is root parser rule - start from it!</span><br><span class="line">        return listener.getInstructionsQueue();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我提供了另一个 Listener 来做异常处理:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EnkelTreeWalkErrorListener.java</span><br><span class="line">public class EnkelTreeWalkErrorListener extends BaseErrorListener &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void syntaxError(Recognizer&lt;?, ?&gt; recognizer, Object offendingSymbol, int line, int charPositionInLine, String msg, RecognitionException e) &#123;</span><br><span class="line">        final String errorFormat = &quot;You fucked up at line %d,char %d :(. Details:\n%s&quot;;</span><br><span class="line">        final String errorMsg = String.format(errorFormat, line, charPositionInLine, msg);</span><br><span class="line">        System.err.println(errorMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历语法树的 Listener 写完后，我们来测试一下。创建 <code>Compiler</code> 类作为入口，输入参数为我们 Enkel 语言的源文件路径。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//Compiler.java</span><br><span class="line">public class Compiler &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        new Compiler().compile(args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void compile(String[] args) throws Exception &#123;</span><br><span class="line">        //arguments validation skipped (check out full code on github)</span><br><span class="line">        final File enkelFile = new File(args[0]);</span><br><span class="line">        String fileName = enkelFile.getName();</span><br><span class="line">        String fileAbsolutePath = enkelFile.getAbsolutePath();</span><br><span class="line">        String className = StringUtils.remove(fileName, &quot;.enk&quot;);</span><br><span class="line">        final Queue&lt;Instruction&gt; instructionsQueue = new SyntaxTreeTraverser().getInstructions(fileAbsolutePath);</span><br><span class="line">        //TODO: generate bytecode based on instructions</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们既可以验证我们的 <code>*.enk</code> 文件了。目前的实现很简陋，但是可以做如下事情：</p><ul><li>允许用 <code>var x=1</code> 或者 <code>var x = &quot;anthing&quot;</code> 来声明变量</li><li>允许用 <code>print x</code> 打印变量</li><li>如果语法不符合规则，报错提示</li></ul><p>下面我们创建示例 <code>first.enk</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var five=5</span><br><span class="line">print five   </span><br><span class="line">var dupa=&quot;dupa&quot;  </span><br><span class="line">print dupa</span><br></pre></td></tr></table></figure></p><p>验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$java Compiler first.enk</span><br><span class="line"></span><br><span class="line">OK: You declared variable named &apos;five&apos; with value of &apos;5&apos; at line &apos;1&apos;.</span><br><span class="line">OK: You instructed to print variable &apos;0&apos; which has value of &apos;5&apos; at line &apos;2&apos;.&apos;</span><br><span class="line">OK: You declared variable named &apos;dupa&apos; with value of &apos;&quot;dupa&quot;&apos; at line &apos;3&apos;.</span><br><span class="line">OK: You instructed to print variable &apos;1&apos; which has value of &apos;&quot;dupa&quot;&apos; at line &apos;4&apos;.&apos;</span><br></pre></td></tr></table></figure><p>在 <code>first.enk</code> 最后添加一行 <code>void noFunctionsYet()</code>, 再次验证，<code>ErrorListener</code> 可以检测到错误，并且输出如下提示信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">You fucked up at line 1,char 0 :(. Details:</span><br><span class="line">mismatched input &apos;void&apos; expecting &#123;&lt;EOF&gt;, &apos;var&apos;, &apos;print&apos;&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-根据-instructions-queue-生成字节码"><a href="#5-根据-instructions-queue-生成字节码" class="headerlink" title="5. 根据 instructions queue 生成字节码"></a>5. 根据 <code>instructions queue</code> 生成字节码</h2><p>Java 的 class 文件的包含的指令描述参见 <a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">JSE 文档</a>。每一条指令包含如下结构：</p><ul><li>操作符（1 byte）- 指令</li><li>可选的操作数 - 指令的输入</li></ul><p>例： <code>iload 5</code> (0x15 5)，从局部变量加载数据，5 是局部变量数组的索引。<br>指令也可以实现操作数占的出栈入栈操作。<br>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iload 3</span><br><span class="line">iload 2</span><br><span class="line">iadd</span><br></pre></td></tr></table></figure><p>上述代码分别从局部变量数组中加载索引为 3 和 2 的变量，此时栈中包含两个数值，<code>iadd</code> 指令将栈中两个出栈，相加，然后结果再次入栈。</p><h2 id="6-ASM"><a href="#6-ASM" class="headerlink" title="6. ASM"></a>6. ASM</h2><p>这里选用 ASM 来操作 Java 字节码。这样可以不用关心非常底层的十六进制数字，你只需要知道指令的名字，ASM 会自动帮你处理剩下的事情。</p><h2 id="7-Instruction-interface"><a href="#7-Instruction-interface" class="headerlink" title="7. Instruction interface"></a>7. Instruction interface</h2><p><code>SyntaxTreeTraverser</code> 在遍历 AST 的时候会把指令按照顺序存储到 <code>instructionsQueue</code> 中。我们做一次抽象，定义接口 <code>Instruction</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Instruction &#123;</span><br><span class="line">    void apply(MethodVisitor methodVisitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的实现需要使用 <code>MethodVisitor</code>（ASM 提供的类） 来做一些代码生成的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//Compiler.java</span><br><span class="line">public void compile(String[] args) throws Exception &#123;</span><br><span class="line">    //some lines deleted -&gt; described in previous sections of this post</span><br><span class="line">    final Queue&lt;Instruction&gt; instructionsQueue = new SyntaxTreeTraverser().getInstructions(fileAbsolutePath);</span><br><span class="line">    final byte[] byteCode = new BytecodeGenerator().generateBytecode(instructionsQueue, className);</span><br><span class="line">    saveBytecodeToClassFile(fileName, byteCode);</span><br><span class="line">&#125;</span><br><span class="line">//ByteCodeGenerator.java</span><br><span class="line">public class BytecodeGenerator implements Opcodes &#123;</span><br><span class="line">    public byte[] generateBytecode(Queue&lt;Instruction&gt; instructionQueue, String name) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        ClassWriter cw = new ClassWriter(0);</span><br><span class="line">        MethodVisitor mv;</span><br><span class="line">               //version ,      acess,       name, signature, base class, interfaes</span><br><span class="line">        cw.visit(52, ACC_PUBLIC + ACC_SUPER, name, null, &quot;java/lang/Object&quot;, null);</span><br><span class="line">        &#123;</span><br><span class="line">            //declare static void main</span><br><span class="line">            mv = cw.visitMethod(ACC_PUBLIC + ACC_STATIC, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;, null, null);</span><br><span class="line">            final long localVariablesCount = instructionQueue.stream()</span><br><span class="line">                    .filter(instruction -&gt; instruction instanceof VariableDeclaration)</span><br><span class="line">                    .count();</span><br><span class="line">            final int maxStack = 100; //TODO - do that properly</span><br><span class="line"></span><br><span class="line">            //apply instructions generated from traversing parse tree!</span><br><span class="line">            for (Instruction instruction : instructionQueue) &#123;</span><br><span class="line">                instruction.apply(mv);</span><br><span class="line">            &#125;</span><br><span class="line">            mv.visitInsn(RETURN); //add return instruction</span><br><span class="line"></span><br><span class="line">            mv.visitMaxs(maxStack, (int) localVariablesCount); //set max stack and max local variables</span><br><span class="line">            mv.visitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">        cw.visitEnd();</span><br><span class="line"></span><br><span class="line">        return cw.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于目前 Enkel 不支持 方法，类以及作用域等概念，因为编译后的类直接继承自 <code>Object</code>, 包含一个 <code>main</code> 函数。<code>MethodVisitor</code> 需要提供局部变量以及栈的深度。然后我们遍历 <code>instructionQueue</code> 的每条指令来生成对应的字节码。目前我们只有两种指令（变量声明以及打印语句）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//VariableDeclaration.java</span><br><span class="line">public class VariableDeclaration implements Instruction,Opcodes &#123;</span><br><span class="line">    Variable variable;</span><br><span class="line"></span><br><span class="line">    public VariableDeclaration(Variable variable) &#123;</span><br><span class="line">        this.variable = variable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void apply(MethodVisitor mv) &#123;</span><br><span class="line">        final int type = variable.getType();</span><br><span class="line">        if(type == EnkelLexer.NUMBER) &#123;</span><br><span class="line">            int val = Integer.valueOf(variable.getValue());</span><br><span class="line">            mv.visitIntInsn(BIPUSH,val);</span><br><span class="line">            mv.visitVarInsn(ISTORE,variable.getId());</span><br><span class="line">        &#125; else if(type == EnkelLexer.STRING) &#123;</span><br><span class="line">            mv.visitLdcInsn(variable.getValue());</span><br><span class="line">            mv.visitVarInsn(ASTORE,variable.getId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里值得注意的是，我们已经添加了简单的类型推断。我们会根据变量的实际类型进行类型推断。针对不同类型我们需要调用 ASM 不同的方法：</p><ul><li>visitInsn - 第一个参数是操作符，第二个是操作数</li><li>BIPUSH - 把一个 byte(integer) 入栈</li><li>ISTORE - int 类型的值出栈，并存储到局部变量中,需要指定局部变量的索引</li><li>ASTORE - 和 ISTORE 功能类似，但是数据类型是索引</li></ul><p>打印语句的代码生成如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//PrintVariable.java</span><br><span class="line">public class PrintVariable implements Instruction, Opcodes &#123;</span><br><span class="line">    public PrintVariable(Variable variable) &#123;</span><br><span class="line">        this.variable = variable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void apply(MethodVisitor mv) &#123;</span><br><span class="line">        final int type = variable.getType();</span><br><span class="line">        final int id = variable.getId();</span><br><span class="line">        mv.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);</span><br><span class="line">        if (type == EnkelLexer.NUMBER) &#123;</span><br><span class="line">            mv.visitVarInsn(ILOAD, id);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(I)V&quot;, false);</span><br><span class="line">        &#125; else if (type == EnkelLexer.STRING) &#123;</span><br><span class="line">            mv.visitVarInsn(ALOAD, id);</span><br><span class="line">            mv.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(Ljava/lang/String;)V&quot;, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>GETSTATIC - 从<code>java.lang.System.out</code>获得静态属性，类型是 <code>java.io.PrintStream</code></li><li>ILOAD - 把局部变量入栈，id 是局部变量的索引</li><li>visitMethodInsn - 访问方法指令</li><li>INVOKEVIRTUAL - 触发实例方法 （调用 out 的 print 方法，该方法接受一个参数为整数类型，返回为空）</li><li>ALOAD - 和 ILOAD 类型，但是数据类型是引用</li></ul><h2 id="8-生成字节码"><a href="#8-生成字节码" class="headerlink" title="8. 生成字节码"></a>8. 生成字节码</h2><p><code>cw.toByteArray();</code> 执行后，ASM 创建一个 <code>ByteVector</code> 实例并把所有的指令加入进去。Java class 文件的结构为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1</span><br><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic; //CAFEBABE</span><br><span class="line">    u2             minor_version;</span><br><span class="line">    u2             major_version;</span><br><span class="line">    u2             constant_pool_count;</span><br><span class="line">    cp_info        constant_pool[constant_pool_count-1]; //string constants etc...</span><br><span class="line">    u2             access_flags;</span><br><span class="line">    u2             this_class;</span><br><span class="line">    u2             super_class;</span><br><span class="line">    u2             interfaces_count;</span><br><span class="line">    u2             interfaces[interfaces_count];</span><br><span class="line">    u2             fields_count;</span><br><span class="line">    field_info     fields[fields_count];</span><br><span class="line">    u2             methods_count;</span><br><span class="line">    method_info    methods[methods_count];</span><br><span class="line">    u2             attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>魔数（Magic Number）是 0xCAFEBABE。由于 Enkel 目前不支持字段，属性，父类或者接口，因此我们这里主要描述了 <code>method_info</code>。</p><h2 id="9-写入字节码到文件"><a href="#9-写入字节码到文件" class="headerlink" title="9. 写入字节码到文件"></a>9. 写入字节码到文件</h2><p>JVM 规范要求我们 .class 文件的名字必须和类型相同。所以我们这里保持文件名字和类名一直，仅替换后缀 (<em>enk -&gt; </em>.class)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Compiler.java</span><br><span class="line">private static void saveBytecodeToClassFile(String fileName, byte[] byteCode) throws IOException &#123;</span><br><span class="line">        final String classFile = StringUtils.replace(fileName, &quot;.enk&quot;, &quot;.class&quot;);</span><br><span class="line">        OutputStream os = new FileOutputStream(classFile);</span><br><span class="line">        os.write(byteCode);</span><br><span class="line">        os.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="10-验证字节码"><a href="#10-验证字节码" class="headerlink" title="10. 验证字节码"></a>10. 验证字节码</h2><p>我们可以使用 JDK 自带的 javap 工具来验证生成的字节码的正确性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">$ $JAVA_HOME/bin/javap -v file</span><br><span class="line"></span><br><span class="line">Classfile /home/kuba/repos/Enkel-JVM-language/file.class</span><br><span class="line">  Last modified 2016-03-16; size 335 bytes</span><br><span class="line">  MD5 checksum bcbdaa7e7389167342e0c04b52951bc9</span><br><span class="line">public class file</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Utf8               file</span><br><span class="line">   #2 = Class              #1             // file</span><br><span class="line">   #3 = Utf8               java/lang/Object</span><br><span class="line">   #4 = Class              #3             // java/lang/Object</span><br><span class="line">   #5 = Utf8               Test.java</span><br><span class="line">   #6 = Utf8               main</span><br><span class="line">   #7 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">   #8 = Utf8               java/lang/System</span><br><span class="line">   #9 = Class              #8             // java/lang/System</span><br><span class="line">  #10 = Utf8               out</span><br><span class="line">  #11 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #12 = NameAndType        #10:#11        // out:Ljava/io/PrintStream;</span><br><span class="line">  #13 = Fieldref           #9.#12         // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">  #14 = Utf8               java/io/PrintStream</span><br><span class="line">  #15 = Class              #14            // java/io/PrintStream</span><br><span class="line">  #16 = Utf8               println</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = NameAndType        #16:#17        // println:(I)V</span><br><span class="line">  #19 = Methodref          #15.#18        // java/io/PrintStream.println:(I)V</span><br><span class="line">  #20 = Utf8               \&quot;dupa\&quot;</span><br><span class="line">  #21 = String             #20            // \&quot;dupa\&quot;</span><br><span class="line">  #22 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #23 = NameAndType        #16:#22        // println:(Ljava/lang/String;)V</span><br><span class="line">  #24 = Methodref          #15.#23        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #25 = Utf8               Code</span><br><span class="line">  #26 = Utf8               SourceFile</span><br><span class="line">&#123;</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: bipush        5</span><br><span class="line">         2: istore_0</span><br><span class="line">         3: getstatic     #13                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         6: iload_0</span><br><span class="line">         7: invokevirtual #19                 // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        10: ldc           #21                 // String \&quot;dupa\&quot;</span><br><span class="line">        12: astore_1</span><br><span class="line">        13: getstatic     #13                 // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        16: aload_1</span><br><span class="line">        17: invokevirtual #24                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        20: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="11-运行-Enkel"><a href="#11-运行-Enkel" class="headerlink" title="11. 运行 Enkel"></a>11. 运行 <code>Enkel</code></h2><p>下面我们来运行第一个 Enkel 代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var five=5</span><br><span class="line">print five   </span><br><span class="line">var dupa=&quot;dupa&quot;  </span><br><span class="line">print dupa</span><br></pre></td></tr></table></figure><p>如果一切顺利的话，会有如下输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$java Compiler first.enk</span><br><span class="line">$java first</span><br><span class="line">5</span><br><span class="line">&quot;dupa&quot;</span><br></pre></td></tr></table></figure><p><em>译者注</em>：上述成品代码托管在 <a href="https://github.com/KevinOfNeu/Enkel/tree/PART-3" target="_blank" rel="noopener">Github</a></p><p>预告：下一节给 Enkel 增加一大坨特性，并定义好规范，方便后续迭代实现。</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Elm 入门指南 - 安装</title>
      <link href="/2018/04/11/Elm-guide-01/"/>
      <url>/2018/04/11/Elm-guide-01/</url>
      <content type="html"><![CDATA[<p>Elm 语言入门系列。<br><a id="more"></a></p><blockquote><p><strong>注:</strong> 如果你不想安装，可以使用<a href="http://elm-lang.org/try" target="_blank" rel="noopener">在线编辑器</a> 以及 <a href="http://elmrepl.cuberoot.in/" target="_blank" rel="noopener">在线 REPL</a>。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul><li>Mac &mdash; <a href="https://44a95588fe4cc47efd96-ec3c2a753a12d2be9f23ba16873acc23.ssl.cf2.rackcdn.com/Elm-Platform-0.18.pkg" target="_blank" rel="noopener">安装</a></li><li>Windows &mdash; <a href="https://44a95588fe4cc47efd96-ec3c2a753a12d2be9f23ba16873acc23.ssl.cf2.rackcdn.com/Elm-Platform-0.18.exe" target="_blank" rel="noopener">安装</a></li><li>Anywhere &mdash; <a href="https://www.npmjs.com/package/elm" target="_blank" rel="noopener">npm 安装</a> or <a href="https://github.com/elm-lang/elm-platform" target="_blank" rel="noopener">源码安装</a></li></ul><p>安装完毕后，下面的命令行工具可以使用:</p><ul><li><a href="#elm-repl"><code>elm-repl</code></a> &mdash; Elm REPL</li><li><a href="#elm-reactor"><code>elm-reactor</code></a> &mdash; 提高项目开发速度（原文:get a project going quickly）</li><li><a href="#elm-make"><code>elm-make</code></a> &mdash; 编译某个目录下的 Elm 代码</li><li><a href="#elm-package"><code>elm-package</code></a> &mdash; 下载 package</li></ul><p>在配置好编辑器后，我们再详细描述他们是怎么协同共工作的。</p><blockquote><p><strong>Troubleshooting:</strong> 提高学习速度最快的方式是参与到 Elm 社区和他们交流。我们愿意沟通和提供帮助！如果你遇到什么问题，欢迎来 <a href="http://elmlang.herokuapp.com/" target="_blank" rel="noopener">Elm Slack</a> 提问。事实上，这样节省你自己的时间。不要犹豫！</p></blockquote><h2 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a>配置编辑器</h2><p>好的编辑器可以在你学习 Elm 过程中助你一臂之力。下面的编辑器中都有 Elm  的插件:</p><ul><li><a href="https://atom.io/packages/language-elm" target="_blank" rel="noopener">Atom</a></li><li><a href="https://github.com/lepinay/elm-brackets" target="_blank" rel="noopener">Brackets</a></li><li><a href="https://github.com/jcollard/elm-mode" target="_blank" rel="noopener">Emacs</a></li><li><a href="https://github.com/durkiewicz/elm-plugin" target="_blank" rel="noopener">IntelliJ</a></li><li><a href="https://github.com/rundis/elm-light" target="_blank" rel="noopener">Light Table</a></li><li><a href="https://packagecontrol.io/packages/Elm%20Language%20Support" target="_blank" rel="noopener">Sublime Text</a></li><li><a href="https://github.com/ElmCast/elm-vim" target="_blank" rel="noopener">Vim</a></li><li><a href="https://github.com/sbrink/vscode-elm" target="_blank" rel="noopener">VS Code</a></li></ul><p>如果上面的编辑器你都不喜欢，那么 <a href="https://www.sublimetext.com/" target="_blank" rel="noopener">Sublime Text</a>  是个不错的选择！</p><p>你可以试试 <a href="https://github.com/avh4/elm-format" target="_blank" rel="noopener">elm-format</a>，帮助你格式化代码。</p><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>安装完 Elm 后你或许好奇 <code>elm-repl</code>, <code>elm-reactor</code>, <code>elm-make</code>, 和 <code>elm-package</code> 命令具体都是做什么的?</p><h3 id="elm-repl"><a href="#elm-repl" class="headerlink" title="elm-repl"></a>elm-repl</h3><p><a href="https://github.com/elm-lang/elm-repl" target="_blank" rel="noopener"><code>elm-repl</code></a> 让你做表达式求值(译者注： Read, Evaluate, Print, Loop)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ elm-repl</span><br><span class="line">---- elm-repl 0.18.0 -----------------------------------------------------------</span><br><span class="line"> :<span class="built_in">help</span> <span class="keyword">for</span> <span class="built_in">help</span>, :<span class="built_in">exit</span> to <span class="built_in">exit</span>, more at &lt;https://github.com/elm-lang/elm-repl&gt;</span><br><span class="line">--------------------------------------------------------------------------------</span><br><span class="line">&gt; 1 / 2</span><br><span class="line">0.5 : Float</span><br><span class="line">&gt; List.length [1,2,3,4]</span><br><span class="line">4 : Int</span><br><span class="line">&gt; String.reverse <span class="string">"stressed"</span></span><br><span class="line"><span class="string">"desserts"</span> : String</span><br><span class="line">&gt; :<span class="built_in">exit</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>我们将在 &ldquo;语言核心概念&rdquo; 章节使用 <code>elm-repl</code>，更多细节请阅读<a href="https://github.com/elm-lang/elm-repl/blob/master/README.md" target="_blank" rel="noopener">这里</a>。</p><blockquote><p><strong>注:</strong> <code>elm-repl</code> 将代码编译成 JavaScript 后执行, 确保你安装了 <a href="http://nodejs.org/" target="_blank" rel="noopener">Node.js</a> 。</p></blockquote><h3 id="elm-reactor"><a href="#elm-reactor" class="headerlink" title="elm-reactor"></a>elm-reactor</h3><p><a href="https://github.com/elm-lang/elm-reactor" target="_blank" rel="noopener"><code>elm-reactor</code></a> helps you build Elm projects without<br>messing with the command-line too much. You just run it at the root of your project, like this:</p><p><a href="https://github.com/elm-lang/elm-reactor" target="_blank" rel="noopener"><code>elm-reactor</code></a> 帮你一句命令搞定整个工程。你只需要在项目的根目录下指定如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/evancz/elm-architecture-tutorial.git</span><br><span class="line"><span class="built_in">cd</span> elm-architecture-tutorial</span><br><span class="line">elm-reactor</span><br></pre></td></tr></table></figure><p>这句命令在 <a href="http://localhost:8000" target="_blank" rel="noopener"><code>http://localhost:8000</code></a> 启动了一个服务。你可以浏览任何一个 Elm 文件，例如 <code>examples/01-button.elm</code>。</p><p><strong>值得注意的 flags:</strong></p><ul><li><code>--port</code> 指定端口号. 比如<br><code>elm-reactor --port=8123</code> 指定服务运行在 <code>http://localhost:8123</code>。</li><li><code>--address</code> 可以替换默认的 <code>localhost</code> 成其他的地址. 比如使用 <code>elm-reactor --address=0.0.0.0</code> 让你的服务监听局域网所有的请求。</li></ul><h2 id="elm-make"><a href="#elm-make" class="headerlink" title="elm-make"></a>elm-make</h2><p><a href="https://github.com/elm-lang/elm-make" target="_blank" rel="noopener"><code>elm-make</code></a> 用来编译 Elm  工程成 HTML 或者 JavaScript。这是最常用的编译 Elm 代码的方式，如果你的代码无需用<code>elm-reactor</code>调试，可以直接运行 <code>elm-make</code> 来构建。</p><p>假设你要编译 <code>Main.elm</code> 成 HTML 文件 <code>main.html</code>，你需要执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elm-make Main.elm --output=main.html</span><br></pre></td></tr></table></figure></p><p><strong>值得注意的 flags:</strong></p><ul><li><code>--warn</code> 打印警告语句以提高代码质量</li></ul><h3 id="elm-package"><a href="#elm-package" class="headerlink" title="elm-package"></a>elm-package</h3><p><a href="https://github.com/elm-lang/elm-package" target="_blank" rel="noopener"><code>elm-package</code></a> 用来下载和发布到<a href="http://package.elm-lang.org/" target="_blank" rel="noopener">package catalog</a>。作为社区成员解决问题<a href="http://package.elm-lang.org/help/design-guidelines" target="_blank" rel="noopener">更好的办法</a>，代码分享出来让大家使用才是王道！</p><p>假设你需要使用 <a href="http://package.elm-lang.org/packages/elm-lang/http/latest" target="_blank" rel="noopener"><code>elm-lang/http</code></a> 和 <a href="http://package.elm-lang.org/packages/NoRedInk/elm-decode-pipeline/latest" target="_blank" rel="noopener"><code>NoRedInk/elm-decode-pipeline</code></a> 来做网络请求，并且将返回的结果转换成 JSON，你可以这样做：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elm-package install elm-lang/http</span><br><span class="line">elm-package install NoRedInk/elm-decode-pipeline</span><br></pre></td></tr></table></figure><p>这句命令把依赖安装到 <code>elm-package.json</code> 文件。（<code>elm-package.json</code> 文件描述项目，如果没有的话，可以手动创建）,更多姿势请移步 <a href="https://github.com/elm-lang/elm-package" target="_blank" rel="noopener">这里</a>!</p><p><strong>值得关注的命令:</strong></p><ul><li><code>install</code>: 安装依赖到项目，并修改描述文件 <code>elm-package.json</code></li><li><code>publish</code>: 发布你的 Elm Package</li><li><code>bump</code>: 根据 API 改变来解决版本号之间的冲突</li><li><code>diff</code>: 查看两个 API 之间的区别</li></ul><blockquote><p>本文系<a href="https://github.com/evancz/guide.elm-lang.org" target="_blank" rel="noopener">原文</a>翻译。中文 <a href="https://github.com/KevinOfNeu/guide.elm-lang.org" target="_blank" rel="noopener">Repo</a>, Gitbook <a href="https://legacy.gitbook.com/book/kevinofneu/elm/details" target="_blank" rel="noopener">地址</a>。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Elm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Elm 入门指南 - 介绍</title>
      <link href="/2018/04/09/Elm-guide/"/>
      <url>/2018/04/09/Elm-guide/</url>
      <content type="html"><![CDATA[<p>Elm 语言入门系列。<br><a id="more"></a></p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>Elm 是一门编译成 <code>JavaScript</code> 的函数式编程语言。</strong> Elm 被用来创建网页应用，与 <code>React</code> 类似。 Elm 简单，易用，工具链强大。</p><p>本指南包含如下内容：</p><ul><li>Elm 编程语言的基础</li><li>如何用 <code>Elm 架构</code> 建构交互式的应用</li><li>强调 Elm 这种与语言无关强大的架构模式</li></ul><p>希望在指南结束后，你不仅能够用 Elm 创建网页应用，也能领悟到 Elm 的核心思想和设计模式。</p><p>如果你还在犹豫不决，我可以保证，只要你尝试一下 Elm，就可以写出更好的 <code>JavaScript</code> 以及 <code>React</code> 代码。</p><h2 id="迅速上手"><a href="#迅速上手" class="headerlink" title="迅速上手"></a>迅速上手</h2><p>Elm 非常棒！<br>这里有一个<a href="http://elm-lang.org/examples/buttons" target="_blank" rel="noopener">计数器</a>的例子。该案例的主要功能是做计数器做加减。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import Html exposing (Html, button, div, text)</span><br><span class="line">import Html.Events exposing (onClick)</span><br><span class="line"></span><br><span class="line">main =</span><br><span class="line">  Html.beginnerProgram &#123; model = 0, view = view, update = update &#125;</span><br><span class="line"></span><br><span class="line">type Msg = Increment | Decrement</span><br><span class="line"></span><br><span class="line">update msg model =</span><br><span class="line">  case msg of</span><br><span class="line">    Increment -&gt;</span><br><span class="line">      model + 1</span><br><span class="line"></span><br><span class="line">    Decrement -&gt;</span><br><span class="line">      model - 1</span><br><span class="line"></span><br><span class="line">view model =</span><br><span class="line">  div []</span><br><span class="line">    [ button [ onClick Decrement ] [ text &quot;-&quot; ]</span><br><span class="line">    , div [] [ text (toString model) ]</span><br><span class="line">    , button [ onClick Increment ] [ text &quot;+&quot; ]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p><em>注</em>：<code>update</code> 和 <code>view</code> 完全解耦。你可以用声明的方式描述 HTML 的内容，Elm 负责处理 DOM。</p><h2 id="为什么是一门函数式的语言？"><a href="#为什么是一门函数式的语言？" class="headerlink" title="为什么是一门函数式的语言？"></a>为什么是一门函数式的语言？</h2><p>忘记你所知道的关于函数式编程的一切吧。时尚的词汇，诡异的概念，糟糕的工具链，令人作吐。（<em>译者注</em>：这里并不一定是贬义词，无意冒犯）<br>Elm 不一样：</p><ul><li>无运行时错误。没有 <code>null</code>，<code>undefined</code> </li><li>友好的错误提示，帮你更快的写 <code>feature</code></li><li>随着代码量的增加，架构依然优秀</li><li>强制对 Elm package 进行语义化版本管理</li></ul><p>没有任何的 JS 库的组合可以给予你这些特性，然而这些在 Elm 中都是自带的。Elm 之所以如此强大是因为 Elm 构建在 40+ 年的带类型函数式编程语言的工作基础上。因此，Elm 是一门函数式的编程语言，你花费几个小时阅读这份文档对你的实践非常有帮助。</p><p>我已经非常尽力的让 Elm 更加容易学习和使用，请给 Elm 一次机会吧，然后再回头想想这番话。我希望你也能被 Elm 惊艳到。</p><blockquote><p>本文系<a href="https://github.com/evancz/guide.elm-lang.org" target="_blank" rel="noopener">原文</a>翻译。中文 <a href="https://github.com/KevinOfNeu/guide.elm-lang.org" target="_blank" rel="noopener">Repo</a>, Gitbook <a href="https://legacy.gitbook.com/book/kevinofneu/elm/details" target="_blank" rel="noopener">地址</a>。</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Elm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 2</title>
      <link href="/2018/04/07/Creating-JVM-Language-Part-2/"/>
      <url>/2018/04/07/Creating-JVM-Language-Part-2/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 翻译的第二篇。</p></blockquote><a id="more"></a><p>总的来说，我需要实现如下三个模块：</p><table><thead><tr><th>模块</th><th>输入</th><th>输出</th></tr></thead><tbody><tr><td>Lexer(词法分析器）</td><td>代码（文本格式）</td><td>Token 序列</td></tr><tr><td>Parse（语法分析器）</td><td>Token 序列</td><td>AST（抽象语法书）</td></tr><tr><td>Compiler（编译器）</td><td>AST</td><td>JVM 字节码</td></tr></tbody></table><h3 id="Lexer"><a href="#Lexer" class="headerlink" title="Lexer"></a>Lexer</h3><p>词法分析器的职责是把简单的文本输入，识别为 <code>Token</code>(可以理解为一种记号），代码，即文本文件在词法分析之前，仅仅是无意义的字节流而已，但 <code>Token</code> 不同，<code>Token</code> 记录的类型信息对接下来的步骤很重要。</p><h3 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h3><p>语法分析器的职责是把 <code>Token</code> 序列输入，组织成具有层次结构的抽象语法树（<code>AST</code>）, <code>AST</code> 决定了代码是被如何执行的。</p><h3 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h3><p>编译器的职责是遍历 <code>AST</code>，并且翻译成合法的 Java 字节码。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>假设有表达式 <code>int x=a*5+2</code>，处理流程如下图所示：<br><img src="https://kevinofneu-blog-static.oss-cn-beijing.aliyuncs.com/pssqj.png" alt=""></p><p><code>AST</code> 创建完毕后，就可以用 <code>Compiler</code> 生成字节码了。</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>手把手教你实现一门运行在 JVM 上的语言 Enkel, 系列 1</title>
      <link href="/2018/04/06/Creating-JVM-Language-Part-1/"/>
      <url>/2018/04/06/Creating-JVM-Language-Part-1/</url>
      <content type="html"><![CDATA[<blockquote><p>本文系 <a href="http://jakubdziworski.github.io/enkel/2016/03/10/enkel_first.html" target="_blank" rel="noopener">Creating JVM language</a> 的翻译, 原文作者 Jakub 花费 20 周的时间，从零开始，实现一门运行在 JVM 上的语言。我也准备花费 20 周的时间对原文做一次比较完备的翻译。</p></blockquote><a id="more"></a><p>正如我之前博客中提到的，我正在参加一个 “让自己知道” 的比赛。这个比赛的目的是做一个项目，并且用博客记录项目的开发过程。于是我想到了开发一个自己的基于 <code>JVM</code> 的语言和编译器（我没有理由不这么做）。</p><p>这个语言的名字我称之为 <code>Enkel</code>, 在瑞士语中表示简单的意思。</p><p>之所以让 <code>Enkel</code> 运行在 <code>JVM</code> 主要有以下几方面的考虑：</p><ul><li><code>JVM</code> 规范文档整理的很好</li><li><code>JVM</code> 语言可以混合调用（因此 <code>Enkel</code> 可以调用 Java 库）</li><li>我熟悉 Java 这门语言（词法分析器，语法分析器以及编译器均准备用 Java 编写）</li><li>Java 有一些很便捷的操作字节码的库（译者注：asm）</li><li>本人觉得 Java 语言有一些可以优化的点</li></ul><p>在接下来的十周，我将详细的描述 <code>Enkel</code> 的整个实现过程，坐稳，发车~</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Enkel </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>两种软件工程师与他们的工作态度</title>
      <link href="/2016/10/06/A-Tale-of-Two-Software-Engineers-and-Commitment/"/>
      <url>/2016/10/06/A-Tale-of-Two-Software-Engineers-and-Commitment/</url>
      <content type="html"><![CDATA[<p>Production上有个bug，工程师 Alice 承诺尽力修复，若晚上9点以前没修好，回家，第二天再继续做；<br>工程师 Bob 承诺不修复好就不回家。老板们会喜欢哪种工程师？</p><a id="more"></a><p>Bob 看上去很卖力，但很多只是急于表现、讨好上司、争取升职加薪，这种工程师看上去能熬夜，但白天精神不好，接下来连续几天精神都不好，效率变得更低。多数情况下的bug其实都没必要在精神状态不佳深夜修复。</p><p>做公司、创业、工作、人生都是马拉松，太早冲刺了后来就没劲了、就想休息了 — 就像很多人这辈子最大的成就发生在高考结束的那一刹那、或者拿到某某名公司offer的那一刹那。</p><p>本文系弯曲日报的<a href="https://wanqu.co/a/4005/2016-10-01-a-tale-of-two-software-engineers-and-commitment.html?s=social" target="_blank" rel="noopener">一篇分享</a>, 并对分享的<a href="https://codegrown.io/engineers-and-commitment/?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website" target="_blank" rel="noopener">原文</a>进行翻译。译文如下。</p><p>多年前当我还在创办<a href="https://soom.la/" target="_blank" rel="noopener">SOOMLA</a>的时候，我和创业伙伴就团队里工程师的工作态度进行激烈的讨论，为了证明他的观点，我的伙伴讲了一个寓言故事：</p><blockquote><p>Production上有个bug，有两个技术水平相当的工程师 Alice 和 Bob 作为修复问题的候选人，当前的情况他们都需要熬夜才能把这个 bug 修掉。但是他们的做法却不同：</p><ul><li>工程师 Alice:<br>承诺尽力修复，若晚上9点以前没修好，回家，第二天再继续做。</li><li>工程师 Bob：<br>承诺不修复好就不回家。</li></ul></blockquote><blockquote><p>然后两个工程师开始着手修复问题，最终两个人都在晚上八点把问题解决，然后回家了。那作为他们的上司，你会更喜欢哪个工程师呢？背后的原因是什么？</p></blockquote><h2 id="从短期角度得出的答案：贡献为王"><a href="#从短期角度得出的答案：贡献为王" class="headerlink" title="从短期角度得出的答案：贡献为王"></a>从短期角度得出的答案：贡献为王</h2><p>显然，最直接的答案就是我们更喜欢 Bob，因为他更有责任感，即便是加班也要完成。Bob 把组织利益放在第一位，自愿付出额外的劳动，而不求回报。许多管理者认为，这才是真正的贡献。</p><p>为什么呢？因为管理者想让团队众志成城。管理者通过打造一个自我管理的团队来从细微的管理工作中脱离出来，更多的去关心培训，管理以及创新工作。但是，管理者私底下也非常希望当有坑的时候，可以依靠一个非常有自我贡献意识的团队，这样管理者就无需每当紧急事故出现的时候孤军奋战。通常来讲，在实时大规模系统的团队中，这种贡献变成了一种对员工自然的期望，不遵守这种“潜规则”的人可能不受欢迎。</p><h2 id="长远来看得出的答案：可持续发展"><a href="#长远来看得出的答案：可持续发展" class="headerlink" title="长远来看得出的答案：可持续发展"></a>长远来看得出的答案：可持续发展</h2><p>Bob 作为一名高级工程师已经很长时间了，我最近改了自己的想法。假设线上问题随时可能会出现，并且有新需求不断地被来回的调整。从长期来看，Alice 会胜出。原因如下：</p><ul><li>1 当 Bob 不断的这样继续下去，一周，一个月甚至更多，他终究吃不消。晚上加班导致白天的工作效率低下，疲劳也会导致糟糕的代码和 Bug。休息不好的工程师经常会以我累了，请让我休息一下来拖延工作上的事情。</li><li>2 Bob 一直在不断去做贡献，事实上，他可能已经超出自己的控制了，希望通过这样得到上司的表扬或者是晋升（我并不是说渴望晋升是一件坏事请）。团队里其他一些资深的工程师，可能会将 Bob 疯狂的行为解读为不专注或者是把个人利益放在团队利益之上。有些人可能会觉得这是 <a href="http://www.forbes.com/sites/mikemyatt/2012/11/30/my-advice-on-managing-up-dont/#4e18fa8e514d" target="_blank" rel="noopener">“managing up”</a>的负面体现。</li></ul><p>打造一个公司（或者是一个产品）是一个长期的过程而不是一次冲刺，如果我们在这一点上达成共识，那么长期来看，Alice 比 Bob 更有奉献精神。进一步来讲，Bob 仅会在这些特殊情况下做出超额的贡献，主要是为了个人利益和职业发展，Bob 很有可能会在 Alice 之前离职。</p><h2 id="软件工程师为何害怕承诺"><a href="#软件工程师为何害怕承诺" class="headerlink" title="软件工程师为何害怕承诺"></a>软件工程师为何害怕承诺</h2><p>我想到了许多点（有一些是我以前经常遇见的）：</p><ul><li>我们担心手头上的工作不确定性太大</li><li>因为我们并不知道预计要投入的时间，所以我们宁愿不去承诺</li><li>我们不愿意加班错过回家吃晚饭的机会</li><li>我们不想被 tech lead，PM 或者销售团队打扰，这样我们就有更多的时间安静的来学习 JavaScript 框架的新特性</li><li>我们害怕被领导们训斥</li><li>我们仅仅是一群社交无能的怪人，无法应对指责</li></ul><p>但是有不同的观点：有时候做出一些承诺会胜过没有。这是学习和提高的关键。作为工程师，我们需要不断的提高自己的技能。通过做出一些承诺，不断挑战自己，并使得自己更加聪明的工作，给出更加客观的估时，最终带领团队进步。这种建议对于那些想要在管理路线有所进步的人来说尤为正确。我至今还没有遇见过对于交付不做承诺的研发 VP，也没有见过销售 VP 对完成交易不做承诺。其中技巧就是，不要做过度的承诺以免自己无法承受。</p><h2 id="进一步思考"><a href="#进一步思考" class="headerlink" title="进一步思考"></a>进一步思考</h2><p>我的妻子经常提醒我：我们终究是工程师，不是脑外科医生。在工作中，出于个人责任和义务的考虑，这条建议也适用，这里没有（通常情况下）没有岌岌可危的生命需要救治，仅仅是工作而已。在特殊的业务场景面前，我们不应该以一种成熟或专业的姿态来做承诺，你同事和上司的一致好评是对你额外付出最好的汇报，但是不能每天都这样下去。我们可以按时下班，第二天精神焕发的继续，世界貌似并没有因此而变得不完整。生产环境上的问题不断的发生，也不断地被修复 - 留得青山在，可持续发展。</p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> 软件 </tag>
            
            <tag> 人文 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>S.O.L.I.D 原则在 Go 中的应用（下）</title>
      <link href="/2016/09/21/solid-go-design-2/"/>
      <url>/2016/09/21/solid-go-design-2/</url>
      <content type="html"><![CDATA[<blockquote><p>接上一篇~深夜看完釜山行，写会博客压压惊(咦？读起来好押韵啊)。写上一句的妹子被抓走了，我来善后，我没有那么多图<br>可以插！</p></blockquote><a id="more"></a><p><a href="http://dave.cheney.net/2016/08/20/solid-go-design?utm_source=wanqu.co&amp;utm_campaign=Wanqu+Daily&amp;utm_medium=website" target="_blank" rel="noopener">原文链接</a></p><p>原文作者：<a href="http://dave.cheney.net/about" target="_blank" rel="noopener">Dave Cheney</a></p><p><a href="yemengying.com/2016/09/11/solid-go-design-1/">S.O.L.I.D 原则在 Go 中的应用 -上 传送门</a></p><h4 id="里式替换原则"><a href="#里式替换原则" class="headerlink" title="里式替换原则"></a>里式替换原则</h4><p>里式替换原则由 <code>Barbara Liskov</code> 提出，如果两个类型表现的行为对于调用者来说没有差别，那么我们就可以认为这两个类型是可互相替换的。</p><p>在面向对象的语言中，里式替换原则通常解释为一个抽象基类拥有继承它的许多具体的子类。但 Go 中并没有类或继承，所以无法通过类的继承来实现替换。</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><p>但是，我们可以通过接口实现替换。在 Go 中，类型并不需要指定他们实现的接口，只要在类型中提供接口要求的所有方法即可。</p><p>所以，Go 中的接口是隐式的(非侵入性的)，而非显式的。这对于我们如何使用这门语言有着深远的影响。</p><p>一个好的接口应该是小巧的，比较流行的做法是一个接口只包含一个方法。因为一般情况下，小的接口往往意味着简洁的实现。</p><h5 id="io-Reader"><a href="#io-Reader" class="headerlink" title="io.Reader"></a>io.Reader</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">        // Read reads up to len(buf) bytes into buf.</span><br><span class="line">        Read(buf []byte) (n int, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面让我们看下 Go 中我最爱的接口—<code>io.Reader</code>。</p><p><code>io.Reader</code> 接口的功能非常简单；将数据读取到提供的缓冲区中，并返回读取的字节数以及读取过程中遇到的错误。虽然看上去简单，但是确非常有用。</p><p>因为<code>io.Reader</code>可以处理任何可以表示为字节流的东东，我们几乎可以为所有东西构造读取器；比如：一个常量字符串，字节数组，标准输入，网络流，tar 文件，通过 ssh 远程执行命令的标准输出，等等。</p><p>而由于实现了同样的接口，这些具体实现都是互相可替换的。</p><p>我们可以用 <code>Jim Weirich</code> 的一句话来描述里式替换原则在 Go 中的应用。</p><blockquote><p>Require no more, promise no less。</p></blockquote><p>好，下面让我们继续看 SOLID 的第四个原则I。 </p><h4 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h4><p>第四个原则是接口隔离，Robert C. Martin 解释为：</p><blockquote><p>调用者不应该被强制依赖那些他们不需要使用的方法。</p></blockquote><p>在 Go 中，接口隔离原则的应用可以参考如何分离一个函数功能的过程。举个例子，我们需将一份文档持久化到磁盘。函数签名可以设计如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save 方法将文档的内容写到文件f</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(f *os.File, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>我们定义的 Save 方法，将 <code>*os.File</code> 作为文档写入的目标，这样的设计会有一些问题。</p><p>Save 方法的签名设计排除了将文档内容存储到网络设备上的可能。假设后续有将文档存储到网络存储设备上的需求，Save 方法的签名需要做出相应的改变，导致所有 Save 方法的调用方也需要做出改变。</p><p>由于 Save 方法直接在磁盘上操作文件，导致对测试不友好。为了验证 Save 所做的操作，测试需要在文档写入后从磁盘上读取文档内容来做验证。 除此之外，测试还要确保文件被写入到临时空间，之后被删除。</p><p><code>*os.File</code> 定义了许多与 Save 操作不相关的方法，比如读取文件目录，检查一个路径是否是符号链接。如果 Save 方法的签名只描述 <code>*os.File</code> 部分相关的操作会更有帮助。</p><p>我们应该如何解决这些问题呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save 方法将文档文档内容写入到指定的ReadWriterCloser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(rwc io.ReadWriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>使用 <code>io.ReadWriteCloser</code> 我们可以根据接口隔离原则来重新定义 Save 方法，将更通用的文件描述接口作为参数。</p><p>重构后，任何实现了 <code>io.ReadWriteCloser</code> 接口的类型都可以替代之前的 <code>*os.File</code> 接口。这扩大了 Save 方法的应用场景，相比使用 <code>*os.File</code> 接口，Save 方法对调用者开说变得更加透明。</p><p>Save 方法的编写者也无需关心 <code>*os.File</code> 包含的那些不相关的方法，因为这些细节都被 <code>io.ReadWriteCloser</code> 接口屏蔽掉了。我们还可以进一步将接口隔离原则发挥一下。</p><p>首先，如果 Save 方法遵循单一职责原则，方法不应该读取文件内容来对刚写入的内容做验证，这应该是另一个代码片段应该做的事。因此，我们进一步细化传递给 Save 方法的接口定义，仅保留写入和关闭的功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save 方法将文档文档内容写入到指定的WriterCloser</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(wc io.WriteCloser, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p><em>译者注：注意，这里接口名字是io.WriteCloser，而上一个签名的参数是io.ReadWriterCloser</em></p><p>其次，根据我们所期望的通用文件描述所具备的功能，给 Save 方法提供关闭流的机制。但是这会引发一个新的问题： <code>wc</code> 在什么时机关闭。Save 方法可以无条件的调用 Close 方法，或者是 Close 方法在执行成功的条件下才会被调用。</p><p>不管哪种关闭流的方式都会产生个问题，因为 Save 方法的调用者可能希望在写入的文档的流后面追加数据，而此时流已经被关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> NopCloser <span class="keyword">struct</span> &#123;</span><br><span class="line">    io.Writer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 重写 Close 方法，提供空实现</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *NopCloser)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br></pre></td></tr></table></figure><p>如上示例代码所示，一种粗暴的做法就是重新定一个类型，组合了 <code>io.Writer</code> , 重写 Close 函数，替换为空实现，防止 Save 方法关闭数据流。</p><p>但是，这违反了里氏替换原则，因为 NopCloser 并没有真正关闭流。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Save 方法将文档文档内容写入到指定的Writer</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Save</span><span class="params">(w io.Writer, doc *Document)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><p>一种更加优雅的解决方案是重新定义 Save 方法的参数，将 <code>io.Writer</code> 作为参数，把 Save 方法的职责进一步细化，除了写入数据，其他不相关的事情都不做。</p><p>通过将接口隔离原则应用到 Save 方法，把方法功能更加明确化，它仅需要一种可以写入的东西就可以。方法的定义更具有普适性，现在我们可以使用Save 方法去保存数据到任何实现了 <code>io.Writer</code> 的设备。</p><blockquote><p>Go 中非常重要的一个原则就是接受interface，返回structs。 – Jack Lindamood</p></blockquote><p>上述引言是 GO 在这些年的发展过程中渗透到 GO 设计思想里中的非常有意思的约定。</p><p>Jack 的精悍言论可能跟实际会有细微差别，但是我认为这是 Go 设计中颇具有代表性的声明。</p><h4 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h4><p>最后一个原则是依赖倒置。可以这样理解：</p><blockquote><p>上层模块不应该依赖于下层模块，他们都应该依赖于抽象。<br>抽象不应依赖于实现细节，实现细节应该依赖于抽象。 – Robert C. Martin</p></blockquote><p>那么，对于 Go 语言开发者来讲，依赖倒置具体指的是什么呢？</p><p>如果你应用了我们上面讲述的4个原则，那么你的代码已经组织在独立的 package 中，每一个包的职责都定义清晰。你的代码的依赖声明应该通过接口来实现，这些接口仅描述了方法需要的功能行为，换句话说，你不需要为此做太多的改变。</p><p>因此我认为,在 Go 语言中，Martin 所讲的依赖倒置是你的依赖导入的结构。</p><p>在 Go 语言中，你的依赖导入结构必须是非循环的，不遵守此约定的后果是可能会导致编译错误，但是更为严重的是设计上的错误。</p><p>良好的依赖导入结构因该是平坦的，而不是层次结构很深。如果你有一个包，在没有其他包的情况下，不能正常工作，这可能你的代码包的组织结构没有划分好边界。</p><p>依赖倒置原则鼓励你将具体实现细节尽可能的放到依赖导入结构的最顶层，在 main package 或者更高层级的处理程序中，让低层级的代码去处理抽象的接口。 </p><h4 id="SOLID-Go-设计"><a href="#SOLID-Go-设计" class="headerlink" title="SOLID Go 设计"></a>SOLID Go 设计</h4><p>简要回顾一下，在将 SOLID 应用到 Go 语言时，每一个原则都陈述了其设计思想，但是所有原则都遵循了同一个中心思想。</p><p>单一职责原则鼓励你组织 function，type 到高内聚的包中，type 或者方法都应该有单一的职责。</p><p>开闭原则鼓励你通过组合简单类型来表达复杂类型。</p><p>里氏替换原则鼓励你通过接口来表达包之间的依赖关系，而非具体的实现。通过定义职责明确的接口，我们可以确保其具体实现足以满足接口契约。</p><p>接口隔离原则将里氏替换原则进一步提升，鼓励你在定义方法或者函数的时候仅包含他所需要的功能。如果仅需要一个 interface 类型的参数的方法就可以满足业务功能，那么我们可以认为这也满足了单一职责原则。</p><p>依赖倒置原则鼓励将你的 package 的依赖从编译阶段推迟到运行时，这样可以减少 import 的数量。</p><p>一句话来总结以上讲述: 善用 interface 可以将 SOLID 原则应用到 Go 编程中。</p><p>因为interface 让你将关注点放在描述包的接口上，而非具体的实现，这也是实现解耦的另一种方式，实际上这也是我们设计的目标，松耦合的软件更容易对修改开放。</p><p>就像 Sandi Metz 所说的：</p><blockquote><p>软件设计的艺术就是合理组织代码，不仅能让它正常工作，也总是能够对修改开放。</p></blockquote><p>如果 Go 作为一家公司从长远角度所做出的技术选型，那么对修改开放的特性必然是他们在做决策时非常认可的一个因素。</p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>最后，回到演讲开始抛出的问题，到底有多少 Go 程序员？我的猜测是：到2020年，将有 500,000 名 Go 开发者。</p><p>这 50 万 Go 开发者都会做些什么呢？显然，他们会写很多 Go 的代码，坦诚的说，这些代码并非都是好的，甚至一些是坏的实践。</p><p>这不是耸人听闻，在座的各位，从其他语言转到 Go 的阵营，以大家的经验来谈，这个预言不是空穴来风。</p><blockquote><p>C++ 的世界，只需用一部分语法就可以形成一种新的更简洁的语言。  – Bjarne Stroustrup</p></blockquote><p><em>译者注：这里主要说明 C++ 过于复杂，并且臃肿冗余</em></p><p>Go 要成为一门成功的语言需要靠大家的努力，不要像 C++ 那样搞得一团糟，被我们吐槽。</p><p>臃肿，啰嗦，过于复杂，其他语言被喷的槽点有一天可能也会发生在 Go 身上，我不希望看到这一幕，所以我有一个小小的请求：</p><p>作为 Go 开发者，少谈论一些框架，多谈论一些设计，并且我们要不惜一切代价去关注代码重用而非性能。</p><p>我希望看到的是人们在讨论如何使用当下的语言来解决实际问题，不论这门语言是什么，有什么限制。</p><p>我希望听到的是人们在谈论如何写精心设计，解耦的，可重用，对改变开放的 Go 程序。</p><h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>今天我们齐聚一堂，来聆听讲师们的演讲，但是现实是，相对于即将使用 Go 语言的开发者的数量而言，我们仅仅是大海中的一叶扁舟。</p><p>因此，我们有义务告诉他们应该如何编写设计良好的软件，可组合的软件，对修改开放的软件，使用 Go 语言如何实现，而这些需要从你开始做起。</p><p>我希望当你在谈论设计的时候，我今天所说的观点对你有所帮助，也希望你能自己做些研究工作，并应用到工程中去，然后希望你能够做以下事情：</p><ul><li>写一篇相关的博客</li><li>在研讨会上分享你所做的事情</li><li>把你所学的东西写成一本书</li><li>明年再来参加会议的时候讲讲你取得的成就</li></ul><p>通过做这些事情，我们可以在关心代码设计的 Go 开发者中建立起一种文化。</p><p>最后谢谢大家！</p><h4 id="相关博客"><a href="#相关博客" class="headerlink" title="相关博客"></a>相关博客</h4><ul><li><a href="http://dave.cheney.net/2014/12/24/inspecting-errors" target="_blank" rel="noopener">Inspecting errors</a></li><li><a href="http://dave.cheney.net/2016/03/19/should-methods-be-declared-on-t-or-t" target="_blank" rel="noopener">Should methods be declared on T or *T</a></li><li><a href="http://dave.cheney.net/2014/06/27/ice-cream-makers-and-data-races" target="_blank" rel="noopener">Ice cream makers and data races</a></li><li><a href="http://dave.cheney.net/2013/11/14/stupid-go-declaration-tricks" target="_blank" rel="noopener">Stupid Go declaration tricks</a></li></ul><p><img src="http://7xr586.com1.z0.glb.clouddn.com/qrcode.jpg" alt="扫码关注微信公众号，及时订阅更新"></p>]]></content>
      
      
        <tags>
            
            <tag> 翻译 </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2016读书计划</title>
      <link href="/2016/02/26/books-read-plan-2016/"/>
      <url>/2016/02/26/books-read-plan-2016/</url>
      <content type="html"><![CDATA[<blockquote><p>为学读书，须是耐心，细意去理会，切不可粗心。为数重物，包裹在里面，无缘得见。必是今日去一重，又见得一重。<br>明日又去一重，又见得一重。去尽皮，方见肉。去尽肉，方见骨。去尽骨，方见髓。——朱熹<br><a id="more"></a></p></blockquote><p><img src="https://images.unsplash.com/photo-1437843947241-9e73e69172fb?ixlib=rb-0.3.5&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;w=1600&amp;h=900&amp;fit=crop&amp;s=0c4d0d89cae35dba80e9f064ffd71b31" alt=""></p><p>造烛求明，读书求理。人活着，总是要读点书的。下面就列出了庐主2016年的读书计划：每个月读一本书籍。<br>目标：2016年结束的时候，书单中应该至少有12本书的进度为已完成。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">书籍</th><th style="text-align:left">进度</th><th style="text-align:left">分类</th><th style="text-align:left">推荐指数</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="http://book.douban.com/subject/26297606/" target="_blank" rel="noopener">《从0到1》</a></td><td style="text-align:left">完成 2016.01</td><td style="text-align:left">商业 互联网 创业</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="http://book.douban.com/subject/1092335/" target="_blank" rel="noopener">《教父Ⅰ》</a></td><td style="text-align:left">完成 2016.02</td><td style="text-align:left">小说 黑帮</td><td style="text-align:left">★★★★★</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="http://book.douban.com/subject/2567698/" target="_blank" rel="noopener">《三体Ⅰ》</a></td><td style="text-align:left">完成 2016.01</td><td style="text-align:left">小说 科幻</td><td style="text-align:left">★★★☆☆</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="http://book.douban.com/subject/3709579/" target="_blank" rel="noopener">《大教堂和市集》</a></td><td style="text-align:left">完成 2016.02</td><td style="text-align:left">管理 软件开发</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">《Docker-从入门到实践》</a></td><td style="text-align:left">完成 2016.01</td><td style="text-align:left">计算机 Docker</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="http://book.douban.com/subject/3066477/" target="_blank" rel="noopener">《三体Ⅱ&amp;Ⅲ》</a></td><td style="text-align:left">完成 2016.03</td><td style="text-align:left">小说 科幻</td><td style="text-align:left">★★★★★</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><del><a href="http://book.douban.com/subject/26008422/" target="_blank" rel="noopener">《How Google Works》</a></del></td><td style="text-align:left">进行中</td><td style="text-align:left">互联网 创业</td><td style="text-align:left">预期★★★★★</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="http://book.douban.com/subject/1770782/" target="_blank" rel="noopener">《追风筝的人》</a></td><td style="text-align:left">完成 2016.03</td><td style="text-align:left">阿富汗 小说</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="http://book.douban.com/subject/1092335/" target="_blank" rel="noopener">《教父Ⅱ》</a></td><td style="text-align:left">完成 2016.03</td><td style="text-align:left">小说 黑帮</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><del><a href="http://book.douban.com/subject/1092335/" target="_blank" rel="noopener">《教父Ⅲ》</a></del></td><td style="text-align:left"><del>进行中</del></td><td style="text-align:left">小说 黑帮</td><td style="text-align:left">预期★★★★★</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="http://book.douban.com/subject/26306686/" target="_blank" rel="noopener">《创业维艰》</a></td><td style="text-align:left">计划</td><td style="text-align:left">互联网 创业</td><td style="text-align:left">预期★★★★☆</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="http://book.douban.com/subject/25928983/" target="_blank" rel="noopener">《周鸿祎自述》</a></td><td style="text-align:left">计划</td><td style="text-align:left">互联网 产品</td><td style="text-align:left">预期★★★★☆</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://book.douban.com/subject/11577300/" target="_blank" rel="noopener">《Go 语言编程》</a></td><td style="text-align:left">完成 2016.10</td><td style="text-align:left">技术 语言类</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="">《大型分布式网站架构设计与实践》</a></td><td style="text-align:left">完成 2016.9</td><td style="text-align:left">技术 架构</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="">《大型网站技术架构》</a></td><td style="text-align:left">完成 2016.8</td><td style="text-align:left">技术 架构</td><td style="text-align:left">★★★★☆</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><a href="http://item.jd.com/11826753.html" target="_blank" rel="noopener">《微服务架构与实践》</a></td><td style="text-align:left">完成 2016.7</td><td style="text-align:left">技术 微服务</td><td style="text-align:left">★★★☆☆</td></tr></tbody></table><p><em>Updated 2016 11.13</em>：计划要读的很多书许多搁浅了，最近看完的书基本都列出来了。目前来看，掂过碌蔗~划掉的基本是半途而废没有坚持下来的。</p><p><em>备注</em>：各位客官，可点击书籍名称会跳转到有详细的介绍。如果你有比较好的书籍，欢迎留言推荐~</p><p><strong>结束语</strong>：回头翻自己的博客，以为这个计划没有完成，结果仔细想了想，最近完整看完的书，其实还是完成的了。最后四本书其实自己也忘记准确的完成日期了，之所以完成日期分开来，主要是为了数据好看，哈哈~最后再说下自己的感言吧，其实自己是有些忘记这个计划的，因为很久没有更新自己的博客了，恩，发现这是一个很不好的习惯，有些东西开始了，就要很认真的去完成，幸运的是，我一开始连续看了不少书， 基础打好了，而且形成习惯了，因为后面能完成计划纯属是因为之前的惯性。但是没有及时更细自己的博客是个非常不好的习惯。</p><p>再说说自己最近还在坚持的一件事情，那就是每天上下班的地铁上（地铁上班平均消耗1.6小时每天）背完了托福的词汇，可能记忆的不是非常牢固，但是好歹也是自己从头至尾，坚持了三个月的时间完成的一刷。相比路上发呆，玩手机，刷朋友圈，这种知识的收获让我每天感到特别的有成就感，尤其是当我完成的时候，幸福感爆棚~</p><p>总之这两个件事让我意识到，做好计划，充分利用好时间，可以做许多许多的事情。</p>]]></content>
      
      
        <tags>
            
            <tag> 书籍 </tag>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
